[toc]
### 数组
#### 一维数组的存储空间是连续的，那么二维数组？
- 取决于语言实现。C++是连续分布；Java由虚拟机完成寻址操作，不是连续分布。
#### 704 二分查找
- 直接用循环二分查找即可，不一定要递归
```c++
int search(vector<int>& nums, int target) {
    int low = 0;
    int len = nums.size();
    int high = len - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (mid >= len) return -1;
        if (nums[mid] == target) return mid;
        if (nums[mid] > target) {
            high = mid -1;
        } else {
            low = mid + 1;
        }
    }
    return -1;v
}
```
#### 209 长度最小的子数组
- 为什么认为需要双指针法？
    - 很可能需要回溯起始位置，来保证每个子数组都检查到。回溯这一操作需要双指针来完成
```C++
 int minSubArrayLen(int target, vector<int>& nums) {
    int slowIndex=0, fastIndex=0, total=0, minLength=1e5;
    int len = nums.size();
    while (slowIndex < len) {
        // 特殊情况处理，剪枝
        if (fastIndex >= len && total < target) break;
        if (total < target && fastIndex < len) {
            total += nums[fastIndex];
            fastIndex++;
        } else {
            minLength = min(fastIndex - slowIndex, minLength);
            total -= nums[slowIndex];
            slowIndex++;
        }
    }
    if (minLength == 1e5) return 0;
    return minLength;
}
```
#### 59 螺旋矩阵2
```c++
// n*n 二维向量的初始化
vector<vector<int>> res(
    n,
    vector<int>(n)
)
// 二维数组的初始化
int direction[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
```
#### 三数之和
- 仍然是双指针法的应用
- for 循环 遍历起始位置 i
- left 从 i+1 开始， right 从 len-1 开始
- 三数之和小于0 left++
- 三数之和大于0 right--
- ==0 加入向量， left++, right--
```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    int len = nums.size();
    if (len < 2) return res;
    sort(nums.begin(), nums.end());
    for (int i=0; i<len-2;i++) {
        int left = i+1;
        int right = len-1;
        if (i>=1 && nums[i] == nums[i-1]) continue; // 去重
        if (nums[i] > 0) break;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] < 0) {
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
            }
            else if (nums[i] + nums[left] + nums[right] > 0) {
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
            else if (nums[i] + nums[left] + nums[right] == 0) {
                // 以下五行可化简为: res.push_back(vector<int>({nums[i], nums[left], nums[right]}));
                vector<int> cur;
                cur.push_back(nums[i]);
                cur.push_back(nums[left]);
                cur.push_back(nums[right]);
                res.push_back(cur);
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
        }
    }
    return res;
```
- **另外的注意点--去重**
- left++, 实际上需要跳过所有相等的值, right--同理
- 
```c++
do {
    left++;
} while(left < len && nums[left] == nums[left-1]);
```
- 遍历i 时，跳过和前一个值相等的
```c++
if (i>=1 && nums[i] == nums[i-1]) continue;
```
### 链表
#### 基础知识
- 链表节点不是连续分布，而是散乱分布
- c++ 链表定义方式
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}; // 构造函数

}
```
- **添加虚拟头结点，可以同化对所有节点的操作，降低复杂度**
#### 203.移除链表元素
- 体现虚拟头结点的作用
```c++
ListNode* removeElements(ListNode* head, int val) {
    ListNode* vHead = new ListNode(0, head);
    ListNode* prev = vHead;
    ListNode* cur = vHead -> next;
    while (cur != NULL) {
        if (cur -> val == val) {
            prev -> next = cur -> next;
            cur = cur -> next;
        } else {
            prev = cur;
            cur = cur -> next;
        }
    }
    return vHead -> next;
}
```
- 仍然存在问题，别忘了释放空间！（虚拟头节点 + 被删除的节点）
```c++
ListNode* tmp;
delete(tmp);
```
### 哈希表
#### 例子
- 学生名字 通过 hashFunction, 得到索引
- 通过索引直接访问对应数据
- 作用：快速判断一个元素是否出现在集合中
#### 数据结构选用
##### Set
- 优先选用std:unordered_set, 查询和增删效率最优
- 需要集合有序：std:set
- 有序加重复数据: std:multi_set
#### 1002. 查找常用字符
- 数组中的每个字符串，对应一个26位数组，存储每个字母出现的频率
- 两个 26 维数组取最小值，符合“所有字符串都显示”这一定义
- 小技巧
    - 数组初始化 int hash[26] = {0};
    - char to string: string s(1, i + 'a');
```c++
vector<string> commonChars(vector<string>& words) {
    vector<string> result;
    int len = words.size();
    if (!len) {
        return result;
    }
    int hash[26] = {0};
    string word = words[0];
    for (int i=0; i< word.length(); i++) {
        hash[word[i] - 'a'] += 1;
    }
    for (int i=1; i< words.size(); i++) {
        int hashOther[26] = {0};
        string word = words[i];
        for (int i=0; i< word.length(); i++) {
            hashOther[word[i] - 'a'] += 1;
        }
        for (int i=0; i<26; i++) {
            hash[i] = min(hash[i], hashOther[i]);
        }
    }
    for (int i=0; i<26; i++) {
        while (hash[i] > 0) {
            string s(1, i + 'a');
            result.push_back(s);
            hash[i]--;
        }
    }
    return result;
}
```
### 字符串
#### 344.反转字符串
- 简单的双指针法
#### 541. 反转字符串2
- 反转部分可以通过循环完成: 起始:low, 终止: high
- 每 2k 字符进行反转：循环完成
- 检查 len - i < k?
```c++
void reverse(string &s, int low, int high) {
  for (int i=0; i<= (high - low) /2; i++) {
    char tmp = s[low + i];
    s[low + i] = s[high - i];
    s[high - i] = tmp;
  }
}
string reverseStr(string s, int k) {
  int len = s.length();
  for (int i=0; i< len; i += 2*k) {
    if (len - i < k) {
        reverse(s, i, len-1);
    } else {
        reverse(s, i, min(len-1, i+k-1));
    }
  }
  return s;
}
```
#### 剑指 Offer 58 - II. 左旋转字符串
- 在不添加额外空间的前提下进行旋转
- 提示: 整体反转 + 局部反转
### 栈和队列
#### 20.有效的括号
- 匹配问题可应用栈
- 遇到左括号 入栈
- 遇到右括号 出栈 看是否匹配
- 未遍历完成，栈空 || 遍历完成，栈非空，则无效
#### 150. 逆波兰表达式求值
- 还是栈的应用
- string to int: stoi()
#### 347. 前k个高频元素

基本思路
```
// 首先是 unordered_map 统计每个数出现频率
// Topk 计算：当然可以对整个 map 进行排序，但由于是大数问题，可能超时
// 更好的方法:
// TopK 问题用堆来解决
// 利用 priority_queue 实现堆，（小顶堆），超出 k 时，最小的那个元素出队，则最后剩下的是 k个频率最高的元素
```

涉及很多数据结构的使用，归纳如下
```c++
priority_queue: 优先级队列，实际上就是一个堆
堆: 堆是一颗完全二叉树，树中每个结点的值都>=(大顶堆) 或 <=(小顶堆) 其左右孩子的值
priority_queue 的缺省实现是大顶堆

priority_queue 的构造函数
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> 

对应
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

std:less 需要实现 bool operator()(const T& lhs, const T& rhs );
```

代码
```c++
class mycomparison {
public:
    // 为什么 左大于右是小顶堆？ 和 priority_queue的实现有关
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
vector<int> topKFrequent(vector<int>& nums, int k) {
    // 要统计元素出现频率
    unordered_map<int, int> map; // map<nums[i],对应出现的次数>
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]]++;
    }

    // 对频率排序
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

    // 用固定大小为k的小顶堆，扫面所有频率的数值
    for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
        pri_que.push(*it);
        if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
            pri_que.pop();
        }
    }

    // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
    vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = pri_que.top().first;
        pri_que.pop();
    }
    return result;

    }
```
### 二叉树
#### 相关定义
- 满二叉树：只有度数为0和度数为2的节点，且度数为0节点在同一层
- 完全二叉树：只有最下层节点可以没填满，且最下层节点集中在最左边
- 二叉搜索树：左子树小于根结点，右子树大于根结点
- 平衡二叉搜索树：二叉搜索树基础上，左右子树高度差不超过1
#### 顺序存储
- 左孩子：2i+1, 右孩子: 2i+2
#### 遍历
##### 深度优先
- 往深处走，遇到叶子结点再往回
- 前序： 中左右
- 中序： 左中右 
- 后序： 左右中
##### 广度优先
- 一层一层遍历
- 层序遍历
#### 数据结构定义
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x), left(NULL), right(NULL) {}
};
```
#### 递归遍历三部曲 （前序遍历为例）
- 递归函数的参数和返回值
```c++
// 当前节点 和 存储遍历值的 vector
void traverse(TreeNode* cur, vector<int>& vec)
```
- 结束条件
```c++
if (cur == NULL) return;
```
- 单层递归逻辑
```c++
vec.push_back(cur->val); //中
traverse(cur->left, vec); //左
traverse(cur->right, vec); //右
```
#### 226. 翻转二叉树
```c++
// 实现一个swap 函数，交换 cur->left, cur->right
// 递归函数
void recur(TreeNode* cur);

// 结束条件
if (cur == NULL) return;

// 递归逻辑
swap(cur);
recur(cur->left);
recur(cur->right);
```
#### 102 层序遍历
- 需要用到一个辅助队列，用到其先进先出的特性
- 同一层的元素归类到vector 的同一维如何实现？读取队列的大小，该大小代表该层的节点数
- 元素出队 --> val加入vector --> 孩子结点入队
#### 106. 从中序与后序遍历序列构造二叉树
- 依然需要递归
- 思路
```
// 中序 左中右 [9, 3, 15, 20, 7]
// 后序 左右中 [9, 15, 7, 20, 3]
// 递归, 参数为中序 后序数组
// 1. 只有一个节点，返回该结点即可
// 2. 找到中间节点 --> 后序数组 最后一个，中序数组按值查找
// 3. 划分中序的左子树，右子树，后序的左子树 右子树 (左闭右开原则)
// 4. 递归构建左子树，右子树
```
- 代码
```c++
TreeNode* recur(vector<int> inorder, vector<int> postorder) {
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);
    if (postorder.size() == 1) return root;
    int rootIndex;
    // 找到中序遍历中的根结点位置
    for (rootIndex = 0; rootIndex < inorder.size(); rootIndex++) {
        if (inorder[rootIndex] == rootValue) break;
    }
    // vector 的构造 可以通过 iterator 完成
    vector<int> inorderLeft(inorder.begin(), inorder.begin() + rootIndex);
    vector<int> inorderRight(inorder.begin() + rootIndex + 1, inorder.begin() + inorder.size());

    // 一个比较巧的地方，后序遍历的左子树部分，长度和中序遍历左子树一致
    vector<int> postorderLeft(postorder.begin(), postorder.begin() + inorderLeft.size());
    vector<int> postorderRight(postorder.begin() + inorderLeft.size(), postorder.begin()+ postorder.size()-1);

    // 这里做一个预处理，数组为空，说明子树为 NULLv
    root -> left = inorderLeft.size() > 0 ? recur(inorderLeft, postorderLeft): NULL;
    root -> right = inorderRight.size() > 0 ? recur(inorderRight, postorderRight): NULL;
    return root;
}
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if (inorder.size() < 1) return NULL;
    return recur(inorder, postorder);
}
```
### 回溯算法
#### 常见问题
- 组合问题
- 切割问题：字符串按照某规则，有几种切割方式
- 子集问题
- 排列问题
- 棋盘问题: N皇后
#### 模板
```c++
void backtracing(参数) {
    if (结束条件) {
        存放结果;
        return;
    }
    for (选择: 本层的所有节点) {
        处理结点；
        backtracing(参数)；
        撤销处理效果
    }
}
```
#### 77.组合
```c++
vector<vector<int>> res;
    vector<int> cur;
    void backtracing(int start, int n, int k) {
        if (cur.size() == k) {
            res.push_back(cur);
            return;
        }
        // 这里剪枝了 (剩余选项 >= k - cur.size())
        for (int i=start; i<=n-k+1+cur.size(); i++) {
            cur.push_back(i);
            backtracing(i+1, n, k);
            cur.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracing(1, n, k);
        return res;
    }
```
#### 131. 分割回文串
- 类比组合问题，只不过组合的是字符串的切割位置
- 思路
```
// void backtracing(string s, int startIndex)
// 结束条件 startIndex >= s.length()
// for 循环, 循环的是截取位置
// for (i=startIndex; i<=s.length();i++)
```
- 代码
```c++
vector<vector<string>> res;
vector<string> cur;
bool isReversable(string s, int start, int end) {
    while (start <= end) {
        if (s[start] != s[end]) return false;
        start++;
        end--;
    }
    return true;
}

void backtracing(string s, int startIndex) {
    if (startIndex == s.length()) {
        res.push_back(cur);
        return;
    }

    for (int i=startIndex; i<s.length(); i++) {
        if (isReversable(s, startIndex, i)) {
            cur.push_back(string(s.begin()+ startIndex, s.begin() + i + 1));
            backtracing(s, i+1);
            cur.pop_back();
        }
    } 
}
vector<vector<string>> partition(string s) {
    backtracing(s, 0);
    
    return res;
}
```

#### 46. 全排列
```c++
vector<vector<int>> res;
vector<int> cur;
void backtracing(vector<int>& nums, vector<bool>& visited) {
    if (cur.size() == nums.size()) {
        res.push_back(cur);
    }
    // 和 组合的不同，并不是只能往后遍历
    // 所有元素都需要遍历，通过 visited 数组辨别是否已经访问过了
    for (int i=0; i<nums.size();i++) {
        if (!visited[i]) {
            visited[i] = true;
            cur.push_back(nums[i]);
            backtracing(nums, visited);
            // 执行结束，撤销结果
            visited[i] = false;
            cur.pop_back();
        }
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    vector<bool> visited(nums.size());
    backtracing(nums, visited);
    return res;
}
```
### 贪心算法
#### 局部最优推出全局最优
#### 455. 分发饼干
- 局部最优: s[j] - g[i] 最小（也就是最刚好，浪费的饼干最少)
- s, g 排序
- 如果 g[i] <= s[j], i++. j++, num++
- g[i] > s[j]: s++;
```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i=0, j=0, num=0;
    while (i < g.size() && j < s.size()) {
        if (g[i] <= s[j]) {
            i++;
            j++;
            num++;
        } else {
            j++;
        }
    }
    return num;
}
```
### 动态规划
#### 解题步骤
- 确定 dp 数组 及下标含义
- 递推公式
- dp 数组初始化
- 确定遍历顺序
- 举例推导 dp数组
- dp 数组要打印出来！
#### 斐波那契数列问题为例
- 确定 dp 数组 及下标含义 --> dp[i] --> F(i)
- 递推公式 --> dp[i] = dp[i-1] + dp[i-2]
- dp 数组初始化 --> dp[0] = 0, dp[1] = 1
- 确定遍历顺序 --> 从前到后
- 举例推导 dp数组 --> 0 1 1 2 3 5 8, 打印出来，比较一下！
#### 70. 爬楼梯
- dp[i]: 第i级阶梯到顶层阶梯的方法
- dp[i] = dp[i+1] + dp[i+2]
- dp[n-2] = 2, dp[n-1] = 1
- 从右向左
```c++
int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 两个数组元素就够了！
    int dp[2]; // vector<int> dp(2), 向量同样可以用下标访问
    dp[0] = 1;
    dp[1] = 2;
    for (int i = n-3;i>=0;i--) {
        int sum = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return dp[1];
}
```
#### 746. 使用最小花费爬楼梯
- dp[n]: 登上第 n 级台阶的总花费
- dp[n] = min(dp[n-1] + cost[n-1], dp[n-2] + cost[n-2])
- dp[0] = 0, dp[1] = 0 (起始位置不花钱，登上台阶才花钱)
#### 343. 整数划分
- 动规五部曲
```
// dp[n]: n可拆分得到的最大乘积
// dp[n] = max (j*(n-j), j*dp[n-j]), j 从1开始
// dp[2] = 1
```
- 代码
```c++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[2] = 1;
    for (int i=3; i<=n; i++) {
        dp[i] = -1e5;
        for (int j=1; j<=i-2; j++) {
            // 在遍历过程中需要不断计算最大值
            // 可以通过加入 dp[i] 项，取最大值，避免额外维护一个变量
            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
        }
    }
    return dp[n];
}
```
#### 96. 不同的二叉搜索树
思路
```
dp[n]: 1->n 组成的二叉搜索树数量
dp[4] 为例
以 4 为根， 左子树三个点 dp[3] * 右子树 0个点 dp[0]
以 3 为根 左子树2个点 dp[2] * 右子树 1个点 dp[1]
以 2 为根 左子树1个点 dp[1] * 右子树 2个点 dp[2]
以 1 为根 左子树0个点 dp[0] * 右子树 3个点 dp[3]
dp[n] = sum(dp[j] * dp[n-1-j])
dp[0] = 1
```

#### 62. 不同路径
- 二维动态规划
- 思路
```
dp[i][j]: (0, 0) 出发，到 (i, j) 的路径数
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
**初始化: dp [i][0] = 1 dp[0][j] = 1**
```
- 代码
```c++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    for (int i=0; i<m; i++) {
        dp[i][0] = 1;
    }
    for (int i=0; i<n; i++) {
        dp[0][i] = 1;
    }
    for (int i=1; i<m; i++) {
        for (int j=1; j<n; j++) {
            dp[i][j] = dp[i][j-1] + dp[i-1][j];
        }
    }
    return dp[m-1][n-1];
}
```

### 动态规划--01背包问题
问题定义
```
总重为 W 的背包
N件物品， weight[i], value[i], 每件物品只能用一次
背包里头的物品最大价值？
```
动规五部曲(二维数组版v)
```
dp[i][j]: 在[0-i]物品中进行选择，装入后背包的容量为j, 此时背包的最大价值

dp[i][j] = max(
            dp[i-1][j]  不放入物品 i
            dp[i-1][j-weights[i]] + values[i] 放入物品i, 注意检查 j-weights[i] 的越界情况
            )

初始化：
    dp[i][0] = 0
    dp[0][j] = j >= weights[0] ? value[0] : 0

遍历顺序：每个值 依赖其左上角的值
所以先遍历物品，然后背包容量           
```

#### 416. 分割等和子集
如何理解为01背包问题？

```
目标: 找出一个和为 sum/2 的子集
背包容量为 sum/2
每个物品 weights[i] = values[i] = nums[i]
背包可以正好装满，则找到了子集
```

代码
```c++
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums);
    if (sum % 2 == 1) return false; // 总和是奇数，肯定找不到子集
    int total = sum / 2; // 背包容量
    vector<vector<int>> dp(nums.size(), vector<int>(total+1));

    for (int i=0; i< nums.size(); i++) {
        dp[i][0] = 0;
    }
    for (int i=0; i<= total; i++) {
        dp[0][i] = nums[0] > i ? 0: nums[0]; // 要检查背包容量 够不够装第一个数
    }

    for (int i=1; i<nums.size(); i++) {
        for (int j=1; j<=total;j++) {
            dp[i][j] = dp[i-1][j];
            // 只有背包容量 能够装下 nums[i] 时，才在两项中取最大值
            if (j - nums[i] >= 0) {
                dp[i][j] = max(
                    dp[i][j],
                    dp[i-1][j-nums[i]] + nums[i]
                );
            }
        }
    }

    return dp[nums.size()-1][total] == total; 
}
```

## 图论
### 并查集
两个操作:
- 查询 a,b 是否在同一组
- 将元素 a,b 合并为一组

数据结构: 每一组表示为树结构
- 是否在同一组 --> 检查根结点是否一致
- 合并为一组: 修改根结点到一致

代码
```c++
vector<int> parent;

void init(int n) {
  for (int i=0; i<n; i++) {
    parent.push_back(i); // 初始每个节点的父元素指向自己
  }
}

int find(int x) {
  if (x == parent[x]) return x;
  return find(parent[x]); // 沿着树往上找
}

void union(int x, int y) {
  x = find(x);
  y = find(y); // 分别找到根结点
  if (x == y) return;
  parent[y] = x;
}

bool same(int x, int y) {
  return find(x) == find(y);
}
```
#### 200. 岛屿数量

DFS 做法 --将该题理解为找 联通组件的数量

代码
```c++
 int count = 0;
int m, n;
void dfs(vector<vector<char>>& grid, int count, int row, int col) {
    if (row >= m || col >= n || row < 0 || col < 0 || grid[row][col] != '1') return;
    grid[row][col] = '2'; // 设置一个已访问过的标志
    // 上下左右 四个方向进行 DFS 搜索
    dfs(grid, count, row+1, col);
    dfs(grid, count, row, col+1);
    dfs(grid, count, row-1, col);
    dfs(grid, count, row, col-1);
}
int numIslands(vector<vector<char>>& grid) {
    m = grid.size();
    n = grid[0].size();
    
    for (int i=0; i<m; i++) {
        for (int j=0; j<n; j++) {
            // 未访问过的 "1"
            if (grid[i][j] == '1') {
                dfs(grid, count, i, j);
                count++;
            } 
        }
    }
    return count;
}
```

并查集做法
整体思想：遇到相邻的 "1" 结点，就合并集合
最后集合的数量（连通组件的数量）就是岛屿数量
集合数最初为节点总数，每次合并集合，则 count--

```c++
class UnionFind {
private:
    int count = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(vector<vector<char>> grid) {
        int m = grid.size();
        int n = grid[0].size();

        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (grid[i][j] == '0') parent.push_back(-1);
                else {
                  parent.push_back(i* n + j); // 用一个一维数组来存储，实质上是一样的
                  count++;
                }
                rank.push_back(0);
            }
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return; // 已经联合的节点，不需要 count--

        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        
        count--; // 联合之后，连通分量减少
    }

    int getCount() {
        return count;
    }
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        UnionFind UF = UnionFind(grid);
       
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                // 未访问过的 "1"
                if (grid[i][j] == '1') {
                    if (j+1 < n && grid[i][j+1] == '1') UF.unite(i*n+j, i*n+j+1);
                    if (j-1 >= 0 && grid[i][j-1] == '1') UF.unite(i*n+j, i*n+j-1);
                    if (i+1 < m && grid[i+1][j] == '1') UF.unite(i*n+j, (i+1)*n+j);
                    if (i-1 >= 0 && grid[i-1][j] == '1') UF.unite(i*n+j, (i-1)*n+j);
                    grid[i][j] == '0'; // 避免重复访问
                } 
            }
        }
        return UF.getCount();
    }
};
```

##### new UnionFind 和 UnionFind 的区别
- new: Allocates memory for an object or array of objects
    - char* pCharArray = new char[CName::sizeOfBuffer];
- UnionFind: 调用构造函数，返回相应的对象
    - UnionFind UF(grid); // 括号里是构造函数的参数v


### 最小生成树
- 无向图中的一个子图
- tree (连通、无环) spanning (include all vertices)
- 找到这样的树中，权值最小的那个
- 应用: 修一条经过所有村庄的路，保证修路的花费最少

#### Kruscal 算法
https://blog.csdn.net/luomingjun12315/article/details/47700237
思路
```
1. 先将所有边排序（权值小的优先）
2. 按权值分别选择边，并查集中合并两个顶点所在集合；如果顶点已经在同一集合，则不选择该边
3. 直到所有节点都被访问过了 (MST.size() == V())
```

##### 1135
```c++
class UnionFind {
private:
    int count = 0;
    int fee = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(int n) {
        count = n;
        for (int i=0; i<=n; i++) {
            parent.push_back(i);
            rank.push_back(0);
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    int getCount() {
        return count;
    }

    int getFee() {
        return fee;
    }

    void unite(int x, int y, int cost) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        count--;
        // 费用也放在并查集里计算
        // 如果两个点已经在同一个集合中，则不应该加上该费用（不选择该边）
        fee += cost; 
    }
    
};
bool compare(vector<int> a, vector<int> b) {
        return a[2] < b[2];
}
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        UnionFind UF(n);

        sort(connections.begin(), connections.end(), compare);

        for (int i=0; i<connections.size(); i++) {
            UF.unite(connections[i][0], connections[i][1], connections[i][2]);
            if (UF.getCount() == 1) return UF.getFee();
        }

        return -1; // 没有找到最小生成树

    }
};
```

#### Prim 算法

选择一个点，放入点集 V 中
选择 V -> 非V 的一个权值最小的边，将新的点加入点集 V
直到 V.size() == 点总数

数据结构:
- visited
- minDist[i]: 从集合 V 到结点i的最小距离

先给出图的定义
```c++
struct Vex {
    int v, weight; // 所连接的节点 和权重
}

vector<Vex> graph[V]; // 每个节点，通过一个 vector 存储邻接结点
```

一次 Prim
```c++
// 将 s 加入 V 中
int prim(int s, int n) {
    int newNode, tmpMin, total=0;
    visited[s] = true;

    // 初始化各点到集合 V 的距离
    for (int j=0; j<graph[s].size(); j++) {
        minDist[graph[s][j].v] = graph[s][j].w;
    }

    // 进行 n-1次相关操作
    for (int i=0; i<n-1; i++) {
        // 找到距离最小的那个点
        tmpMin = INF;
        for (int j=0; j<n; j++) {
            if (minDist[j] < tmpMin) {
                tmpMin = minDist[j];
                newNode = j;
            }
        }
        // visited, minDist 更新
        visited[newNode] = true;
        total += tmpMin;

        for (int j=0; j<graph[newNode].size(); j++) {
            if (!visited[graph[newNode][j].v]) {
                minDist[graph[newNode][j].v] = min(graph[s][j].w, minDist[graph[newNode][j].v]);
            }
            
        }
    }
    return total;
}
```

```c++
bool visited[V];
int minDist[v];
// 先把0号结点加入集合
visited[0] = true;
minDist[0] = -1;
for (int i=1; i<V; i++) {
    visited[i] = false;
    if (graph[0][i])
}
```