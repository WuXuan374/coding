[toc]
### 数组
#### 一维数组的存储空间是连续的，那么二维数组？
- 取决于语言实现。C++是连续分布；Java由虚拟机完成寻址操作，不是连续分布。
#### 704 二分查找
- 直接用循环二分查找即可，不一定要递归
```c++
int search(vector<int>& nums, int target) {
    int low = 0;
    int len = nums.size();
    int high = len - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (mid >= len) return -1;
        if (nums[mid] == target) return mid;
        if (nums[mid] > target) {
            high = mid -1;
        } else {
            low = mid + 1;
        }
    }
    return -1;
}
```
### 链表
#### 基础知识
- 链表节点不是连续分布，而是散乱分布
- c++ 链表定义方式
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}; // 构造函数

}
```
- 添加虚拟头结点，可以同化对所有节点的操作，降低复杂度
#### 203.移除链表元素
- 体现虚拟头结点的作用
```c++
ListNode* removeElements(ListNode* head, int val) {
    ListNode* vHead = new ListNode(0, head);
    ListNode* prev = vHead;
    ListNode* cur = vHead -> next;
    while (cur != NULL) {
        if (cur -> val == val) {
            prev -> next = cur -> next;
            cur = cur -> next;
        } else {
            prev = cur;
            cur = cur -> next;
        }
    }
    return vHead -> next;
}
```
- 仍然存在问题，别忘了释放空间！（虚拟头节点 + 被删除的节点）
```c++
ListNode* tmp;
delete(tmp);
```
### 哈希表
#### 例子
- 学生名字 通过 hashFunction, 得到索引
- 通过索引直接访问对应数据
- 作用：快速判断一个元素是否出现在集合中
#### 数据结构选用
##### Set
- 优先选用std:unordered_set, 查询和增删效率最优
- 需要集合有序：std:set
- 有序加重复数据: std:multi_set
#### 1002. 查找常用字符
- 数组中的每个字符串，对应一个26位数组，存储每个字母出现的频率
- 两个 26 维数组取最小值，符合“所有字符串都显示”这一定义
- 小技巧
    - 数组初始化 int hash[26] = {0};
    - char to string: string s(1, i + 'a');
```c++
vector<string> commonChars(vector<string>& words) {
    vector<string> result;
    int len = words.size();
    if (!len) {
        return result;
    }
    int hash[26] = {0};
    string word = words[0];
    for (int i=0; i< word.length(); i++) {
        hash[word[i] - 'a'] += 1;
    }
    for (int i=1; i< words.size(); i++) {
        int hashOther[26] = {0};
        string word = words[i];
        for (int i=0; i< word.length(); i++) {
            hashOther[word[i] - 'a'] += 1;
        }
        for (int i=0; i<26; i++) {
            hash[i] = min(hash[i], hashOther[i]);
        }
    }
    for (int i=0; i<26; i++) {
        while (hash[i] > 0) {
            string s(1, i + 'a');
            result.push_back(s);
            hash[i]--;
        }
    }
    return result;
}
```
### 动态规划
#### 解题步骤
- 确定 dp 数组 及下标含义
- 递推公式
- dp 数组初始化
- 确定遍历顺序
- 举例推导 dp数组
- dp 数组要打印出来！
#### 斐波那契数列问题为例
- 确定 dp 数组 及下标含义 --> dp[i] --> F(i)
- 递推公式 --> dp[i] = dp[i-1] + dp[i-2]
- dp 数组初始化 --> dp[0] = 0, dp[1] = 1
- 确定遍历顺序 --> 从前到后
- 举例推导 dp数组 --> 0 1 1 2 3 5 8, 打印出来，比较一下！
#### 70. 爬楼梯
- dp[i]: 第i级阶梯到顶层阶梯的方法
- dp[i] = dp[i+1] + dp[i+2]
- dp[n-2] = 2, dp[n-1] = 1
- 从右向左
```c++
int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 两个数组元素就够了！
    int dp[2];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = n-3;i>=0;i--) {
        int sum = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return dp[1];
}
```
