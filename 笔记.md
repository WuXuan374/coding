[toc]
## LabuLadong
### c++ 代码注意事项
#### 链表
```c++
ListNode* dummy1 = new ListNode(); // new 一个 struct
dummy1->val, dummy1->next; //访问成员变量
// 判断空指针: NULL
```
#### vector
```c++
vector<ListNode*> lists;
lists.size() // vector 长度
```
#### 优先级队列
```c++
priority_queue<ListNode* , vector<ListNode*>, decltype( comp )> pq(comp); // comp 是自定义的 comparator

auto comp = []( ListNode* a, ListNode* b ) { return a->val > b->val; }; // 对应一个小顶堆

priority_queue<int , vector<int>, greater<int>> pq; // 小顶堆

```
- 赋值构造函数：```vector<int> parent = vector<int> (1001);```, 适合类成员变量的初始化
- 根据初始值构造 vector
    - vector<int> ({0, 0, pathLen})
    - ```vector<vector<int>> directions({{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1,-1}, {1, 0}, {1, 1}});```
- 二维，带大小的 vector 声明
- 要求返回一个 vector<int> 时，可以直接返回里头的元素
    - ```return {1,2,3}```
```c++
vector<vector<int>> dp(m+1, vector<int>(n+1));
```
- vector 之间的拼接
```c++
res.insert(res.end(), left_res.begin(), left_res.end());
```

### Java 代码注意事项
- 可以使用三目运算符
- 需要注意的是，java 函数中的 variable 是 pass-by-value
    - 对于一个 Object 参数来说，比如 List<Integer> cur
    - 传入的是 cur 这个对象的引用的地址，也就是说如果在函数外去修改 cur(比如 cur.add(1)), 这个修改同样会作用在这个函数参数 cur 上
    - 可以看一下 46.全排列的例子
#### 基本类型
- Integer 是否相等，记得使用 equals() 方法
    - '==' 方法比较的是对象是否相同，超过 127 的 Integer 就指向不同的对象（<= 127 的，从常量池里头拿？）

#### 数组
```java
int[] dp = new int[amount+1];
Arrays.fill(dp, 0); // 数组赋值
boolean[][] track = new boolean[n][n]; // 二维数组
int[] arr = new int[]{3, 5}; // 直接带值初始化
Arrays.sort(nums1); // 升序排序
// 降序排序，只能对 array of objects
Integer[] arr = { 5, 2, 1, 8, 10 };
Arrays.sort(arr, Collections.reverseOrder());
```
#### List
```java
LinkedList<Integer> cur = new LinkedList<>();
cur.add(nums[i]);
cur.removeLast();
cur.get(i); // 访问下标为 i 的元素

private List<Integer[]>[] graph;
graph = new LinkedList[n]; // 初始化
```
#### 循环
```java
int[] coins;
for (int coin:coins) {
    ...
}
```
#### 实用工具
```java
Math.min(a, b);
int res = Integer.MAX_VALUE;
null, true, false
```
#### 字符串
```java
// 可以从 char[] 生成 String
char[] row = new char[n];
// 对于数组，可以用Arrays.fill() 赋初值
Arrays.fill(row, '.');
String s = new String(row);
// 如果想修改字符串的内容，也可以用 char[] 作为中间的桥梁
String s = "0000";
s.charAt(0); // '0'
char[] ch = s.toCharArray();
ch[0] = '5';
return new String(ch); // "5000"
new String(s_array, subStringLeft, subStringRight-subStringLeft+1); // char[], startIndex, offset
```
#### 队列
```java
Queue<TreeNode> q = new LinkedList<>();
q.offer(root); // 加入队列
q.isEmpty();
q.size();
q.poll(); // 返回第一个元素，并从队列中删除
```
##### 优先级队列
```java
// 参数是一个 comparator
pq = new PriorityQueue<>((a, b) -> {
    // 按照边的权重从小到大排序
    return a[2] - b[2];
});
```
#### 集合
```java
Set<String> set = new HashSet<>();
set.add("abc");
set.contains("xyz");
set.remove("hello"); // 返回 true/false, 是否删除成功
set.size();
```
#### HashMap
```java
HashMap<Character, Integer> t_characters = new HashMap<Character, Integer>(); // 为什么不是 char, int? Generic parameters can only bind to reference types, not primitive types
map.put(key, map.getOrDefault(key, 0)+1); // map[key]++, 但是 java 中不支持啊 map[key] 的写法
map.getOrDefault(key, 0);//如果 key 不存在，则返回0
map.size(); // 一共有多少个 (key, value) pair
map.containsKey(d); 
for(char key: t_characters.keySet()) {...}
```
#### Integer
- java 中 Integer 也是对象，需要使用 equals()方法来判断值的相等（== 判断的是引用的相等）

#### class
- 一个 java 文件中可以声明多个 class
- 每定义一个 class, 编译的时候就生成一个对应的 .class 文件
- 但是只能有一个 public class, 并且该 class 需要和文件同名

#### 随机数
```java
Random rand = new Random();
rand.nextInt(n); // [0, n)
```

### 数据结构相关
#### LRU
- Least Recently Used: 缓存淘汰策略，删除最近最久未使用的
- 必要条件
    - 要区分数据项最近的使用时间（按照在链表中的位置区分即可）
    - 需要快速查询每个 key 对应的 val
    - 访问一个 key 的时候，要将其变为最近使用的，因此要支持快速插入和删除元素
- 对应的数据结构 LinkedHashMap
    - HashMap 支持快速查询每个 key 对应的 val
    - LinkedList 支持快速插入和删除元素
<img src="图片/LinkedHashMap.png">

```java
/**
- 一个 java 文件中可以声明多个 class
- 每定义一个 class, 编译的时候就生成一个对应的 .class 文件
- 但是只能有一个 public class, 并且该 class 需要和文件同名
 */
class LRUCache {
    // key --> Node(key, val)
    private HashMap<Integer, Node> map;
    private DoubleList cache;
    // 最大容量
    private int cap;

    public LRUCache(int capacity) {
        cap = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }
    // 避免让 get 和 put 方法直接操作 map 和 cache 的底层细节，我们需要提供一层抽象 API

    /** 将某个 key 提升为最近使用的*/
    private void makeRecently(int key) {
        // 其实就是把这个元素移到 cache 尾部
        Node x = map.get(key);
        cache.remove(x);
        cache.addLast(x);
    }

    /** 添加最近使用的元素 */
    private void addRecently(int key, int val) {
        Node x = new Node(key, val);
        map.put(key, x);
        cache.addLast(x);
    }

    /** 删除一个 key */
    private void deleteKey(int key) {
        Node x = map.get(key);
        cache.remove(x);
        map.remove(key);
    }

    /** 删除最久未使用的 key */
    private void removeLeastRecently() {
        Node first = cache.removeFirst();
        // 注意这里，链表是需要存储 key + value 的
        int firstKey = first.key; 
        map.remove(firstKey);
    }
    
    /** 访问一个 key 的时候，要将其变为最近使用的 */
    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        makeRecently(key);
        return map.get(key).val;
    }
    
    public void put(int key, int value) {
        if (map.containsKey(key)) {
            deleteKey(key);
            addRecently(key, value);
        } else {
            if (cache.size() == cap) {
                removeLeastRecently();
            }
            addRecently(key, value);
        }
    }

}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */

class Node {
    public int key, val;
    public Node next, prev;
    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}

class DoubleList {
    private Node head, tail; // 头尾结点
    private int size; // 节点数量

    public DoubleList() {
        head = new Node(0, 0); //  为什么创建（0,0） 节点呢？
        tail = new Node(0, 0);
        // 仔细看图，这里的 head 和 tail 都不是真实的节点，而是两个 dummy node
        // 这种做法很有用，避免在链表为空的时候，需要做一些特殊处理
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // O(1)
    public void addLast(Node x) {
        Node prevNode = tail.prev;
        prevNode.next = x;
        x.prev = prevNode;
        x.next = tail;
        tail.prev = x;
        size++;
    }

    // O(1)
    public void remove(Node x) {
        Node prevNode = x.prev;
        Node nextNode = x.next;
        prevNode.next = nextNode;
        nextNode.prev = prevNode;
        x.prev = null;
        x.next = null;
        size--;
    }

    // 首个元素，其实就是最近最久未使用的元素
    // 两个 dummy 节点的设置，帮助避免了很多对于 null 节点的判断
    public Node removeFirst() {
        if (head.next == tail) return null;
        Node first = head.next;
        remove(first);
        return first;
    }

    public int size() {
        return size;
    }
}
```

- 也可以直接用 java 的 LinkedHashMap 来实现
```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) { 
        this.cap = capacity;
    }
    
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // 将 key 变为最近使用
        makeRecently(key);
        return cache.get(key);
    }
    
    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // 修改 key 的值
            cache.put(key, val);
            // 将 key 变为最近使用
            makeRecently(key);
            return;
        }
        
        if (cache.size() >= this.cap) {
            // 链表头部就是最久未使用的 key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // 将新的 key 添加链表尾部
        cache.put(key, val);
    }
    
    private void makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插入到队尾
        cache.remove(key);
        cache.put(key, val);
    }
}
```


### 链表
- dummy 头结点很有用
#### 86.分隔链表
```c++
    ListNode* partition(ListNode* head, int x) {
        ListNode* dummy1 = new ListNode();
        ListNode* head1 = dummy1;
        ListNode* dummy2 = new ListNode();
        ListNode* head2 = dummy2;
        // 遍历原链表
        ListNode* node = head;
        while(node != NULL) {
            if(node-> val < x) {
                head1-> next = node; // 这个地方赋的是原节点的引用
                head1 = head1-> next;
            } else {
                head2-> next = node;
                head2 = head2-> next;
            }
            ListNode* temp = node->next; 
            node->next = NULL; // 因此要把原节点的 next 设置成 NULL
            node = temp;
        }
        // 组合两个链表
        head1->next = dummy2->next;
        return dummy1->next;
    }
```
#### 23. 合并k个有序链表
- 需要一个（小顶堆）优先级队列，每次出队目前的最小元素
- 所有链表的首个元素入队，每次最小元素出队，然后补充对应链表的下一个元素
- 时间复杂度分析
    - 优先级队列中有 k 个元素，因此每次入队，出队是$O(\log K)$(二叉堆作为实现方式)
    - 每个元素都需要入队出队，因此时间复杂度一共$O(N\log K)$
```c++
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode* , vector<ListNode*>, decltype( comp )> pq(comp);
        ListNode* dummy = new ListNode();
        ListNode* node = dummy;
        for (int i=0; i<lists.size(); i++) {
            if (lists[i] != NULL) {
                pq.push(lists[i]); // 各链表头结点
            }
            
        }
        while (!pq.empty()) {
            ListNode* curNode = pq.top();
            node -> next = curNode;
            node = node -> next;
            pq.pop();
            if (curNode -> next != NULL) {
                pq.push(curNode -> next);
            }
        }
        return dummy -> next;
    }
```
#### 19. 删除链表的倒数第n个节点
- 倒数第 n 个节点: 如果希望只遍历一次的话，可以有一对快慢指针；
- 快指针多走 n 步，快指针到达NULL时，慢指针对应要删除的节点
- 保存慢指针的前一个节点
- dummy 头结点很有用！可以处理头结点需要删除的情况
```c++
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode();
        dummy -> next = head;
        ListNode* fast = head;
        ListNode* slow = head;
        ListNode* slow_prev = dummy;
        int i=0;
        while (i<n & fast != NULL) {
            fast = fast -> next;
            i++;
        }
        if (i<n) {
            return NULL;
        }
        while (fast != NULL) {
            fast = fast -> next;
            slow_prev = slow;
            slow = slow -> next;
        }
        slow_prev -> next = slow -> next;
        return dummy -> next;
    }
```
#### 676.链表的中间节点
- 仍然容易想到快慢指针，快的走两步，走到尽头时慢指针指向中间节点
```java
public ListNode middleNode(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast.next != null) {
        slow = slow.next;
        fast = fast.next;
        if (fast.next != null) fast = fast.next;
    }
    return slow;
}
```
#### 160. 相交链表
- 和判断链表是否存在环，其实有一点相似之处
- A/B 两个链表的头结点各自存在一个指针
- 对于指针A, 走到尽头之后则到达 B 的头结点
- 指针 B 类似
- 这样的话，如果存在相交节点，指针A/B会在相交节点相遇，因为他们恰好都把链表A 和链表B不相交部分都走完了（走的步数相同）
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode nodeA = headA;
    ListNode nodeB = headB;
    boolean finishA = false;
    boolean finishB = false;
    if (headA == null || headB == null) return null; // 考虑存在空链表的特殊情况
    while (true) {
        if (nodeA == null) {
            if (finishA == true) {
                return null;
            } else {
                finishA = true;
                nodeA = headB;
            }
        }
        if (nodeB == null) {
            if (finishB == true) {
                return null;
            } else {
                finishB = true;
                nodeB = headA;
            }
        }
        if (nodeA == nodeB) {
            return nodeA;
        }
        nodeA = nodeA.next;
        nodeB = nodeB.next;
    }
}
```
#### 206. 反转链表
- 这个是我自己的想法，每次递归，返回的是 next 节点
```java
private ListNode newHead;
public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) return head;
    recur(head);
    return newHead;
}
private ListNode recur(ListNode current) {
    if (current.next == null) {
        newHead = current;
        return current;
    } else {
        ListNode prevNode = recur(current.next);
        prevNode.next = current;
        current.next = null; // 别忘了将节点原来的 next 置为 null, 避免出现环（特别是原来的头结点，反转之后的尾结点）
        return current;
    }
}
```
- 但其实呢，next 节点并不需要递归来返回；递归可以返回反转之后逇头结点
```java
public ListNode reverseList(ListNode head) {
    // 递归终点
    if (head == null || head.next == null) {
        return head;
    }
    ListNode last = reverseList(head.next); // last 返回的是反转之后，头结点的位置
    head.next.next = head; // 反转链表
    head.next = null; // 这个要记得置为 null, 否则可能出现环
    return last;
}
```
#### 92. 反转链表 II
- 感觉自己写的代码就不太对，一些特殊情况处理不了（比如要反转的内容出现在头尾）
- 还是看一下教程，相应的去写吧
- 说实话，看完之后感觉自己写是写不出来的
- 思路
    - 首先考虑反转前面的几个元素 (reverseN)
    - 对于考虑一个区间的情况，那就遍历区间前的节点，把 left -1, right-1; 到达区间的起始位置，就调用 reverseN
```java
    private ListNode successor;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == 1) {
            return reverseN(head, right-left+1);
        }
        head.next = reverseBetween(head.next, left-1, right-1);
        return head;

    }
    private ListNode reverseN(ListNode head, int n) {
        if (n == 1) {
            successor = head.next; // 要记录前 n 个之外的下一个链表元素
            return head;
        }
        ListNode last = reverseN(head.next, n-1);
        head.next.next = head;
        head.next = successor; // 这一点很巧妙: 只有原来的头结点，其 next 会被设置成 succesor; 其他节点由于上一行的存在， next 又被设置成前一个节点
        return last;
    }
```
#### 25. K个一组翻转链表
- 这个还是我的写法
- 之前有了 reverseN, 这里还是会用到这个函数
- 比较麻烦的是，我们需要记录
    - 前驱节点：上一次翻转后的尾巴节点
    - 本次翻转后的头结点 -- 递归返回值
    - 下一次翻转开始的位置
- 另外这个函数要求除不尽的余数部分不要翻转，我通过检测链表还剩多少个元素来完成这个任务（肯定不是最好做法）
```java
    ListNode successor = null;
    ListNode newHead = null;
    ListNode predecessor = null;
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode newHead = reverseN(head, k);
        predecessor = head;
        if (successor == null) {
            return newHead;
        }
        ListNode node = successor;
        while (node != null && checkLeft(node, k)) {
            ListNode last = reverseN(node, k);
            predecessor.next = last;
            
            predecessor = node;
            node = successor;
        }
        predecessor.next = successor;
        return newHead;
    }
    private ListNode reverseN(ListNode head, int n) {
        if (head.next == null || n==1) {
            successor = head.next;
            return head;
        }
    
        ListNode last = reverseN(head.next, n-1);
        head.next.next = head;
        head.next = successor;
        return last;
    }
    private boolean checkLeft(ListNode node, int k) {
        for (int i=k; i>=1; i--) {
            if (node == null) return false;
            node = node.next;
        }
        return t
```
#### 234. 回文链表
- 判断回文串的思路很简单：双指针，分别从头尾出发，不相等 --> 不是回文串，直到相遇
- 但这是一个链表，如何倒着去遍历链表呢
- 当然可以反转链表，然后同时遍历两个链表，判断是否相等
- 这里采用递归的思路: 后序遍历就能得到反过来遍历链表的结果（其实和翻转链表一样）；在这个过程中递归的判断每个位置是否相等
```java
ListNode left;
public boolean isPalindrome(ListNode head) {
    left = head;
    return recur(head);
}
private boolean recur(ListNode right) {
    if (right == null) return true;
    boolean res = recur(right.next); // 这里也可以理解成把链表放到栈里头，取出来的时候自然就倒序了
    res = res && (right.val == left.val); // 后序遍历位置
    left = left.next;
    return res;
}
```
### 数组
- 左右指针
- 快慢指针
    - 原地修改数组
#### 26. 删除有序数组中的重复项
- 由于需要原地修改数组，所以快慢指针
- 快指针遇到更大的数，就和慢指针的下一位交换，慢指针走一位
```c++
    void swap(int &a, int &b) {
        int temp = a;
        a = b;
        b = temp;
    }
    int removeDuplicates(vector<int>& nums) {
        int slow = 0;
        int fast = 1;
        while (fast < nums.size()) {
            if (nums[fast] > nums[slow]) {
                swap(nums[fast], nums[slow+1]);
                slow++;
            }
            fast++;
        }
        return slow+1;
    }
```
#### 83.删除排序链表中的重复元素
- 一样的快慢指针
- 链表更简单，不需要原地修改，直接断开链表/修改 next 即可
```c++
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) {
            return NULL;
        }
        ListNode* slow = head;
        ListNode* fast = head-> next;
        while (fast != NULL) {
            if (fast->val > slow->val) {
                slow -> next = fast;
                slow = fast;
            }
            fast = fast -> next;
        }
        slow -> next = NULL;
        return head;
    }
```
#### 27. 移除元素
- 我用的是左右指针
- 比较麻烦的是后处理
    - 数组越界的情况
    - 究竟停在哪个位置：根据慢指针当前位置的值来确定
```c++
    void swap(int& a, int& b) {
        int temp = a;
        a = b;
        b = temp;
    }
    int removeElement(vector<int>& nums, int val) {
        int slow = 0;
        int fast = nums.size() - 1;
        while (slow < fast) {
            while (fast >= 0 && nums[fast] == val) {
                fast--;
            }
            while (slow < nums.size() && nums[slow] != val) {
                slow++;
            }
            if (slow < fast) {
                swap(nums[slow], nums[fast]);
                slow++;
                fast--;
            }
        }
        if (slow >= nums.size()) return nums.size();
        while (slow >= 0 && nums[slow] == val) {
            slow--;
        }
        return slow+1;
    }
```
#### 283.移动0
- 快慢指针
- 慢指针每次遇到0，就和快指针交换
- 快指针始终停在非 0 的位置
- 直到快指针完成了数组遍历；快指针每次从慢指针+1处出发，确保非零元素的相对顺序
```java
public void moveZeroes(int[] nums) {
    int slow = 0;
    while (slow < nums.length) {
        if(nums[slow] == 0) {
            int fast = slow + 1;
            while (fast < nums.length && nums[fast] == 0) fast++;
            if (fast < nums.length) {
                int tmp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = tmp;
            } else {
                // 后面只剩下 0， 处理完毕了
                return;
            }
        }
        slow++;
    }
}
```
#### 5.最长回文子串
- 仍然是双指针法，不过是从中间向两边展开
- 然后子串长度是奇数还是偶数需要考虑(会影响指针的位置)
```java
String result = "";
public String longestPalindrome(String s) {
    if (s.length() < 1) return result;
    if (s.length() < 2) return s; // 处理特殊情况
    String subResult;
    for (int i=0; i<s.length()-1; i++) {
        subResult = palindrome(s, i, i); // 子串长度为奇数
        if (subResult.length() > result.length()) result = subResult;
        if (s.charAt(i) == s.charAt(i+1)) {
            subResult = palindrome(s, i, i+1); // 子串长度为偶数
        if (subResult.length() > result.length()) result = subResult;
        }
    }
    return result;
}
private String palindrome(String s, int i, int j) {
    while (i>=0 && j<s.length() && s.charAt(i) == s.charAt(j)) {
        i--;
        j++;
    }
    return s.substring(i+1, j);
}
```
#### 前缀和数组
- 其实就是一个打表的方法，能够避免重复计算
- 例如计算区间和的情况下，一个前缀和数组的例子
<img src="图片/前缀和.png">

##### 304.二维情况下的前缀和
- 还是维护一个二维前缀和数组（这个元素和原点所构成区域的面积）
- 查询的时候，通过四个区域的加减得到答案
```java
class NumMatrix {
    private int[][] count;
    public NumMatrix(int[][] matrix) {
        count = new int[matrix.length][matrix[0].length];
        for (int i=0; i<matrix.length; i++) {
            for (int j=0; j<matrix[0].length; j++) {
                if (i==0 && j== 0) {
                    count[i][j] = matrix[0][0];
                } else if (i==0) {
                    count[i][j] = count[i][j-1] + matrix[i][j];
                } else if (j==0) {
                    count[i][j] = count[i-1][j] + matrix[i][j];
                } else {
                    count[i][j] = count[i-1][j] + count[i][j-1] - count[i-1][j-1] + matrix[i][j];
                }
            }
        }
    }

    private int getCountValue(int row, int col) {
        if (row < 0 || col < 0) return 0;
        return count[row][col];
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return getCountValue(row2, col2)- getCountValue(row1-1, col2) - getCountValue(row2, col1-1) + getCountValue(row1-1, col1-1);
    }
}

```
#### 差分数组
- 主要目的：快速进行区间增减操作
- 主要还是为了降低时间复杂度吧
- 差分数组：存储相邻元素只差
##### 1109. 航班预订统计
- 对于差分数组，定义了三个函数
    - 构造函数，初始化差分数组
    - increment: 起始位置 + num, 结束位置 - num
    - 根据差分数组，构造原数组
```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
        Difference difference = new Difference(n);
        for (int[] book: bookings) {
            difference.increment(book[0]-1, book[1]-1, book[2]);
        }
        return difference.getResult();
    }
}
class Difference {
    int[] diff;
    public Difference(int n) {
        this.diff = new int[n];
        for (int i=0; i<n; i++) {
            diff[i] = 0;
        }
    }
    public void increment(int start, int end, int num) {
        diff[start] += num;
        if (end+1 < diff.length) {
            diff[end+1] -= num;
        }
    }
    public int[] getResult() {
        int[] result = new int[diff.length];
        result[0] = diff[0];
        for (int i=1; i<diff.length; i++) {
            result[i] = result[i-1] + diff[i];
        }
        return result;
    }
}
```
#### 二维数组遍历相关
##### 48. 旋转图像
- 教程中的做法，我觉得面试的时候想不到；还是老老实实用常规做法吧
- 必须原地修改数组，我们发现存在如下规律
    -  matrix[row][col] = matrix[n-1-col][row];
- 但是因为要原地修改，只考虑上面这个等式，会有值被覆盖
- 考虑这是一个正方形，上面这个等式是旋转了 90度；旋转 360度之后应该就回来了
    - int tmp = matrix[row][col];
    - matrix[row][col] = matrix[n-1-col][row];
    - matrix[n-1-col][row] = matrix[n-1-row][n-1-col];
    - matrix[n-1-row][n-1-col] = matrix[col][n-1-row];
    - matrix[col][n-1-row] = tmp;
```java
class Solution {
    public void rotate(int[][] matrix) {
        if (matrix.length < 1) return;
        int n = matrix.length;
        for (int row=0; row<n/2; row++) { // 只需要翻转前 n/2 行
            for (int col=0; col<(n+1)/2; col++) { // 每一列只需要翻转左边的一半
                int tmp = matrix[row][col];
                matrix[row][col] = matrix[n-1-col][row];
                matrix[n-1-col][row] = matrix[n-1-row][n-1-col];
                matrix[n-1-row][n-1-col] = matrix[col][n-1-row];
                matrix[col][n-1-row] = tmp;
            }
        }
        return;
    }
}
```
##### 54. 螺旋矩阵
- 按照右、下、左、上的顺序遍历矩阵
- 同时设置四个边界变量，限定遍历的范围（每次只能遍历里面的一层）
- 代码里头有细节！
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int upper_bound = 0;
        int lower_bound = m-1;
        int left_bound = 0;
        int right_bound = n-1;

        List<Integer> results = new LinkedList<Integer>();
        int row_index = 0, col_index = 0;

        // 这个地方用边界变量不好判断，res.size() 是一个更好的判定方法
        while (results.size() < m*n) {
            // 向右走
            if (upper_bound <= lower_bound) { // 这个条件判断很重要，能够避免重复遍历
                for (int i=left_bound; i<=right_bound; i++) {
                    results.add(matrix[upper_bound][i]);
                }
                upper_bound++; // 1
            }
           
            if (left_bound <= right_bound) {
                // 向下走
                for (int i=upper_bound; i<=lower_bound; i++) {
                    results.add(matrix[i][right_bound]);
                }
                right_bound--; //1 
            }
            
            if (upper_bound <= lower_bound) {
                // 向左走
                for (int i=right_bound; i>=left_bound; i--) {
                    results.add(matrix[lower_bound][i]);
                }
                lower_bound--; // 1
            }
           
            if (left_bound <= right_bound) {
                // 向上走
                for (int i=lower_bound; i>=upper_bound; i--) {
                    results.add(matrix[i][left_bound]);
                }
                left_bound++; // 1
            }
        }

        return results;
    }
}
```
#### 528. 带权重的随机选择算法
- 根据权重数组构造一个前缀和数组
- 每次生成一个随机数，然后就是在前缀和数组中，根据这个随机数进行查找
- 推导过程见:https://labuladong.github.io/algo/2/20/30/
```java
class Solution {
    private int[] preSum;
    private Random rand = new Random();

    public Solution(int[] w) {
        // 构造前缀和数组
        preSum = new int[w.length+1];
        preSum[0] = 0; // 下标 0 处其实就是一个占位符
        int curSum = 0;
        for (int i=1; i<preSum.length; i++) {
            curSum += w[i-1];
            preSum[i] = curSum;
        }
    }
    
    public int pickIndex() {
        // 需要实现在前缀和数组中，二分查找的工作
        int n = preSum.length;
        int target = rand.nextInt(preSum[n-1])+1; // 取值范围是 [1, presum[n-1]]
        // 前缀和数组中的下标 0 是一个占位符，因此有一位偏差
        return binarySearch(target) - 1; 
    }

    private int binarySearch(int target) {
        int left = 1;
        int right = preSum.length-1;

        while (left <= right) {
            int mid = left + (right-left)/2;
            if (preSum[mid] == target) {
                return mid;
            } else if (preSum[mid] < target) {
                left = mid + 1;
            } else if (preSum[mid] > target) {
                right = mid - 1;
            }
        }
        return left;
    }
}
```
#### 870. 优势洗牌（田忌赛马问题）
- 先把两个数组排序好
- 按顺序一一比较，如果能比得过，就直接比；否则就拿一个垫底的去比
- 实现细节
    - 无法原地排序，可以用一个优先级队列，记录在原数组中的下标
```java
class Solution {
    public int[] advantageCount(int[] nums1, int[] nums2) {
        Arrays.sort(nums1); // 这个实现的是升序排序
        // 因为要保留 nums2 原来的顺序，所以不能原地对数组排序
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            return b[1] - a[1];
        });
        for (int i=0; i<nums2.length; i++) {
            pq.offer(new int[]{i, nums2[i]});
        }
        // 使用双指针，来完成直接比/送人头这两种操作
        int n = nums1.length;
        int[] temp = new int[n];
        int left = 0, right=n-1;
        for (int i=0; i<n; i++) {
            int[] current = pq.poll();
            int curIndex = current[0];
            int curValue = current[1];
            if (nums1[right] > curValue) {
                temp[curIndex] = nums1[right--];
            } else {
                temp[curIndex] = nums1[left++];
            }
        }
        return temp;
    }
}
```
### 二叉树
- 思维模式
    - 遍历二叉树 + 外部变量
    - 定义递归函数，通过子树答案推导出原问题的答案
- 通用
    - 对于一个二叉树节点，需要做什么？什么时候做（前序、中序、后序）
        - 前序位置的代码：刚进入节点时执行
        - 后序位置代码：离开节点时执行
        - 中序位置代码：左子树遍历完，即将遍历右子树时执行
    - 其他内容交给递归遍历框架
- 快速排序：二叉树前序遍历
- 归并排序：二叉树后序遍历
#### 104.二叉树的最大深度
- 遍历 + 外部变量（记录深度，作为递归函数的参数传入）
    - 这个思路其实有点绕
    - 全局变量: res 记录最大深度，depth 记录遍历到的深度
    - 遍历到了叶子结点，去更新最大深度
```c++
    int depth = 0;
    int res = 0;
    int maxDepth(TreeNode* root) {
        recursion(root);
        return res;
    }
    void recursion(TreeNode* node) {
        if (node == NULL) {
            return;
        }
        // 前序位置
        depth++;
        if (node->left == NULL && node->right == NULL) {
            res = max(res, depth);
        }
        recursion(node->left);
        recursion(node->right);
        // 后序位置
        depth--;
    }
```
- 通过求解子树的最大深度，推导整棵树的最大深度
```c++
    int maxDepth(TreeNode* root) {
        if (root == NULL) {
            return 0;
        }
        return recursion(root, 1);
    }
    int recursion(TreeNode* node, int depth) {
        if (node->left == NULL && node -> right == NULL) {
            return depth;
        }
        int left_depth = -1;
        int right_depth = -1;
        if (node->left != NULL) {
            left_depth = recursion(node->left, depth+1);
        }
        if (node->right != NULL) {
            right_depth = recursion(node->right, depth+1);
        }
        return left_depth > right_depth? left_depth: right_depth;
    }
```
#### 144. 前序遍历
- 基于遍历的思路做了很多次了
- 基于子树的思路
    - 对于每个子树：首先加入当前节点，随后加入左子树遍历结果，最后加入右子树遍历结果
```c++
    vector<int> preorderTraversal(TreeNode* root) {
        if (root == NULL) {
            return {};
        } 
        vector<int> res;
        res.push_back(root->val);
        vector<int> left_res = preorderTraversal(root->left);
        res.insert(res.end(), left_res.begin(), left_res.end());
        vector<int> right_res =  preorderTraversal(root->right);
        res.insert(res.end(), right_res.begin(), right_res.end());
        return res;
    }
```
#### 543. 二叉树的最大半径
- 对于每个节点：最大半径=两边的最大深度之和
- 每个节点的最大深度：左右子树的最大深度
- 遍历+外部变量的思路
- 遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章
```c++
    // 每个节点记录左边的最大深度和右边的最大深度，两者相加即为（对于这个节点的）最大直径
    int maximum_diameter = 0;
    int max_depth(TreeNode* node, int depth) {
        if (node == NULL) {
            return depth;
        }
        depth++;
        int leftDepth = max_depth(node->left, depth);
        int rightDepth = max_depth(node->right, depth);
        maximum_diameter = max(leftDepth+rightDepth-2*depth, maximum_diameter);
        return max(leftDepth, rightDepth);
    }
    int diameterOfBinaryTree(TreeNode* root) {
        max_depth(root, 0);
        return maximum_diameter;
    }
```

#### 116. 填充每个节点的下一个右侧节点指针
- 第一种思路是层序遍历，把每一层的元素都连起来
- 第二种思路是遍历二叉树
    - 普通的遍历，无法处理左子树的右孩子，和右子树的左孩子之间的联系
    - 因此遍历思路成了一个三叉树的遍历 [(left.left, left.right), (left.right, right.left), (right.left, right.right)]
```java
class Solution {
    public Node connect(Node root) {
        if (root == null) return root;
        traverse(root.left, root.right);
        return root;
    }
    private void traverse (Node node1, Node node2) {
        if (node1 == null || node2 == null) return;
        node1.next = node2;
        traverse(node1.left, node1.right);
        traverse(node1.right, node2.left);
        traverse(node2.left, node2.right);
    }
}
```
#### 114. 二叉树展开为链表
- 用分解问题 + 递归的思路
```java
public void flatten(TreeNode root) {
    if (root == null) return;
    // 左右都拉平成链表了
    flatten(root.left);
    flatten(root.right);

    TreeNode tmp = root.right;
    root.right = root.left;
    root.left = null; // 这一步很重要; 因为是 in-place 操作，所以得把左指针置空
    TreeNode p = root;
    // 找到左边节点的终点
    while (p.right!=null) {
        p = p.right;
    }
    p.right = tmp;
}
```
#### 最大二叉树
- 很直接的分解问题思路
- 构造整棵树 = 根节点 + 构造左子树 + 构造右子树
```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        if (nums.length == 0) return null;
        if (nums.length == 1) return new TreeNode(nums[0]);
        return recur(nums, 0, nums.length);

    }
    private int findMaxIndex(int[] nums, int start, int end) {
        int index = start;
        int maxValue = -200000;
        for (int i=start; i<end; i++) {
            if (nums[i] > maxValue) {
                index = i;
                maxValue = nums[i];
            }
        }
        return index;
    }
    private TreeNode recur(int[] nums, int start, int end) {
        if (start >= end) {
            return null;
        }
        int maxIndex = findMaxIndex(nums, start, end);
        TreeNode node = new TreeNode(nums[maxIndex]);
        node.left = recur(nums, start, maxIndex);
        node.right = recur(nums, maxIndex+1, end);
        return node;
    }
}
```
#### 105. 从前序与中序遍历序列构造二叉树
- 还是递归的分解问题思路
- 前序: 根左右；中序: 左根右
- 主要考虑遍历左子树的时候，左子树在前序数组的位置；左子树在中序数组的位置
```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }
    private TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {
        if (preStart >= preEnd || inStart >= inEnd) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preStart]);
        int rootIndex = findIndex(inorder, inStart, inEnd, preorder[preStart]);
        int leftLength = rootIndex - inStart;
        root.left = build(preorder, preStart+1, preStart+1+leftLength, inorder, inStart, inStart+leftLength);
        root.right = build(preorder, preStart+1+leftLength, preEnd, inorder, rootIndex+1, inEnd);
        return root;
    }

    private int findIndex(int[] arr, int start, int end, int value) {
        for (int i=start; i<end; i++) {
            if (arr[i] == value) {
                return i;
            }
        }
        return start-1;
    }
}
```
#### 889. 根据前序和后序遍历，构造二叉树
```java
class Solution {
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        return build(preorder, 0, preorder.length, postorder, 0, postorder.length);
    }
    private TreeNode build(int[] preorder, int preStart, int preEnd, int[] postorder, int postStart, int postEnd) {
        if (preStart >= preEnd || postStart >= postEnd) {
            return null;
        }
        TreeNode root = new TreeNode(preorder[preStart]);
        int preLeftRoot = preStart + 1; // 这里存在越界可能，需要判断；前序遍历，根节点下一个元素，是左子树的根节点
        if (preLeftRoot >= preEnd) {
            return root;
        }
        int postLeftRoot = postStart;
        for (int i=postStart; i< postEnd; i++) {
            if (postorder[i] == preorder[preLeftRoot]) {
                postLeftRoot = i;
            }
        }// 找到后序遍历左子树的根节点，其下一个元素开始是右子树
        root.left = build(preorder, preLeftRoot, preLeftRoot+(postLeftRoot-postStart)+1, postorder, postStart, postLeftRoot+1);
        root.right = build(preorder, preLeftRoot+(postLeftRoot-postStart)+1, preEnd, postorder, postLeftRoot+1, postEnd-1);
        return root;
    }
}
```
#### 297.二叉树的序列化和反序列化
- 比如 JSON 数据格式，目标是以某种特定格式组织数据，使得数据独立于编程语言
```java
public class Codec {
    /** 采用前序遍历方式来序列化和反序列化 */
    String SEP = ",";
    String NULL = "#";
    int traverseIndex = 0;
    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        traverse(root, sb);
        String s = sb.toString();
        // 把最后的 ',' 移除, 否则在反序列化的时候，末尾会多一个空字符串 
        return s.substring(0, s.length()-1);
    }

    public void traverse(TreeNode node, StringBuilder sb) {
        if (node == null) {
            sb.append(NULL).append(SEP);
            return;
        }
        sb.append(node.val).append(SEP);
        traverse(node.left, sb);
        traverse(node.right, sb);
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] nodes = data.split(",");
        TreeNode root = traverseDeserialize(nodes);
        traverseIndex = 0; // 遍历结束之后，记得把这个全局变量重置
        return root;
    }

    public TreeNode traverseDeserialize(String[] nodes) {
        String current = nodes[traverseIndex];
        traverseIndex++;
        if (current.equals("#")) return null;
        TreeNode node = new TreeNode(Integer.parseInt(current));
        node.left = traverseDeserialize(nodes);
        node.right = traverseDeserialize(nodes);;
        return node;
    }
}

```
#### 652. 寻找重复的子树
- TODO: 写思路
```java
class Solution {
    // 思路: 序列化每颗子树
    Map<String, TreeNode> subTreeToRoot = new HashMap<String, TreeNode>();
    Set<TreeNode> duplicates = new HashSet<TreeNode>();
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        dfs(root);
        return new ArrayList<TreeNode>(duplicates);
    }
    String dfs(TreeNode node) {
        if (node == null) return " ";
        StringBuilder sb = new StringBuilder();
        sb.append(node.val);
        sb.append("(");
        sb.append(dfs(node.left));
        sb.append(")");

        sb.append("(");
        sb.append(dfs(node.right));
        sb.append(")");

        String s = sb.toString();
        if (subTreeToRoot.containsKey(s)) {
            duplicates.add(subTreeToRoot.get(s));
        } else {
            subTreeToRoot.put(s, node);
        }
        return s;
    }
    
}
```
#### 归并排序
- 本质上是后序遍历
- 代码实现上，需要一个辅助数组，便于赋值
```java
void sort(int[] nums, int lo, int hi) {
    if (lo == hi) {
        return;
    }
    int mid = lo + (hi-lo)/2;
    // 这就是后序遍历吧，两个子树先 sort, 然后根节点 merge
    sort(nums, lo, mid);
    sort(nums, mid+1, hi);
    merge(nums, lo, mid, hi);
}

void merge(int[] nums, int lo, int mid, int hi) {
    for (int i=lo; i<=hi; i++) {
        temp[i] = nums[i]; // 辅助数组，便于赋值
    }
    int i = lo, j=mid+1;
    for (int cur=lo; cur<=hi; cur++) {
        if (i > mid) {
            nums[cur++] = temp[j++];
        }
        else if (j>hi) {
            nums[cur++] = temp[i++];
        }
        else if (temp[i] < temp[j]) {
            nums[cur++] = temp[i++];
        } else {
            nums[cur++] = temp[j++];
        }
    }
}
```
- 复杂度分析
    - https://labuladong.github.io/algo/2/21/41/ 看这里头的图
    - 对于递归算法: 子问题个数 * 解决子问题的复杂度
    - 子问题个数：二叉树节点的个数
    - 子问题的复杂度：节点代表的子数组长度（要进行 merge 操作）
    - 相乘一下，复杂度就是所有子数组元素数量；每一层都是 N 个，一共 logN 层，故 O(NlogN)
##### 315.计算右侧小于当前元素的个数
- 在归并排序的基础上，在 merge 函数中夹杂私货，计算右边有多少元素更小
```java
class Solution {
    public List<Integer> countSmaller(int[] nums) {
        MergeSort ms = new MergeSort(nums);
        ms.sort(0, nums.length-1);
        List<Integer> res = new LinkedList<>();
        for (int c : ms.count) res.add(c);
        return res;
    }

    // 唯一标识一个数组元素
    class Pair {
        int val;
        int index; // 记录的是在 nums 中的下标
        public Pair(int val, int index) {
            this.val = val;
            this.index = index;
        }
    }
    
    class MergeSort {
        private Pair[] temp;
        public int[] count;
        private Pair[] arr;

        public MergeSort(int[] nums) {
            this.temp = new Pair[nums.length];
            this.count = new int[nums.length];
            this.arr = new Pair[nums.length];
            for (int i=0; i<nums.length; i++) {
                arr[i] = new Pair(nums[i], i);
            }
        }

        public void sort(int lo, int hi) {
            if (lo == hi) return;
            int mid = lo + (hi-lo)/2;
            sort(lo, mid);
            sort(mid+1, hi);
            merge(lo, mid, hi);
        }

        public void merge(int lo, int mid, int hi) {
            for (int i=lo; i<=hi; i++) {
                temp[i] = arr[i];
            }
            int i=lo, j=mid+1;
            for (int p=lo; p<=hi; p++) {
                if (i>mid) {
                    arr[p] = temp[j++];
                } else if (j>hi) {
                    count[temp[i].index] += (hi-mid); 
                    arr[p] = temp[i++];
                    // 后面这一半的元素，都比 temp[i] 要小
                } else if (temp[i].val > temp[j].val) {
                    arr[p] = temp[j++];
                } else {
                    arr[p] = temp[i++];
                    // 更新 count 数组
                    count[arr[p].index] += j - mid - 1;
                }
            }
        }
    }
}
```
##### 493. 翻转对
- 和上一题一样的思路，也是归并排序 + 私货
- 但是有一些细节需要注意，看代码
```java
class Solution {
    public int reversePairs(int[] nums) {
        MergeSort ms = new MergeSort(nums);
        ms.sort(0, nums.length-1);
        return ms.getCount();
    }

    class MergeSort {
        private int[] temp;
        private int[] nums;
        private int count;

        public MergeSort(int[] nums) {
            this.nums = nums;
            this.temp = new int[nums.length];
            this.count = 0;
        }

        public int getCount() {
            return this.count;
        }

        public void sort(int lo, int hi) {
            if (lo == hi) return;
            int mid = lo + (hi-lo)/2;
            sort(lo, mid);
            sort(mid+1, hi);
            merge(lo, mid, hi);
        }

        public void merge(int lo, int mid, int hi) {
            for (int i=lo; i<=hi; i++) {
                temp[i] = nums[i];
            }

            int i = lo, j = mid+1;
            // 这里头需要剪枝，不然时间复杂度过不去
            while (i<=mid && j<=hi) {
                while (i <= mid) {
                    // 虽然是 int[] 数组，但不能保证 2*nums[j] 还是 int，所以强制转换一下
                    if ((long) nums[i] > (long) 2*nums[j]) {
                        // 因为已经排好序了，所以 i 之后的元素也满足条件
                        this.count += (mid-i+1);
                        break;
                    } else {
                        // 看看下一个i 是否大于 2*nums[j]
                        i++;
                    }
                }
                j++;
            }
            j = mid+1;
            i = lo;

            for (int p=lo; p<=hi; p++) {
                if (i>mid) {
                    nums[p] = temp[j++];
                } else if (j>hi) {
                    nums[p] = temp[i++];
                } else if (temp[i] > temp[j]) {
                    nums[p] = temp[j++];
                } else {
                    nums[p] = temp[i++];
                }
            }
        }
    }
}
```
#### 二叉搜索树(BST)
- 对于节点 node, 其左子树上的节点都比 node 小，右子树上的节点都比 node 大
- BST 的中序遍历结果（左根右）是升序的
##### 230. 二叉搜索树中第 K 小的元素
- 最简单的思路: 直接中序遍历，取第 K 个遍历到的元素，最差情况复杂度 O(N), N 为二叉树节点个数
- 但是 BST 一般来说，增删改查的复杂度都是 O(logN), 怎么优化呢？
```
k, m: m 为当前遍历到的节点的排名
k<m: 去左子树找；
k>m: 去右子树找
k == m: 找到了
实现上，构造二叉树的时候要维护以自己为根的子二叉树，有多少个节点
```
##### 538. 二叉搜索树转换为累加树
- 如果按照 "右根左"的顺序遍历，得到的就是降序序列
- 我们要做的，就是在遍历过程中维护一个记录“之前和”的变量，然后加到每个节点上
```java
class Solution {
    private int curSum = 0;
    public TreeNode convertBST(TreeNode root) {
        traverse(root);
        return root;
    }
    
    private void traverse(TreeNode node) {
        if (node == null) {
            return;
        }
        traverse(node.right);
        curSum += node.val; // 需要包含当前节点原来的值
        node.val = curSum;
        traverse(node.left);
    }
}
```
##### 98.验证二叉搜索树
- 普通的递归有一个问题: 只知道当前根节点的值；然而二叉搜索树要求对于所有节点，其左子树上的所有点都比右子树上所有点更小；
- 关键就是能够有个辅助变量，记录全局的这个约束
```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBSTWithCons(root, null, null);
    }

    private boolean isValidBSTWithCons(TreeNode root, Integer min, Integer max) {
        if (root == null) {
            return true;
        }
        if (max != null && root.val >= max) {
            return false;
        }
        if (min != null && root.val <= min) {
            return false;
        }
        // 对于左子树，最大值就是根节点的值；最小值则是从更往上的节点继承得到的
        return isValidBSTWithCons(root.left, min, root.val) 
        && isValidBSTWithCons(root.right, root.val, max);
    }
}
```
### 图算法
- 本质上可以认为是多叉树的衍生
#### 底层实现
- 邻接表或者邻接矩阵
#### 图的遍历
- 和树差不多的递归做法
- 区别在于图中可能存在环，因此需要一个 visited 数组
##### 797. 所有可能的路径
- 老生常谈，results.add(new LinkedList<Integer>(current)); 因为 java 函数传递的是引用值
```java
class Solution {
    private List<List<Integer>> results = new LinkedList<>();
    private int[][] graph;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        LinkedList<Integer> current = new LinkedList<Integer>();
        this.graph = graph;
        current.add(0);
        traverse(0, graph.length-1, current);
        return results;
    }
    private void traverse(int n, int target, LinkedList<Integer> current) {
        if (n == target) {
            results.add(new LinkedList<Integer>(current));
        }
        if (graph[n].length == 0) return;
        for (int i=0; i<graph[n].length; i++) {
            current.add(graph[n][i]);
            traverse(graph[n][i], target, current);
            current.removeLast();
        }
        
    }
}
```
#### 环检测和拓扑排序算法

##### 207 课程表
- 场景: 存在循环依赖，则无法完成所有课程
- 将课程之间的关系建模成有向图，如果这个有向图中间存在环，则存在循环依赖
- onPath 与 visited 辨析
    - visited 是为了避免重复遍历；因此访问该节点之后，不需要设回为 false
    - onPath 是记录当前路径下已遍历的节点，判断是否会出现环；因此完成遍历之后，需要置为 false (换了一条路径了)
```java
class Solution {
    // 转化成图上是否存在环的问题
    LinkedList<Integer>[] graph; //邻接表形式的图
    boolean[] visited;
    boolean[] onPath;
    boolean cycleExists = false;
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        graph = new LinkedList[numCourses]; // LinkedList需要实例化，所以对于每个 graph[i], 下面还需要初始化
        buildGraph(prerequisites, numCourses);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        for (int i=0; i<numCourses; i++) {
            traverse(graph, i);
            if (cycleExists) return false;
        }
        if (cycleExists) return false;
        return true;
    }

    private void buildGraph(int[][] prerequisites, int numCourses) {
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge:prerequisites) { // 对于数组，同样可以使用 for-each 遍历
            int from = edge[1], to = edge[0];
            graph[from].add(to);
        }
    }
    private void traverse(List<Integer>[] graph, int node) {
        if (onPath[node]) cycleExists = true; // 存在环
        if (onPath[node] || visited[node]) return;
        
        onPath[node] = true;
        visited[node] = true;
        for (int v: graph[node]) {
            traverse(graph, v);
        }
        // 节点遍历完成，visited 仍置为 true
        onPath[node] = false;
    }
}
```

##### 210. 课程表2
- 一种学习顺序 --> 一个拓扑排序的结果
- 首先可以判断是否存在环，有环的话，无法拓扑排序
- 拓扑排序结果：图的逆后序遍历序列
- 为什么是逆后序：看 https://labuladong.github.io/algo/2/22/51/ 的两张图片例子
    - 图中存在先完成父节点学习，然后才能学习子节点的依赖关系
    - 后序: 先遍历子节点，然后才是父节点
    - 逆后序：确保了父节点都在子节点之前被访问
    
```java
class Solution {
    // 转化成图上是否存在环的问题
    LinkedList<Integer>[] graph; //邻接表形式的图
    boolean[] visited;
    boolean[] onPath;
    boolean cycleExists = false;
    List<Integer> postorder = new ArrayList<Integer>();
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        graph = new LinkedList[numCourses]; // LinkedList需要实例化，所以对于每个 graph[i], 下面还需要初始化
        buildGraph(prerequisites, numCourses);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        for (int i=0; i<numCourses; i++) {
            traverse(graph, i);
        }
        if (cycleExists) return new int[]{};
        else {
            Collections.reverse(postorder);
            int[] result = new int[numCourses];
            for (int i=0; i<numCourses; i++) {
                result[i] = postorder.get(i);
            }
            return result;
        }
    }

    private void buildGraph(int[][] prerequisites, int numCourses) {
        for (int i = 0; i < numCourses; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge:prerequisites) { // 对于数组，同样可以使用 for-each 遍历
            int from = edge[1], to = edge[0];
            graph[from].add(to);
        }
    }
    private void traverse(List<Integer>[] graph, int node) {
        if (onPath[node]) cycleExists = true; // 存在环
        if (onPath[node] || visited[node]) return;
        
        onPath[node] = true;
        visited[node] = true;
        for (int v: graph[node]) {
            traverse(graph, v);
        }
        // 后序位置
        postorder.add(node);
        onPath[node] = false;
    }
}
```
#### 二分图判定算法
- 定义：所有节点可以划分成两个互不相交的子集；每条边的两个顶点分属于这两个子集
- 作用: 高效存储数据，双向索引；比如演员和电影通过二分图形式建模，可以快速查询演员出演的电影；以及电影的参演演员
- 判定：转化成染色问题，通过 BFS/DFS 遍历；遍历过程中加上相邻节点的颜色是否相同这一判断
##### 785.判断二分图
- BFS 实现的代码如下
```java
class Solution {
    private int[] color; //0,1,2
    private boolean[] visited;
    private boolean bipartite = true;
    public boolean isBipartite(int[][] graph) {
        color = new int[graph.length];
        visited = new boolean[graph.length];
        bfs(graph);
        return bipartite;
    }

    private void bfs(int[][] graph) {
        Queue<Integer> qu = new LinkedList<Integer>();
        int nodeNum = graph.length;
        if (nodeNum <= 1) return;
        
        for (int node=0; node<nodeNum; node++) {
            if (visited[node]) continue;
            visited[node] = true;
            color[node] = 1;
            qu.offer(node);
            while (!qu.isEmpty()) {
                int curNode = qu.poll();
                int curColor = color[curNode];
                for (int nextNode: graph[curNode]) {
                    if (visited[nextNode]) {
                        if (color[nextNode] != curColor) {
                            continue;
                        } else {
                            bipartite = false;
                            return;
                        }
                    } else {
                        visited[nextNode] = true;
                        color[nextNode] = curColor == 1? 2:1;
                        qu.offer(nextNode);
                    }
                }
            }
        }
    }
}
```
##### 886. 可能的二分法
- 和上面一题基本上一致
- 我觉得不需要一个额外的 color 数组； visited 数组就够了（有三个值）
```java
class Solution {
    private boolean result = true;
    private int[] visited; // 0: 没遍历过；1: 属于 group 1, 2: 属于 group 2
    public boolean possibleBipartition(int n, int[][] dislikes) {
        List<Integer>[] graph = buildGraph(n, dislikes);
        visited = new int[n];
        for (int i=0; i<n; i++) {
            // 并不一定是一个连通图，因此需要遍历所有没 visited 过的节点
            if (visited[i] == 0) {
                dfs(graph, i, 1);
            }
        }
        return result;
    }
    List<Integer>[] buildGraph(int n, int[][] dislikes) {
        // 不能写作 List<Integer>[] graph = new List<Integer>[n]; 因为 Java 不允许创建包含泛型的数组
        List[] graph = new List[n];
        for (int i=0; i<n; i++) {
            graph[i] = new LinkedList<Integer>();
        }
        for (int i=0; i<dislikes.length; i++) {
            int nodeA = dislikes[i][0];
            int nodeB = dislikes[i][1];
            graph[nodeA-1].add(nodeB-1);
            graph[nodeB-1].add(nodeA-1);
        }
        return graph;
    }
    void dfs(List<Integer>[] graph, int currentNode, int color) {
        visited[currentNode] = color;
        for (int nextNode: graph[currentNode]) {
            if (visited[nextNode] == 0) {
                dfs(graph, nextNode, color == 1? 2: 1);
            } else if (visited[nextNode] == color) {
                result = false;
                return;
            }
        }
    }
}
```
#### 并查集 (union-find) 算法
- 针对动态连通性的算法
```java
// API
class UF {
    public void union(int p, int q)
    public boolean connected(int p, int q)
    public int count()
}
```
- 思路: 森林（数组形式存储）
- 每个节点的根节点，初始都指向自己 -- 此时有很多棵互相独立的树
- 每次调用 union, 就是将 p 的根节点指向 q 的根节点，这样就构成了一棵树
- 那么，连通性的判断，通过 p 和 q 是否有共同的根节点，即可完成
```java
// 初始版本算法
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 将两棵树合并为一棵
    parent[rootP] = rootQ;
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
// 时间复杂度分析：复杂度都是 find() 函数造成的；find() 的复杂度其实就是树的高度；但是树如果不平衡的话，复杂度就会退化到 O(N)，这是无法接受的
```
##### 优化1: 让树更加平衡
```java
class UF{
    private int count;
    private int[] parent;
    private int[] size;

    public UF(int n) {
        this.count = n;
        this.parent = new int[n]; // 初始值为自己
        this.size = new int[n];
        for (int i=0; i<n; i++) {
            this.parent[i] = i;
        }
    }
}
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 小树接在大树底下，这样比较平衡（画个图就看出来了）
    if (size[rootP] > size[rootQ]) {
        parent[rootQ] = rootP;
        size[rootP] += size[rootQ]
    } else {
        parent[rootP] = rootQ;
        size[rootQ] += size[rootP];
    }
    
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    // 根节点的 parent[x] == x
    while (parent[x] != x)
        x = parent[x];
    return x;
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
```
##### 优化2：
- 其实我只在乎树的根节点是谁，并不在乎树的结构
- 加了这个优化后，树的平衡优化就不是很必要的
```java
class UF{
    private int count;
    private int[] parent;
    private int[] size;

    public UF(int n) {
        this.count = n;
        this.parent = new int[n]; // 初始值为自己
        for (int i=0; i<n; i++) {
            this.parent[i] = i;
        }
    }
}
public void union(int p, int q) {
    int rootP = find(p);
    int rootQ = find(q);
    if (rootP == rootQ)
        return;
    // 小树接在大树底下，这样比较平衡（画个图就看出来了）
    parent[rootP] = rootQ;
    
    // parent[rootQ] = rootP 也一样
    count--; // 两个分量合二为一
}

/* 返回某个节点 x 的根节点 */
private int find(int x) {
    if (parent[x] != x) {
        parent[x] = find(parent[x]);
    }
        
    return parent[x];
}

/* 返回当前的连通分量个数 */
public int count() { 
    return count;
}
```
##### 990. 等式方程的可满足性
- 首先把 '==' 和 '!=' 分两个阶段处理
    - 对于 '==', 其实就是 union 头尾两个变量, 完成并查集（树）的构建
    - 对于 '!=', 其实就是校验变量是不是联通的（根据并查集来校验） 
```java
class Solution {
    class UF {
        private int count;
        private int[] parent;
        public UF(int n) {
            parent = new int[n];
            for (int i=0; i<n; i++) {
                parent[i] = i;
            }
        }

        public void union(int p, int q) {
            int rootP = find(p);
            int rootQ = find(q);
            if (rootP == rootQ) {
                return;
            }
            parent[rootP] = rootQ;
            count--;
        }

        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public int count() {
            return count;
        }
    }

    public boolean equationsPossible(String[] equations) {
        UF uf = new UF(26); // 因为等式两边都是小写字母
        LinkedList<String> neq = new LinkedList<String>();
        for (int i=0; i<equations.length; i++) {
            String s = equations[i];
            if (s.charAt(1) == '!') {
                neq.add(s);
            } else {
                int p = s.charAt(0) - 'a';
                int q = s.charAt(3) - 'a';
                uf.union(p, q);
            }
        }
        // 遍历要求不相等的，看看是否都不连通
        for (String s: neq) {
            int p = s.charAt(0) - 'a';
            int q = s.charAt(3) - 'a';
            if (uf.find(p) == uf.find(q)) {
                return false;
            }
        }
        return true;
    }
    
}
```
#### Prim 最小生成树算法
- 树：无环连通图
- 生成树: 包含图中所有节点的树
- 保证权重尽可能小：贪心思想（切分定理）
- 避免成环: BFS + visited 数组
##### 思路
- 可以看 https://labuladong.github.io/algo/2/22/55/ 中关于原理的证明，横切边等等
- 我的理解：首先有一个点的集合，当点集覆盖了图中的所有节点，就完成了生成树的构建
    - 那么每次通过加一条边的方式，引入新的节点；故要求这条边要连向不在点集中的节点
    - 为了保证是最小生成树，每次加的边是权重最小的
- 实现: 
    - 优先级队列存储所有邻接边
    - visited 数组，存放点集
    - 图本身具备邻接边的信息
##### 1584. 连接所有点的最小费用
```java
class Solution {
    public int minCostConnectPoints(int[][] points) {
        int n = points.length;
        // 初始化的时候，初始化成 ArrayList 或 LinkedList, 不能初始化成 List (因为是个泛型)
        List<int[]>[] graph = new LinkedList[n]; 
        for (int i=0; i<n; i++) {
            // 还需要初始化一下
            graph[i] = new LinkedList<>();
        }
        // 构造一个全连接图 （按照题目说明，图上的所有点都可以相连）
        for (int i=0; i<points.length-1; i++) {
            for (int j=i+1; j<points.length; j++) {
                int dis = manhattan_dis(points[i], points[j]);
                graph[i].add(new int[] {i, j, dis});
                graph[j].add(new int[] {j, i, dis});
            } 
        }
        Prim pr = new Prim(graph);
        return pr.getWeightedSum();
    }

    private int manhattan_dis(int[] p1, int[] p2) {
        return Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);
    }

    class Prim {
        private PriorityQueue<int[]> pq; // 优先级队列，存放邻接边
        private boolean[] inMST; // visited 数组，或者说点集
        private int weightedSum;
        // 三元组 int[]{from, to, weight} 表示一条边
        // graph[s]: 节点 s 的所有邻接边
        private List<int[]>[] graph;

        public Prim(List<int[]>[] graph) {
            this.graph = graph;
            this.pq = new PriorityQueue<>((a, b) -> {
                return a[2] - b[2]; // 权重小的排前面
            });
            this.weightedSum = 0;
            int n = graph.length;
            this.inMST = new boolean[n];
            // 先把初始节点加进去
            this.cut(0);
            this.inMST[0] = true;

            while (!pq.isEmpty()) {
                // 一个优化，加快速度
                if (this.allConnected()) {
                    break;
                }
                int[] edge = pq.poll();
                int to = edge[1];
                if (inMST[to]) { // 已经在点集中了
                    continue;
                } else {
                    int weight = edge[2];
                    weightedSum += weight;
                    inMST[to] = true;
                    this.cut(to);
                }
            }
        }

        private void cut(int s) {
            // 把节点 s 的符合条件的邻居，加入队列中
            List<int[]> nb = graph[s];
            for (int i=0; i<nb.size(); i++) {
                int[] edge = nb.get(i);
                int to = edge[1];
                if (inMST[to]) { // 已经在集合中了
                    continue;
                }
                this.pq.offer(edge);
            }
        }

        private int getWeightedSum() {
            return this.weightedSum;
        }

        private boolean allConnected() {
            for (int i=0; i<graph.length; i++) {
                if (!inMST[i]) return false;
            }
            return true;
        }
    }
}
```
#### Dijkstra 算法
- 作用: 计算从一个节点出发，到所有其他节点的最短距离
- 和 BFS 的比较: 
    - 共同点：都是每一次把相邻节点加入队列中，并更新这些节点的最短距离
    - 不同点: 
        - BFS 是不走回头路的，通过 visited 数组来停止访问；Dijkstra 是通过距离的判断，如果不是最短距离，就停止这个节点的进一步遍历
        - Dijkstra 用到了一个优先级队列，每次选择距离最小的节点（而 BFS 用的是普通队列）；这里用到了贪心思想，效率上的优化
- 代码模板
```java
// 返回节点 from 到节点 to 之间的边的权重
int weight(int from, int to);

// 输入节点 s 返回 s 的相邻节点
List<Integer> adj(int s);

// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, List<Integer>[] graph) {
    // 图中节点的个数
    int V = graph.length;
    // 记录最短路径的权重，你可以理解为 dp table
    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] distTo = new int[V];
    // 求最小值，所以 dp table 初始化为正无穷
    Arrays.fill(distTo, Integer.MAX_VALUE);
    // base case，start 到 start 的最短距离就是 0
    distTo[start] = 0;

    // 优先级队列，distFromStart 较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
        return a.distFromStart - b.distFromStart;
    });

    // 从起点 start 开始进行 BFS
    pq.offer(new State(start, 0));

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        if (curDistFromStart > distTo[curNodeID]) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (int nextNodeID : adj(curNodeID)) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);
            if (distTo[nextNodeID] > distToNextNode) {
                // 更新 dp table
                distTo[nextNodeID] = distToNextNode;
                // 将这个节点以及距离放入队列
                pq.offer(new State(nextNodeID, distToNextNode));
            }
        }
    }
    return distTo;
}
```
- 如果我只需要到达某个节点的最短路径呢?
```java
// 输入起点 start 和终点 end，计算起点到终点的最短距离
int dijkstra(int start, int end, List<Integer>[] graph) {

    // ...

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        // 优先级队列的性质保证了: 首次遍历到某个节点时，curDistFromStart就是到这个节点的最短距离
        if (curNodeID == end) {
            return curDistFromStart;
        }

        if (curDistFromStart > distTo[curNodeID]) {
            continue;
        }

        // ...
    }

    // 如果运行到这里，说明从 start 无法走到 end
    return Integer.MAX_VALUE;
}

```
##### 743.网络延迟时间
- 
```java
class Solution {
    private List<Integer[]>[] graph;

    class State {
        int node;
        int distFromStart;
        public State(int n, int d) {
            this.node = n;
            this.distFromStart = d;
        }
    }

    public int networkDelayTime(int[][] times, int n, int k) {
        constructGraph(times, n);
        // 优先级队列，根据从 n 出发的距离
        PriorityQueue<State> pq = new PriorityQueue<>((a, b) -> {
            return a.distFromStart - b.distFromStart; // 升序，return -1 的话排在前面
        });
        State st = new State(k, 0); // 把起点先加入队列
        pq.offer(st);

        // 维护一个从起点出发，到所有节点的最短距离数组
        // 初始值全部赋一个最大值（包括起点自己）; 注意因为标记从 1 到 n, 所以数组多一位
        int[] distTo = new int[n+1];
        Arrays.fill(distTo, Integer.MAX_VALUE);

        while(!pq.isEmpty()) {
            State curState = pq.poll();
            int curNode = curState.node;
            int curDist = curState.distFromStart;

            if (curDist > distTo[curNode]) {
                // 不是最短距离
                continue;
            }

            distTo[curNode] = curDist;
            for (int adj: adjs(curNode)) {
                int w = weight(curNode, adj);
                // 这里可以加一个优化，如果超过当前已知的最短距离，就不加入队列了 (不加这个优化的话，会超出内存限制)
                int newDist = curDist + w;
                if (newDist < distTo[adj]) {
                    pq.offer(new State(adj, newDist));
                }
                
            }
        }

        // 找到距离最远的那个节点
        int res = 0;
        for (int i = 1; i < n+1; i++) {
            if (i==k) continue;
            if (distTo[i] == Integer.MAX_VALUE) {
                // 有节点不可达，返回 -1
                return -1;
            }
            res = Math.max(res, distTo[i]);
        }
        return res;
    }

    private void constructGraph(int[][] times, int n) {
        // 因为节点序号是从 1 到 n, 所以数组多出来一位
        graph = new LinkedList[n+1];
        // 初始化 List
        for (int i=1; i<n+1; i++) {
            graph[i] = new LinkedList<Integer[]>();
        }
        for (int i=0; i<times.length; i++) {
            int src=times[i][0], tgt=times[i][1], weight = times[i][2];
            graph[src].add(new Integer[]{tgt, weight});
        }
    }
    // 邻接节点
    private List<Integer> adjs(int i) {
        List<Integer> results = new LinkedList<>();
        for (Integer[] neighbors: graph[i]) {
            results.add(neighbors[0]);
        }
        return results;
    }

    // 权重，-1代表不相连
    private int weight(int i, int j) {
        for (Integer[] neighbors: graph[i]) {
            if (j == neighbors[0]) {
                return neighbors[1];
            }
        }
        return -1;
    }
}
```
### 动态规划
- 状态转移方程
- 重叠子问题
- 最优子结构
<img src="图片/DP框架.png">

#### 以斐波那契数列为例
- 重叠子问题：f(n) 会需要重复计算
- 加入备忘录: 用数组存储 f(n) 的值，需要的时候先查数组，如果数组中没有，才去计算
- 备忘录可以独立为 DP Table, 然后用自底向上的方法进行计算！
#### 322. 零钱兑换
- 确定 base case: amount = 0 时返回 0
- 状态（原问题和子问题中的变量）: amount
- 选择（使得状态发生变化的行为）: 不同面值的硬币，就是选择
- dp 函数（数组）的意义: dp(n): 凑出 amount n 所需的最少硬币数量
```java
    // 自顶向下的写法
    // 重叠子问题的处理是很有必要的，不然会超时；用一个 memo 数组存储之前计算过的子问题值
    int[] memo; 
    public int coinChange(int[] coins, int amount) {
        memo = new int[amount+1];
        Arrays.fill(memo, -250);
        return dp(coins, amount);
    }

    private int dp(int[] coins, int amount) {
        // base case
        if (amount < 0) return -1;
        if (amount == 0) return 0;
        if (memo[amount] != -250) return memo[amount];

        int res = Integer.MAX_VALUE;
        for (int coin:coins) {
            int subResult = dp(coins, amount-coin);
            if (subResult < 0) continue;
            res = Math.min(res, 1+subResult);
        }
        memo[amount] = (res == Integer.MAX_VALUE) ? -1:res;
        return memo[amount];
    }
```

- 自顶向下的写法比较繁琐，主要体现在需要 memo 数组，并且要遍历所有选择，保存最小值
- 自底向上写法:
```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount+1];
    Arrays.fill(dp, amount+1);
    
    // base case
    dp[0] = 0;
    for (int i=1; i<dp.length; i++) {
        // 遍历所有选择，取最小值
        for (int coin:coins) {
            if (i-coin < 0) continue; // 没有合适的硬币
            if (dp[i-coin] == amount+1) continue; // amount+1 是初始值，说明对于 i-coin 这一面额，没有硬币方案
            dp[i] = Math.min(dp[i], 1+dp[i-coin]); // 可以直接更新 dp[i], 无需用一个 res 变量
        }
    }
    if (dp[amount] == amount + 1) return -1;
    return dp[amount];
}
```
#### 股票买卖系列
##### 整体归纳（以188. 买卖股票的最佳时机 IV为例）
- 三个状态 dp[i][k][0/1]
    - i: 第 i 天
    - k: 交易了k次
    - 0: 当前不持有股票; 1:当前持有股票
- 每天有三种选择: 买入（前提是之前的股票已经卖出）；卖出（之前买入了股票）和啥也不干
- 状态转移
```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i])// 啥也不干或者卖出
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])// 啥也不干或者买入
```
- 然后就是初始值设置，直接看底下的代码吧
##### 188. 买卖股票的最佳时机 IV
```java
public int maxProfit(int k, int[] prices) {
    int[][][] dp = new int[prices.length][k+1][2];
    // 初始化
    for (int i=0; i<prices.length; i++) {
        // 没有交易过，不可能持有股票
        dp[i][0][0] = 0;
        dp[i][0][1] = -20000; // 弄一个比较小的数
    }
    for (int j=1; j<=k; j++) {
        // 第0天，最多交易过1次
        dp[0][j][0] =  -20000;
        if (j == 1) dp[0][j][1] = -prices[0];
        else dp[0][j][1] =  -20000;
    }
    for (int i=1; i<prices.length; i++) {
        for (int j=0; j<=k; j++) {
            dp[i][j][0] = Math.max(
                dp[i-1][j][0], dp[i-1][j][1] + prices[i]
            );
            if (j-1 < 0) {
                dp[i][j][1] = dp[i-1][j][1];
            } else {
                dp[i][j][1] = Math.max(
                    dp[i-1][j][1], dp[i-1][j-1][0] - prices[i]
                );
            } 
            // System.out.println(i + " " + j + " " + dp[i][j][0] + " " + dp[i][j][1]);
        }
    }
    int max_profix = -2000;
    for (int j=0;j<=k;j++) {
        max_profix = Math.max(max_profix, dp[prices.length-1][j][0]);
    }
    return max_profix;
}
```
##### 121. 买卖股票的最佳时机
- 上一个例子，在k=1条件下的变种
##### 122. 买卖股票的最佳时机 II
- 可以先购买，然后在 同一天 出售。当天买当天卖其实就等于休息（啥也不做）；当天卖然后当天买的情况不需要考虑，
    - 9买 6卖+买 2卖 == 9买 2卖
- 那么这道题就变成k没有限制条件下的变种，状态方面就少了一个，不需要考虑 k
##### 309. 最佳买卖股票时机含冷冻期
- 冷冻期只需要修改状态方程，买入的时候需要从 i-2 的状态转移
```java
public int maxProfit(int[] prices) {
    int[][] dp = new int[prices.length][2];
    dp[0][0] = 0; // 不持有股票
    dp[0][1] = -prices[0]; // 持有股票
    if (prices.length > 1) {
        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);
        dp[1][1] = Math.max(dp[0][1], -prices[1]);
    }
    

    for (int i=2; i<prices.length; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i-1][1], dp[i-2][0] - prices[i]); // 对于第一次买入的情况， dp[i-1][0] == dp[i-2][0], 所以这里没毛病
    }
    return dp[prices.length-1][0];
}
```
#### 打家劫舍系列
- 和股票买卖是一样的动态规划套路
##### 198. 打家劫舍
- 推荐把 dp 数组的长度设置为nums.length+1
    - 这样设置下标为[0]处的初始值即可，不会涉及到 nums 数组里头的取值
    - 要注意的的是 dp[i] 对应的是 nums[i-1]
```java
public int rob(int[] nums) {
    int[][] dp = new int[nums.length+1][2];
    if (nums.length == 0) return 0;
    dp[0][0] = 0;
    dp[0][1] = -2000000;
    for (int i=1; i<=nums.length; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);
        dp[i][1] = dp[i-1][0] + nums[i-1];
    }
    return Math.max(dp[nums.length][0], dp[nums.length][1]);
}
```
##### 213. 打家劫舍2
- 主要有一个环，第一间和最后一间不能同时偷
- 我试图考虑再去增加一个状态（第一间偷了没），发现会变得非常麻烦
- 代码随想录的思路
    - 既然第一间和最后一间不能同时偷
    - 那么我们就分开考虑，第一次不考虑第一间，第二次不考虑最后一间
    - 两种考虑的结果取个最大值
```java
// 需要特别考虑的是数组长度 <= 1 的情况，这时候就不用管头尾这件事了
public int rob(int[] nums) {
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    int wo_last = robRange(nums, 0, nums.length-1);
    int wo_first = robRange(nums, 1, nums.length);
    return Math.max(wo_last, wo_first);
}

private int robRange(int[] nums, int start, int end) {
    int[][] dp = new int[end-start+1][2];
    if (end-start <= 0) return 0;
    dp[0][0] = 0;
    dp[0][1] = -2000000;
    for (int i=1; i<=end-start; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);
        dp[i][1] = dp[i-1][0] + nums[start+i-1];
    }
    return Math.max(dp[end-start][0], dp[end-start][1]);
}
```
#### 300. 最长递增子序列
- dp[i]: 以 nums[i] 结尾的最长递增子序列的长度
- 转移方程: 如果发现 nums[j] < nums[i], 则 dp[i] 可能更新为 dp[j]+1(如果值更大的话)
- 最后要遍历所有元素，找到最大的那个 dp[i] (不一定以最后一个元素结尾)
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int max_value = dp[0];

        for (int i=1; i<nums.length; i++) {
            dp[i] = 1;
            for (int j=0; j<i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[j]+1, dp[i]);
                }
            }
            max_value = Math.max(max_value, dp[i]);
        }
        return max_value;
    }
}
```
#### 72. 编辑距离
- TODO: 目前实现的是一个暴力解法，后面用动态规划来改进
```java
class Solution {
    // 初始指针都指向两个字符串的最后一位，按照从后往前的顺序
    public int minDistance(String word1, String word2) {
        return dp(word1, word1.length()-1, word2, word2.length()-1);
    }
    
    private int dp(String word1, int i, String word2, int j) {
        // i 和 j 分别指向 word1 和 word2 的某一位；指针都是从后往前
        if (i == -1) return j+1; // 需要把 word2 剩下的字符添加到 word1 前面，共 j+1 步操作
        if (j == -1) return i+1;

        if (word1.charAt(i) == word2.charAt(j)) {
            // 不做操作，指针同时往前；
            return dp(word1, i-1, word2, j-1);
        }

        return min(
            dp(word1, i, word2, j-1) + 1, // 插入一个字符(插到后面)
            dp(word1, i-1, word2, j) + 1, // 删除一个字符
            dp(word1, i-1, word2, j-1) + 1// 替换一个字符
        );
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```
- 动态规划的改进: 用一个 DP Table, 自底向上的方式
- 注意数组下标从 0 开始，而上面的 base case 是从 -1 开始，因此数组需要偏离一位
```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];

        // base case, 对应优化前代码 i==1 或 j==1 情况
        for (int i=0; i<=n; i++) {
            dp[0][i] = i;
        }
        for (int i=0; i<=m; i++) {
            dp[i][0] = i;
        }
        for (int i=1; i<=m ;i++) {
            for (int j=1; j<=n; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = min(
                        dp[i-1][j]+1,
                        dp[i][j-1]+1,
                        dp[i-1][j-1]+1
                    );
                }
            }
        }
        return dp[m][n];
    }

    private int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```


### 回溯法
<img src="图片/回溯法框架.png">

#### 46.全排列
- TODO: 了解LinkedList 和 ArrayList 的区别
```java
List<List<Integer>> results;
boolean[] visited;
public List<List<Integer>> permute(int[] nums) {
    visited = new boolean[nums.length];
    results = new LinkedList<>();
    LinkedList<Integer> cur = new LinkedList<>();
    backtracing(nums, cur);
    return results;
}
private void backtracing(int[] nums, LinkedList<Integer> cur) {
    if (cur.size() >= nums.length) {
        // 这里是根据 cur 里头的内容，new 了一个新的 LinkedList
        // 原因是前面说的，对于 Object, 函数传递其引用值
        // 因此如果这里直接 results.add(cur), 在后面的函数中由于调用了 cur.removeLast(), 会导致 cur 的内容发生变化；结果就是 results 里头都是空的 list
        results.add(new LinkedList(cur));
        return;
    } 
    for (int i=0; i<nums.length; i++) {
        if (!visited[i]) {
            visited[i] = true;
            cur.add(nums[i]);
            backtracing(nums, cur);
            cur.removeLast();
            visited[i]=false;
        }
    }
}
```
#### 51.N皇后
- 还是回溯法，只是多了一个位置上的检查（这个位置能否放皇后）
- Java 对于字符串的处理很麻烦，因此一个更加方便的做法：先用 boolean 数组记录棋盘；最后要返回结果的时候，再从 boolean 数组生成 List<String>.
```java
List<List<String>> results = new LinkedList<>();
public List<List<String>> solveNQueens(int n) {
    boolean[][] track = new boolean[n][n];
    backtrack(track, n, 0);
    return results;
}
private void backtrack(boolean[][] track, int n, int row) {
    if (row == n) {
        results.add(generateBoard(track, n));
        return;
    }
    for (int i=0; i<n; i++) {
        if (isValid(row, i, track, n)) { // 判断这个位置能否放皇后
            track[row][i]=true;
            backtrack(track, n, row+1);
            track[row][i]=false;
        }
    }
}
private List<String> generateBoard(boolean[][] track, int n) {
    List<String> cur = new LinkedList<>();
    for (int i=0; i<n; i++) {
        // 可以从 char[] 生成 String
        char[] row = new char[n];
        // 对于数组，可以用Arrays.fill() 赋初值
        Arrays.fill(row, '.');
        for (int j=0; j<n; j++) {
            if (track[i][j]) row[j]='Q';
        }
        cur.add(new String(row));
    }
    return cur;
}
private boolean isValid(int row, int col, boolean[][] track, int n) {
    for (int i=0; i<n; i++) {
        if (track[row][i]) return false;
        if (track[i][col]) return false;
    }
    int i = row;
    int j = col;
    while (i>=0 && j>=0) {
        if (track[i][j]) return false;
        i--;
        j--;
    }
    i = row;
    j = col;
    while (i>=0 && j<n) {
        if (track[i][j]) return false;
        i--;
        j++;
    }
    i = row;
    j = col;
    while (i<n && j>=0) {
        if (track[i][j]) return false;
        i++;
        j--;
    }
    i = row;
    j = col;
    while (i<n && j<n) {
        if (track[i][j]) return false;
        i++;
        j++;
    }
    return true;
}
```
#### 78.子集
- 子集: 不考虑顺序
- 遍历选择的时候: 只能按照数组的顺序，选择后面的元素（因为集合不考虑顺序）
- 所有的子集: 每次增加一个元素，都要把track加入 res 中；数组最后一个元素被加入了，就需要return;
```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> subsets(int[] nums) {
    LinkedList<Integer> track = new LinkedList<>();
    backtrack(nums, -1, track);
    return res;
}

private void backtrack(int[] nums, int index, LinkedList<Integer> track) {
    res.add(new LinkedList<>(track));
    if (index == nums.length) {
        return;
    }
    for (int i=index+1; i<nums.length; i++) { // 只能选择后面的元素
        track.add(nums[i]);
        backtrack(nums, i, track);
        track.removeLast();
    }
}
```
#### 47.全排列2
- 对于排列，需要一个 used 数组来记录元素是否访问过
- 由于要返回不重复的全排列，首先对数组进行排序，把相同元素放到一起
    - 保持相同值元素的位置关系不变（看代码）
```java
List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> permuteUnique(int[] nums) {
    boolean[] used = new boolean[nums.length];
    LinkedList<Integer> cur = new LinkedList<Integer>();
    Arrays.sort(nums);
    backtrack(nums, cur, used);
    return res;
}
private void backtrack(int[] nums, LinkedList<Integer> cur, boolean[] used) {
    
    if (cur.size() == nums.length) {
        res.add(new LinkedList<Integer>(cur));
        return;
    }
    for (int i=0; i<nums.length; i++) {
        if (used[i]) continue;
        if (i-1 >=0 && nums[i] == nums[i-1] && !used[i-1]) continue; // 保持相同值元素的位置关系不变: 如果出现在前面的这个相同元素 not used, 那么就不使用当前元素，避免相对位置发生变化
        used[i] = true;
        cur.addLast(nums[i]);
        backtrack(nums, cur, used);
        cur.removeLast();
        used[i] = false;
    }
}
```
#### 39.组合总和
- 主要的区别在于每一个数可以重复使用
    - 遍历选择的时候，应该从startIndex 开始
    - 递归调用的时候，传入的也是 startIndex, 而不是 startIndex+1
    - 递归的终止条件: 目前的和大于 target
```java
class Solution {
    List<List<Integer>> results = new LinkedList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        LinkedList<Integer> trace = new LinkedList<Integer>();
        backtrace(trace, 0, candidates, target, 0);
        return results;
    }
    private void backtrace(LinkedList<Integer> trace, int startIndex, int[] candidates, int target, int curSum) {
        if (curSum == target) {
            results.add(new LinkedList<Integer>(trace));
            return;
        }
        if (curSum > target) return;
        for (int i=startIndex; i<candidates.length; i++) {
            trace.add(candidates[i]);
            backtrace(trace, i, candidates, target, curSum+candidates[i]);
            trace.removeLast();
        }
    }
}
```
### BFS
- 常见场景: 在一个图中，找到起点到终点的最近距离
<img src="图片/BFS框架.png">

- 实际上是一个层序遍历的思路，因此保证了是最短路径
    - 比DFS 效率高；因为DFS 得把所有叶子结点（路径）遍历完了，才知道哪条是最短路径
- 访问每个节点之后，将其相邻的所有节点都加入队列中；一直循环，直到队列为空

#### 111. 二叉树的最小深度
```java
public int minDepth(TreeNode root) {
    Queue<TreeNode> que = new LinkedList<TreeNode>();
    Set<TreeNode> visited = new HashSet<TreeNode>();
    if (root == null) return 0;
    que.offer(root);
    int step = 1;
    while (!que.isEmpty()) { // 一层一层往下走
        int queSize = que.size();
        for (int i=0; i<queSize; i++) { // 遍历这一层的所有节点
            TreeNode node = que.poll();
            if (node.left == null && node.right == null) {
                return step;
            }
            if (!visited.contains(node.left) && node.left != null) que.offer(node.left);
            if (!visited.contains(node.right) && node.right != null) que.offer(node.right);
        }
        step++;
    }
    return step;
}
```

#### 752. 打开转盘锁
- 首先是字符串的处理: 如何+1, -1
- 相比于上一题，需要一个 visited set, 来避免重复访问（重复访问的话，最后可能会死循环）
- 对于每个数字，有8个相邻节点（一共4位，每一位可以+1/-1）
- 遇到 deadends 的处理和遇到 visited 的处理一致，不需要把相邻节点加入队列中
```java
class Solution {
    public int openLock(String[] deadends, String target) {
        Queue<String> q = new LinkedList<String>();
        Set<String> visited = new HashSet<String>();
        q.offer(new String("0000"));
        int step = 0;
        while (!q.isEmpty()) {
            int sz = q.size();
            for (int i=0; i<sz; i++) {
                String s = q.poll();
                if (!Arrays.asList(deadends).contains(s) && !visited.contains(s)) {
                    visited.add(s);
                    if (s.equals(target)) {
                        return step;
                    }
                    for (int idx=0; idx<4; idx++) {
                        String sp = plusOne(s, idx);
                        if (!visited.contains(sp)) {
                            q.offer(sp);
                        }
                        String sm = minusOne(s, idx);
                        if (!visited.contains(sm)) {
                            q.offer(sm);
                        }
                    }
                }
            }
            step++;
        }
        return -1;
    }
    private String plusOne(String s, int i) {
        char[] ch = s.toCharArray();
        if (ch[i] == '9') {
            ch[i] = '0';
        } else {
            ch[i] += 1;
        }
        return new String(ch);
    }
    private String minusOne(String s, int i) {
        char[] ch = s.toCharArray();
        if (ch[i] == '0') {
            ch[i] = '9';
        } else {
            ch[i] -= 1;
        }
        return new String(ch);
    }

}
```
### 二分搜索算法
<img src="图片/二分查找框架.png">

- 需要注意的: left + (right-left)/2, 能够避免溢出情况
#### 寻找一个数（基本的二分查找）
- 特点：这里使用两端都闭的区间，因此这个区间就是搜索空间
    - 循环终止的条件是搜索空间为空 --> left > right
```java
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```
#### 进阶：找到左右边界
```java
private int binarySearchLeft(int[] nums, int target) {
    int left = 0;
    int right = nums.length-1;
    while (left <= right) {
        int mid = left + (right-left)/2;
        if (nums[mid] == target) {
            if (left == mid) return left;
            else right=mid-1; // 寻找最左侧的边界，可能会导致目标值只有一个的情况被忽略，后面处理
        } else if (nums[mid] < target) {
            left = mid+1;
        } else if (nums[mid] > target) {
            right = mid-1;
        }
    }
    // 处理上面忽略的情况
    if (right+1<nums.length && nums[right+1] == target) {
        return right+1;
    }
    return -1;
}
private int binarySearchRight(int[] nums, int target) {
    int left = 0;
    int right = nums.length-1;
    if (left > right) return -1;
    while (left <= right) {
        int mid = left + (right-left)/2;
        if (nums[mid] == target) {
            if (right == mid) return right;
            else left=mid+1;// 寻找最右侧的边界，可能会导致目标值只有一个的情况被忽略，后面处理
        } else if (nums[mid] < target) {
            left = mid+1;
        } else if (nums[mid] > target) {
            right = mid-1;
        }
    }
    // 处理前面忽略的情况
    if (left-1>=0 && nums[left-1]==target) {
        return left-1;
    }
    return -1;
}
```
#### 总结（我觉得看这个就好）
- 全部都采用两端闭区间的写法
```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

// 找到左边边界
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，继续查找左侧边界
            right = mid - 1;
        }
    }
    // 判断 target 是否存在于 nums 中
    // 此时 target 比所有数都大，返回 -1
    if (left == nums.length) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left] == target ? left : -1;
    // 如果最后找到了 target, right = mid-1, 也就是说 right 指向左侧边界前面一个元素，而 left 正好指向左侧边界
}

int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，继续查找右侧边界
            left = mid + 1;
        }
    }
    // 此时 left - 1 索引越界
    if (left - 1 < 0) return -1;
    // 判断一下 nums[left] 是不是 target
    return nums[left - 1] == target ? (left - 1) : -1;
    // 如果最后找到了 target, left = mid+1, 也就是说 left 指向右侧边界后面一个元素，而 left-1 正好指向右侧边界边界
}
}

```
### 双指针法--滑动窗口
#### 76. 最小覆盖子串
- 初始 left, right 指针都为 0
- 首先不断增加 right, 直到覆盖了子串为止（寻找可行解）
    - 这时候可能还不是最小的覆盖子串，那么 left 不断增加，直到不再覆盖为止（优化可行解）
    - 记录下来这时候的区间大小
- 不断重复上述过程，始终取最小的那个区间（可能有多个子区间都能覆盖子串），直到 right 访问到字符串的末尾
```java
public String minWindow(String s, String t) {
    char[] s_array = s.toCharArray();
    char[] t_array = t.toCharArray();
    HashMap<Character, Integer> t_characters = new HashMap<Character, Integer>();
    HashMap<Character, Integer> s_characters = new HashMap<Character, Integer>();
    for (int i=0; i<t_array.length; i++) {
        mapPlus(t_characters, t_array[i]);
    }
    int left = 0, right=0;
    int subStringLeft=0, subStringRight=s_array.length;
    while (right < s_array.length) {
        mapPlus(s_characters, s_array[right]);
        char leftCharacter = s_array[left];
        if (check_coverage(t_characters, s_characters)) {
            while (check_coverage(t_characters, s_characters)) { // 寻找最小的能覆盖的子集
                leftCharacter = s_array[left];
                s_characters.put(leftCharacter, s_characters.get(leftCharacter)-1);
                left++;
            }
            if (right-left+1 < subStringRight - subStringLeft) {
                subStringLeft = left-1;
                subStringRight = right;
            }
        }
        right++;
    }
    if (subStringLeft == 0 && subStringRight == s_array.length) {
        return "";
    }
    return new String(s_array, subStringLeft, subStringRight-subStringLeft+1);
}
private void mapPlus(HashMap<Character, Integer> map, char key) {
    map.put(key, map.getOrDefault(key, 0)+1);
}
private boolean check_coverage(HashMap<Character, Integer> target, HashMap<Character, Integer> current) {
    for (char key: target.keySet()) {
        int target_value = target.getOrDefault(key, 0);
        int current_value = current.getOrDefault(key, 0);
        if (current_value < target_value) return false;
    }
    return true;
}
```
#### 567.字符串的排列
- 题目说明: s2的某个子串是不是包含 s1 中的所有字符（不考虑顺序，考虑相同字符的出现次数）
- 我开始的想法是通过比较 HashMap 是否相等，来判断
    - 但 HashMap 的相等是很难判断的，需要分别遍历两个 map 的所有key
    - 这里头的 valid 以字符为单位，计算有多少个字符的出现次数是匹配的；比起 HashMap 的相等，其判断更加容易一些。
```java
public boolean checkInclusion(String s1, String s2) {
    HashMap<Character, Integer> need= new HashMap<Character, Integer>();
    HashMap<Character, Integer> window = new HashMap<Character, Integer>();
    // 数据准备
    char[] s1_array = s1.toCharArray();
    char[] s2_array = s2.toCharArray();
    for (char c: s1_array) {
        plusMapKey(need, c);
    }
    // 这是一个固定长度的窗口，长度为 s1 的排列的长度
    int left = 0;
    int right = 0;
    int valid = 0; // 匹配的字符数量
    if (s2.length() < 1) return false;
    while (right < s2.length()) {
        plusMapKey(window, s2_array[right]);
        if (window.getOrDefault(s2_array[right], 0).equals(need.getOrDefault(s2_array[right], 0))) valid++;
        right++;
        while (right-left > s1.length()) {
            if (window.getOrDefault(s2_array[left], 0).equals(need.getOrDefault(s2_array[left], 0))) valid--;
            reduceMapKey(window, s2_array[left]);
            left++;
        }
        if (valid == need.size()) return true;
    }
    return false;
}
private void plusMapKey(HashMap<Character, Integer> map, char key) {
    map.put(key, map.getOrDefault(key, 0)+1);
}
private void reduceMapKey(HashMap<Character, Integer> map, char key) {
    map.put(key, map.getOrDefault(key, 0)-1);
}
private boolean checkCoverage(HashMap<Character, Integer> target, HashMap<Character, Integer> current) {
    if (!(target.keySet().equals(current.keySet()))) return false;
    for (char key: target.keySet()) {
        int target_value = target.getOrDefault(key, 0);
        int current_value = current.getOrDefault(key, 0);
        if (target_value != current_value) return false;
    }
    return true;
}
```

#### 3. 无重复字符的最长子串
- 这个滑动窗口的题目比之前要简单一些，只需要用一个集合记录之前访问过的字符
- 出现重复字符时，移动左边指针，直到移除了重复字符
- 用一个 maxLen 不断记录最长子串的长度
```java
public int lengthOfLongestSubstring(String s) {
    HashSet<Character> target = new HashSet<Character>();
    char[] s_array = s.toCharArray();
    int maxLen = 0;
    int right = 0;
    int left = 0;
    while (right < s.length()) {
        char c = s_array[right];
        // 还没有出现重复字符
        if (!target.contains(c)) {
            target.add(c);
            right++;
            continue;
        }
        // 刚刚出现重复字符
        maxLen = Math.max(maxLen, right-left);
        while(s_array[left] != c) {
            target.remove(s_array[left]);
            left++;
        }
        left++;
        right++;
    }
    maxLen = Math.max(maxLen, right-left);
    return maxLen;
}
```

#### 438. 找到字符串中所有字母异位词
- 感觉这道题并不需要滑动窗口: 遍历所有相同长度的子串，并且记录字母出现的频率即可
    - 再思考一下，滑动窗口做法，相比于枚举所有长度相同的子串，其优势是少了子串枚举的这个循环，时间复杂度上低一些
```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        HashMap<Character, Integer> need = new HashMap<Character, Integer>();
        HashMap<Character, Integer> window = new HashMap<Character, Integer>();
        // 记录 p 中出现的 characters
        for (int i=0; i<p.length(); i++) {
            char c = p.charAt(i);
            need.put(c, need.getOrDefault(c, 0)+1);
        }
        int left = 0, right = 0;
        int valid = 0; // 记录有多少个字符匹配上了
        LinkedList<Integer> res = new LinkedList<Integer>();
        while (right < s.length()) {
            char c = s.charAt(right);
            // 根据新来的字符，更新频率
            if (need.containsKey(c)) {
                // Java 的 map, 不能够直接用 window[c] 来取值
                window.put(c, window.getOrDefault(c, 0)+1);
                if (need.getOrDefault(c, 0).equals(window.getOrDefault(c, 0))) {
                    valid++;
                }
            }
            right++;
            // 重要！我们需要始终限制这个滑动窗口的大小与子串一致
            // 但是感觉这题不是很滑动窗口吧，循环一遍是不是也可以？
            while (right - left >= p.length()) {
                if (valid == need.size()) {
                    res.add(left);
                }
                char d = s.charAt(left);
                left++;
                if (need.containsKey(d)) {
                    if (need.getOrDefault(d, 0).equals(window.getOrDefault(d, 0))) {
                        valid--;
                    }
                }
                window.put(d, window.getOrDefault(d, 0)-1);
            }
        }
        return res;
    }
}
```
#### 滑动窗口延伸: RABIN KARP 字符匹配算法
- 先说一个滑动窗口中的哈希值计算方法
    - 滑动窗口中往往要比较窗口值和目标值
    - 字符串匹配复杂度比较高，而且如果每次都substring一个新的字符串，很浪费
    - 我们发现，窗口基本上就是 '左移' 和 '右移' 两个操作
    - 和数字的去除最高位，添加最低位类似
    - 所以可以把字符串序列化成数值，比较起来也方便
```java
/* 在最低位添加一个数字 */
// number 的进制
int R = 4;
// 想在 number 的最低位添加的数字
int appendVal = 0~3 中的任意数字;
// 运算，在最低位添加一位
number = R * number + appendVal;

/* 在最高位删除一个数字 */
// number 的进制
int R = 4;
// number 最高位的数字
int removeVal = 0~3 中的任意数字;
// 此时 number 的位数
int L = ?;
// 运算，删除最高位数字
number = number - removeVal * R^(L-1);

```
- RABIN KARP 算法，就利用了这个滑动哈希技巧，从字符串中找到匹配的模式串

##### 28. 找出字符串中第一个匹配项的下标
- 目前的算法还存在不足，那就是哈希值可能溢出
    - 可以用一个比较大的数（比如这个类型的临界值），然后把哈希值对这个数求余
    - 不过又引出了哈希冲突的处理问题
```java
class Solution {
    // 为什么不是 26? 因为如果把 'a' 转化成 0 的话，'aaa' 和 'aa' 的哈希值就一样了
    private int R = 27; 
    public int strStr(String haystack, String needle) {
        int left = 0, right = 0;
        long needHash = getHash(needle); // 发现对于 int 会溢出, 改用 long
        long curNumber = 0;
        while (right < haystack.length()) {
            // 添加一位数
            curNumber = curNumber * R + haystack.charAt(right) - 'a' + 1; // 把 'a' 转化成 1, 依次类推

            if (curNumber == needHash) {
                return left;
            }
            right++;
            while (right - left >= needle.length()) {
                // 缩减一位数
                curNumber -= (haystack.charAt(left) - 'a' + 1) * Math.pow(R, right-left-1);
                left++;
            }
        }
        return -1;
    }
    private long getHash(String s) {
        // 题目中说了，字符串仅由小写英文字符组成
        long number = 0;
        for (int i=0; i<s.length(); i++) {
            int appendVal = s.charAt(i) - 'a' + 1;
            number = number * R + appendVal;
        }
        return number;
    }
}
```
## 代码随想录
### 理论
#### 时间复杂度
- 一个函数，定性描述算法的运行时间
- 通过估算算法的操作单元数量，来表示时间复杂度
- 记操作单元数量为 f(n), 时间复杂度为 O(f(n))
- O的定义表示上界，算法在最坏情况下的运行时间上界
    - 然而大多数时候，讲到复杂度，讲的是一般情况下的复杂度
    - 比如快速排序 O(nlogn), 指的就是一般情况下
##### 复杂表达式的化简
- $O(2*n^2 + 10*n + 1000)$
- 去掉常数项 $O(2*n^2 + 10*n)$
- 去掉常数系数 $O(n^2 + n)$
- 只保留最高项 $O(n^2)$
##### O(logn) 以什么为底？
- 都有可能，我们忽略对底数的描述
##### 递归算法的时间复杂度
- 复杂度 = 递归次数 * 每次递归的操作次数
- 以求x 的 n 次方为例
```c++
// 递归次数 n, 操作次数1（一次乘法）， O(n)
int function2(int x, int n) {
    if (n == 0) {
        return 1; // return 1 同样是因为0次方是等于1的
    }
    return function2(x, n - 1) * x;
}
```
```c++
int function3(int x, int n) {
    if (n == 0) {
        return 1;
    }
    if (n % 2 == 1) {
        return function3(x, n / 2) * function3(x, n / 2)*x;
    }
    return function3(x, n / 2) * function3(x, n / 2);
}
```
- function3 可以表示为一颗满二叉树
- <img src="图片/求平方和.png">
- 每个节点执行一次乘法操作
- 总共$2^m + 2^(m-1) + ... 2^0 = 2^(m+1)-1$个节点
- 已知$m = log_2^n - 1$
- 带入$2^(m+1)-1$, 得到 $n-1$, 复杂度还是 O(n)
```c++
int function4(int x, int n) {
    if (n == 0) {
        return 1;
    }
    int t = function4(x, n / 2);// 这里相对于function3，是把这个递归操作抽取出来
    if (n % 2 == 1) {
        return t * t * x;
    }
    return t * t;
}
```
- 每次递归一个乘法操作
- 递归次数: 16 -> 8 -> 4 -> 2 -> 1, $log_2^n+1$
- 所以复杂度 $O(log_2^n+1)$
#### 空间复杂度
- 考虑程序运行时，占用内存的大小
```c++
// 简单例子，空间复杂度 O(n)
int* a = new int(n);
for (int i = 0; i < n; i++) {
    a[i] = i;
}
```
#### 递归算法的时间复杂度和空间复杂度
- 时间复杂度: 递归次数 * 每次递归的操作次数
- 递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度
    - 为什么是递归深度？每次递归所需空间压到调用栈中；等到递归结束，调用栈把本次递归的数据弹出去；所以调用栈的最大长度就是递归深度
```c++
int fibonacci(int i) {
       if(i <= 0) return 0;
       if(i == 1) return 1;
       return fibonacci(i-1) + fibonacci(i-2);
}
```
- 计算时间复杂度，可以画出如下调用二叉树
- <img src="图片/fibonacci.png">
- 树的高度为 n-1 (最后一层移到右边)，则满二叉树的节点数应该是 $2^n-1$
- 每次递归，做一次加法
- 故，时间复杂度 $O(2^n)$

```c++
// 版本二
int fibonacci(int first, int second, int n) {
    if (n <= 0) {
        return 0;
    }
    if (n < 3) {
        return 1;
    }
    else if (n == 3) {
        return first + second;
    }
    else {
        return fibonacci(second, first + second, n - 1);
    }
}
```
- 递归每次 n-1, 所以递归次数为n, 每次操作次数仍然为1
- 时间复杂度 O(n)
- 空间复杂度 O(n)

```c++
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```
- 二分法的递归深度是 $\log_2 {n}$
- C++ 中传递数组，实际传的是数组首元素地址
    - 每次递归公用一块数组空间，而每次递归本身的复杂度是 O(1)
- 单论这段代码，空间复杂度$\log_2 {n}$
    - 外部肯定还有数组的创建，那部分空间复杂度 O(n)
#### 内存管理
##### 存储空间的分类
- <img src="图片/C存储空间.png">
##### 不同编程语言
- C/C++: 内存堆空间的申请和释放由自己管理 （常常造成内存泄漏）
- Java: JVM 做内存管理
- Python: 私有堆空间，解释器才能访问
##### 数据类型的大小
- <img src="图片/数据类型.png">
- 为什么指针大小会不同
    - 32位机器上，内存一般 <= 4G, 也就是 $2^{32}$, 4个 Byte足以寻址
    - 64位机器上，内存 >4G, 所以指针需要 8Byte 来进行寻址
##### 内存对齐
- 原因
    - 平台：有些硬件平台只能在某些地址取某些数据
    - 硬件：内存对齐后， 提升 CPU 访问内存的速度
- CPU按块来读取内存，块的大小可以是2, 4, 8, 16 byte, 由硬件决定
- 假设块的大小为4个 byte, 没有内存对齐的情况下，读取一个 int(4 byte)
- <img src="图片/内存对齐.png">
- 需要两次寻址；如果对齐了，则只需要一次寻址
- 当然，内存对齐会浪费内存资源；但一般内存是充足的，运行速度是更重要的
### 各种数据结构的使用技巧
想到哪写到哪吧
#### unordered_map
- 元素是否存在于 map: ```map.find(i) != map.end()```
- 想++：首先检查哈希表中是否有这个值，有则++；无则置为1
```c++
if (numOccurences.find(arr[i]) != numOccurences.end()) {
    numOccurences[arr[i]]++;
} else {
    numOccurences[arr[i]] = 1;
}
```
- 遍历 map
```c++
for (pair<int, int> myPair: numOccurences) {
    int num = myPair.second;
```

#### 构造函数
- new UnionFind(): 返回一个指向对象的指针
- UnionFind(): 返回对象
#### 队列
- 声明: queue<vector<int>> qu;
    - queue<pair<int, int>> qu;
- qu.push() 入队
- qu.pop() 出队
- qu.front() 取队首元素
- qu.back() 取队尾元素
#### string
- s.substr(1,5): 从下标1开始，长度为5的子串
- s.pop_back()
- s.empty()
#### 依赖两个变量的循环体
```c++
for (int i=row-1,j=col-1; i>=0 && j>=0; i--, j--) {
    if (visited[i][j]) {
        return false;
    }
}
```
### 查找
#### 二分查找
##### 34. 在排序数组中查找元素的第一个和最后一个位置
###### 思路1
- 利用二分法找到 target 的一个位置 （也有可能找不到）
- 这个位置向左 向右延伸，应该都是相等元素，找到边界
```c++
int search(vector<int> nums, int start, int end, int target) {
    if (start > end) return -1;
    if (start == end) return nums[start] == target ? start : -1;
    int mid = (start + end)/2;
    if (nums[mid] == target) return mid;
    if (nums[mid] < target) return search(nums, mid+1, end, target);
    else return search(nums, start, mid, target);
}
vector<int> searchRange(vector<int>& nums, int target) {
    int index = search(nums, 0, nums.size()-1, target);
    if (index == -1) return {-1, -1};
    int left = index, right = index;
    while (left > 0 && nums[left-1] == target) left--;
    while (right < nums.size()-1 && nums[right+1] == target) right++;
    return {left, right};
}
```
###### 思路2 直接去找到 target 在数组中的左边界，右边界 （可能不存在）
- 我觉得很难理解，别用这个做法吧
##### 540. 有序数组中的单一元素
- 要求 O(logN) 复杂度，条件反射是二分法
- 有序数组总长一定是奇数（这样才会有单一元素）
- 去掉中间的一对相同元素后，长度为奇数的区间，包含单一元素
```c++
int singleNonDuplicate(vector<int>& nums) {
    int start = 0, end = nums.size()-1;
    while (start < end) {
        int mid = (start + end)/2;
        bool leftHalfEven = (mid-start) %2 == 0;
        if (nums[mid] == nums[mid+1]) {
            // 左半区间为偶数，右半区间-1 (mid+1) 为奇数
            if (leftHalfEven) start = mid+2;
            else end = mid-1;
        } else if (nums[mid] == nums[mid-1]) {
            // 左半区间-1为奇数
            if (leftHalfEven) end = mid-2;
            else start = mid+1;
        } else {
            // 和左右元素都不相等
            return nums[mid];
        }
    }
    return nums[start];
}
```
### 数组
#### 一维数组的存储空间是连续的，那么二维数组？
- 取决于语言实现。C++是连续分布；Java由虚拟机完成寻址操作，不是连续分布。
#### 704 二分查找
- 直接用循环二分查找即可，不一定要递归
```c++
int search(vector<int>& nums, int target) {
    int low = 0;
    int len = nums.size();
    int high = len - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (mid >= len) return -1;
        if (nums[mid] == target) return mid;
        if (nums[mid] > target) {v
            high = mid -1;
        } else {
            low = mid + 1;
        }
    }
    return -1;v
}
```
#### 209 长度最小的子数组
- 为什么认为需要双指针法？
    - 很可能需要回溯起始位置，来保证每个子数组都检查到。回溯这一操作需要双指针来完成
```C++
 int minSubArrayLen(int target, vector<int>& nums) {
    int slowIndex=0, fastIndex=0, total=0, minLength=1e5;
    int len = nums.size();
    while (slowIndex < len) {
        // 特殊情况处理，剪枝
        if (fastIndex >= len && total < target) break;
        if (total < target && fastIndex < len) {
            total += nums[fastIndex];
            fastIndex++;
        } else {
            minLength = min(fastIndex - slowIndex, minLength);
            total -= nums[slowIndex];
            slowIndex++;
        }
    }
    if (minLength == 1e5) return 0;
    return minLength;
}
```
#### 59 螺旋矩阵2
```c++
// n*n 二维向量的初始化
vector<vector<int>> res(
    n,
    vector<int>(n)
)
// 二维数组的初始化
int direction[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
```
#### 三数之和
- 仍然是双指针法的应用
- for 循环 遍历起始位置 i
- left 从 i+1 开始， right 从 len-1 开始
- 三数之和小于0 left++
- 三数之和大于0 right--
- ==0 加入向量， left++, right--
```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    int len = nums.size();
    if (len < 2) return res;
    sort(nums.begin(), nums.end());
    for (int i=0; i<len-2;i++) {
        int left = i+1;
        int right = len-1;
        if (i>=1 && nums[i] == nums[i-1]) continue; // 去重
        if (nums[i] > 0) break;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] < 0) {
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
            }
            else if (nums[i] + nums[left] + nums[right] > 0) {
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
            else if (nums[i] + nums[left] + nums[right] == 0) {
                // 以下五行可化简为: res.push_back(vector<int>({nums[i], nums[left], nums[right]}));
                vector<int> cur;
                cur.push_back(nums[i]);
                cur.push_back(nums[left]);
                cur.push_back(nums[right]);
                res.push_back(cur);
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
        }
    }
    return res;
```
- **另外的注意点--去重**
- left++, 实际上需要跳过所有相等的值, right--同理
- 
```c++
do {
    left++;
} while(left < len && nums[left] == nums[left-1]);
```
- 遍历i 时，跳过和前一个值相等的
```c++
if (i>=1 && nums[i] == nums[i-1]) continue;
```

#### 1365. 小于当前数字的数字
- 小于当前数字 -- 很容易想到要排序
- 但是不能打乱原数组顺序 -- copy 一个数组来排序
- 排序后的数组，我们知道值，如何映射到原数组的下标？ 一个 <value, index> map
```c++
vector<int> smallerNumbersThanCurrent(vector<int>& nums) {
    unordered_map<int, vector<int>> vtoi; // (value, indexes)
    vector<int> sorted(nums.size());
    vector<int> res(nums.size());
    // copy array + map
    for (int i=0; i<nums.size(); i++) {
        sorted[i] = nums[i];
        vtoi[nums[i]].push_back(i);
    }

    sort(sorted.begin(), sorted.end());
    for (int i=0; i<sorted.size(); i++) {
        // 相同的数，跳过
        if (i-1>=0 && sorted[i] == sorted[i-1]) continue;
        vector<int> indexes = vtoi[sorted[i]];
        for (int index: indexes) {
            res[index] = i;
        }
    }
    return res;
}
```
#### 1207. 独一无二的出现次数
- 弄两个map
    - 第一个存储每个数字的出现频率
    - 第二个存储上一个 map 中，每个频率的出现次数；遇到大于1的，直接 return false;
```c++
bool uniqueOccurrences(vector<int>& arr) {
    if (arr.size() <=1) return true;
    unordered_map<int, int> numOccurences;
    for (int i=0; i<arr.size(); i++) {
        if (numOccurences.find(arr[i]) != numOccurences.end()) {
            numOccurences[arr[i]]++;
        } else {
            numOccurences[arr[i]] = 1;
        }
    }
    unordered_map<int, int> occurencesMap;
    for (pair<int, int> myPair: numOccurences) {
        int num = myPair.second;
        if (occurencesMap.find(num) != numOccurences.end()) {
            return false;
        } else {
            occurencesMap[num] = 1;
        } 
    }
    return true;
}
```
#### 283. 移动0
- 双指针，slow遍历 0 --> nums.size()-1
- fast = slow+1, 遇到非0元素，交换 (slow, fast), 则非0元素跑到后面
- 如果 fast == nums.size(), 说明后面都是0了，不需要继续交换了
- 由于 slow, fast 从前往后, 所以保证了非0元素的顺序
```c++
void moveZeroes(vector<int>& nums) {
    int slow = 0, fast = 1;
    while (slow < nums.size() - 1) {
        if (nums[slow] != 0) {
            slow++;
            continue;
        }
        fast = slow+1;
        while (fast < nums.size() && nums[fast] == 0) fast++;
        if (fast == nums.size()) return;
        swap(nums[slow], nums[fast]);
        slow++;
    }
}
```
#### 189. 旋转数组
- 空间复杂度 O(n) 的做法，就是另外弄一个数组，然后旋转
- 空间复杂度 O(1): 类似字符串的旋转：整体旋转 + 部分旋转
```c++
void myReverse(vector<int>& nums, int start, int end) {
    while (start < end) {
        swap(nums[start], nums[end]);
        start++;
        end--;
    }
}
void rotate(vector<int>& nums, int k) {
    k = k % nums.size();
    reverse(nums.begin(), nums.end());
    myReverse(nums, 0, k-1);
    myReverse(nums, k, nums.size()-1);
}
```
#### 922.按奇偶排序数组2
- 奇数下标的偶数， 和 偶数下标的奇数进行交换即可, 原地修改数组
```c++
void searchAndSwap(vector<int>& nums, int index) {
    // +=2: 只需要找奇数下标的/偶数下标的
    for (int i= index+1; i<nums.size(); i+=2) {
        if (i % 2 != nums[i] % 2) {
            swap(nums[index], nums[i]);
        }
    }
}
vector<int> sortArrayByParityII(vector<int>& nums) {
    for (int i=0; i<nums.size(); i++) {
        if (nums[i] % 2 != i%2) searchAndSwap(nums, i);
    }
    return nums;
}
```
### 链表
#### 基础知识
- 链表节点不是连续分布，而是散乱分布
- c++ 链表定义方式
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}; // 构造函数

}
```
- **添加虚拟头结点，可以同化对所有节点的操作，降低复杂度**
#### 203.移除链表元素
- 体现虚拟头结点的作用
```c++
ListNode* removeElements(ListNode* head, int val) {
    ListNode* vHead = new ListNode(0, head);
    ListNode* prev = vHead;
    ListNode* cur = vHead -> next;
    while (cur != NULL) {
        if (cur -> val == val) {
            prev -> next = cur -> next;
            cur = cur -> next;
        } else {
            prev = cur;
            cur = cur -> next;
        }
    }
    return vHead -> next;
}
```
- 仍然存在问题，别忘了释放空间！（虚拟头节点 + 被删除的节点）
```c++
ListNode* tmp;
delete(tmp);
```

#### 面试题 02.07. 链表相交
这一题要看图
简单的思路: 两个指针分别从 headA, headB出发，每次走一步
如果链表A 走完了，就走链表 B; 链表B 走完了，走A
当两个指针所指的节点相等，则遇到交点了

代码实现过程中有不少注意点
```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* nodeA = headA;
    ListNode* nodeB = headB;
    // 因为环不一定存在，为了避免无限循环，控制每个链表只遍历一次
    bool finishA = false, finishB = false;
    // 链表为 NULL 也需要考虑
    if (nodeA == NULL || nodeB == NULL) return NULL;
    while (true) {
        if (nodeA == NULL && !finishA) {
            nodeA = headB;
            finishA = true;
        } else if (nodeA == NULL && finishA) {
            // 只能遍历一次，不允许重复遍历
            break;
        }

        if (nodeB == NULL && !finishB) {
            nodeB = headA;
            finishB = true;
        } else if (nodeB == NULL && finishB) {
            break;
        } 
        // 很可能第一个节点就相等，所以相等判断 先于 往后走一步
        if (nodeA == nodeB) return nodeA;

        nodeA = nodeA -> next;
        nodeB = nodeB -> next;
    }
    return NULL;
}
```
#### 19. 删除链表的倒数第n个节点
希望能用一趟扫描实现
可以先往前 n+1个节点记作node，然后开始记录 prev = head, cur = head->next,
这样随着 node 往下走， cur 一直是倒数第n个节点
当 node == NULL, 删除 cur 节点即可
```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    ListNode* node = head;
    int i=0;
    while (node != NULL && i<n) {
        node = node->next;
        i++;
    }
    if (node == NULL) return head->next;
    node = node->next;
    ListNode* prev = head;
    ListNode* cur = head->next;
    while (node != NULL) {
        node = node -> next;
        prev = prev -> next;
        cur = cur->next;
    }
    prev -> next = cur->next;
    delete(cur);
    return head;
}
```
#### 24. 两两交换链表中的节点
通过模拟过程，来实现交换
只不过我们需要保存四个值
prev, cur(第一个要交换的值), next1（第二个要交换的值）, next2
```c++
ListNode* swapPairs(ListNode* head) {
    if(head == NULL) return NULL;
    ListNode* cur = head;
    ListNode* prev = NULL;
    ListNode* next1 = head->next;

    while (next1 != NULL) {
        ListNode* next2 = next1->next;
        if (prev != NULL) {
            prev -> next = next1;
        }
        if (cur == head) {
            head = next1;
        }
        next1 -> next = cur;
        cur -> next = next2;
        prev = cur;
        cur = next2;
        if (next2 == NULL) next1 = NULL;
        else next1 = next2 -> next;
    }

    return head;
}
```
#### 143.重排链表
- 先用一个数组存放链表每个位置的元素
- 然后双指针法，重排链表 （也可以用递归方法）
- 最后一个元素特殊处理
```c++
void reorderList(ListNode* head) {
    vector<ListNode*> arr;
    if (head == NULL) return;
    
    ListNode* node = head;
    while (node != NULL) {
        arr.push_back(node);
        node = node -> next;
    }

    ListNode* cur = arr[0];
    int left = 1, right = arr.size()-1;
    while (left < right) {
        cur -> next = arr[right];
        right--;
        cur = cur->next;
        cur->next = arr[left];
        left++;
        cur = cur->next;
    }
    if (left == right) {
        cur-> next = arr[left];
        cur = cur->next;
    }
    // 置 NULL 要记得，否则会报错（找不到链表结尾）
    cur->next = NULL;
    
    return;
}
```
### 哈希表
#### 例子
- 学生名字 通过 hashFunction, 得到索引
- 通过索引直接访问对应数据
- 作用：快速判断一个元素是否出现在集合中
#### 数据结构选用
##### Set
- 优先选用std:unordered_set, 查询和增删效率最优
- 需要集合有序：std:set
- 有序加重复数据: std:multi_set
#### 1002. 查找常用字符
- 数组中的每个字符串，对应一个26位数组，存储每个字母出现的频率
- 两个 26 维数组取最小值，符合“所有字符串都显示”这一定义
- 小技巧
    - 数组初始化 int hash[26] = {0};
    - char to string: string s(1, i + 'a');
```c++
vector<string> commonChars(vector<string>& words) {
    vector<string> result;
    int len = words.size();
    if (!len) {
        return result;
    }
    int hash[26] = {0};
    string word = words[0];
    for (int i=0; i< word.length(); i++) {
        hash[word[i] - 'a'] += 1;
    }
    for (int i=1; i< words.size(); i++) {
        int hashOther[26] = {0};
        string word = words[i];
        for (int i=0; i< word.length(); i++) {
            hashOther[word[i] - 'a'] += 1;
        }
        for (int i=0; i<26; i++) {
            hash[i] = min(hash[i], hashOther[i]);
        }
    }
    for (int i=0; i<26; i++) {
        while (hash[i] > 0) {
            string s(1, i + 'a');
            result.push_back(s);
            hash[i]--;
        }
    }
    return result;
}
```
#### 18. 四数之和
- 固定遍历的是前两个数
- 最后两个数采用双指针法，一个往前 一个往后， 直到相遇

去重
```
数组长度小于 4
所有元素都是正数时， nums[0] > target
nums[i] == nums[i-1]
nums[k] == nums[k-1] (不包括 k-1 == i 的情况)
slow++, fast-- 都要跳过相等的元素
```
```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    if (nums.size() < 4) return res;
    sort(nums.begin(), nums.end());
    if (nums[0] >= 0 && nums[0] > target) return res;

    for (int i=0;i<nums.size()-3; i++) {
        if (i>0 && nums[i] == nums[i-1]) continue;
        for (int k=i+1; k<nums.size()-2;k++) {
            // 去重
            if (k > i+1 && nums[k] == nums[k-1]) continue;
            int slow = k+1;
            int fast = nums.size() - 1;
            while (slow < fast) {
                int total = nums[i] + nums[k] + nums[slow] + nums[fast];
                if (total < target) {
                    do {
                        slow++;
                    } while(slow < fast && nums[slow] == nums[slow-1]);
                }
                else if (total == target) {
                    res.push_back({nums[i], nums[k], nums[slow], nums[fast]});
                    do {
                        slow++;
                    } while(slow < fast && nums[slow] == nums[slow-1]);
                    do {
                        fast--;
                    } while(slow < fast && nums[fast] == nums[fast+1]);
                } else {
                    do {
                        fast--;
                    } while(slow < fast && nums[fast] == nums[fast+1]);
                }
            }
        }
    }

    return res;
}
```
#### 205.同构字符串
两个哈希表（因为没说都是小写字母，不知道数量）
分别是 s到t, t到s 的映射
```c++
bool isIsomorphic(string s, string t) {
    if (s.length() != t.length()) return false;
    unordered_map<char, char> myMap1;
    unordered_map<char, char> myMap2;
    for (int i=0; i<s.length(); i++) {
        if (myMap1.find(s[i]) != myMap1.end()) {
            if (myMap1[s[i]] != t[i]) return false;
        } else {
            myMap1[s[i]] = t[i];
        }
        if (myMap2.find(t[i]) != myMap2.end()) {
            if (myMap2[t[i]] != s[i]) return false;
        } else {
            myMap2[t[i]] = s[i];
        }
    }
    return true;
}
```
### 字符串
#### 344.反转字符串
- 简单的双指针法
#### 541. 反转字符串2
- 反转部分可以通过循环完成: 起始:low, 终止: high
- 每 2k 字符进行反转：循环完成
- 检查 len - i < k?
```c++
void reverse(string &s, int low, int high) {
  for (int i=0; i<= (high - low) /2; i++) {
    char tmp = s[low + i];
    s[low + i] = s[high - i];
    s[high - i] = tmp;
  }
}
string reverseStr(string s, int k) {
  int len = s.length();
  for (int i=0; i< len; i += 2*k) {
    if (len - i < k) {
        reverse(s, i, len-1);
    } else {
        reverse(s, i, min(len-1, i+k-1));
    }
  }
  return s;
}
```
#### 剑指 Offer 58 - II. 左旋转字符串
- 在不添加额外空间的前提下进行旋转
- 提示: 整体反转 + 局部反转
#### KMP 算法
**看了白看，还是不会！！**********
https://gitee.com/programmercarl/leetcode-master/blob/master/problems/0028.%E5%AE%9E%E7%8E%B0strStr.md
当遇到字符串不匹配时，记录一部分之前已经匹配的内容，避免从头再去匹配
问题描述：要在文本串aabaabafa 中 找出模式串 aabaaf
##### 前缀表
下标 i 之前（包括i) 的字符串中，有多大长度的相同 前缀 后缀
前缀表指向已经匹配的位置，我们下一次从这个位置开始匹配即可
为啥？后缀 == 前缀，所以后缀之后的字符串匹配前缀之后的字符串即可
##### 计算前缀表
双指针，一个从首位，一个从末位

#### 925. 长按键入
- 考虑 name 中的字符（包括连续的相同字符）
- typed 中的该字符序列，长度必须大于等于 name 中的
- 此外，如果一者到达终点，另一者未到达，同样也是不匹配的
```c++
bool isLongPressedName(string name, string typed) {
    int nameIndex = 0, typedIndex = 0;
    while (nameIndex < name.length()) {
        if (typedIndex >= typed.length()) return false;
        int nameCount = 0;
        char cur = name[nameIndex];
        while (nameIndex < name.length() && name[nameIndex] == cur) {
            nameCount++;
            nameIndex++;
        }
        int typeCount=0;
        while (typedIndex < typed.length() && typed[typedIndex] == cur) {
            typeCount++;
            typedIndex++;
        }
        if (typeCount < nameCount) return false;
    }
    if (typedIndex < typed.length()) return false;
    return true;
}
```
#### 844. 比较含退格的字符串
- 退格：可以用栈来模拟，栈首元素出栈
```c++
bool backspaceCompare(string s, string t) {
    if (s.length() == 0 && t.length() == 0) return true;
    if (s.length() == 0 || t.length() == 0) return false;
    stack<char> st1;
    stack<char> st2;
    for (int i=0; i<s.length(); i++) {
        if (s[i] == '#') {
            if (!st1.empty()) st1.pop();
        } else {
            st1.push(s[i]);
        }
    }
    for (int i=0; i<t.length(); i++) {
        if (t[i] == '#') {
            if (!st2.empty()) st2.pop();
        } else {
            st2.push(t[i]);
        }
    }
    while (!st1.empty() && !st2.empty()) {
        if (!(st1.top() == st2.top())) return false;
        st1.pop();
        st2.pop();
    }
    return st1.empty() && st2.empty();
}
```
- 但其实，string 也可以当做栈来用
    - s.pop_back()
    - s.empty()
### 栈和队列
#### 20.有效的括号
- 匹配问题可应用栈
- 遇到左括号 入栈
- 遇到右括号 出栈 看是否匹配
- 未遍历完成，栈空 || 遍历完成，栈非空，则无效
#### 150. 逆波兰表达式求值
- 还是栈的应用
- string to int: stoi()
#### 347. 前k个高频元素

基本思路
```
// 首先是 unordered_map 统计每个数出现频率
// Topk 计算：当然可以对整个 map 进行排序，但由于是大数问题，可能超时
// 更好的方法:
// TopK 问题用堆来解决
// 利用 priority_queue 实现堆，（小顶堆），超出 k 时，最小的那个元素出队，则最后剩下的是 k个频率最高的元素
```

涉及很多数据结构的使用，归纳如下
```c++
priority_queue: 优先级队列，实际上就是一个堆
堆: 堆是一颗完全二叉树，树中每个结点的值都>=(大顶堆) 或 <=(小顶堆) 其左右孩子的值
priority_queue 的缺省实现是大顶堆

priority_queue 的构造函数
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> 

对应
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

std:less 需要实现 bool operator()(const T& lhs, const T& rhs );
```

代码
```c++
class mycomparison {
public:
    // 为什么 左大于右是小顶堆？ 和 priority_queue的实现有关
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
vector<int> topKFrequent(vector<int>& nums, int k) {
    // 要统计元素出现频率
    unordered_map<int, int> map; // map<nums[i],对应出现的次数>
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]]++;
    }

    // 对频率排序
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

    // 用固定大小为k的小顶堆，扫面所有频率的数值
    for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
        pri_que.push(*it);
        if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
            pri_que.pop();
        }
    }

    // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
    vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = pri_que.top().first;
        pri_que.pop();
    }
    return result;

    }
```
### 二叉树
#### 相关定义
- 满二叉树：只有度数为0和度数为2的节点，且度数为0节点在同一层
- 完全二叉树：只有最下层节点可以没填满，且最下层节点集中在最左边
- 二叉搜索树：左子树小于根结点，右子树大于根结点
- 平衡二叉搜索树：二叉搜索树基础上，左右子树高度差不超过1
#### 顺序存储
- 左孩子：2i+1, 右孩子: 2i+2
#### 遍历
##### 深度优先
- 往深处走，遇到叶子结点再往回
- 前序： 中左右
- 中序： 左中右 
- 后序： 左右中
##### 广度优先
- 一层一层遍历
- 层序遍历
#### 数据结构定义
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x), left(NULL), right(NULL) {}
};
```
#### 递归遍历三部曲 （前序遍历为例）
- 递归函数的参数和返回值
```c++
// 当前节点 和 存储遍历值的 vector
void traverse(TreeNode* cur, vector<int>& vec)
```
- 结束条件
```c++
if (cur == NULL) return;
```
- 单层递归逻辑
```c++
vec.push_back(cur->val); //中
traverse(cur->left, vec); //左
traverse(cur->right, vec); //右
```

#### 三种遍历的迭代方法！
##### 前序遍历(辅助栈)
- 空节点不入栈
```c++
stack<TreeNode* > st;
vector<int> res;
vector<int> preorderTraversal(TreeNode* root) {
    if (root == NULL) return res;
    st.push(root);
    while (!st.empty()) {
        TreeNode* cur = st.top();
        st.pop();
        res.push_back(cur->val);
        if (cur->right != NULL) st.push(cur->right);
        if (cur->left != NULL) st.push(cur->left);
    }
    return res;
}
```
##### 中序遍历
- 中序遍历不能用前序遍历的方法，为啥？
一共存在两种操作
- 处理：将元素放入数组
- 访问：遍历节点
- 前序遍历是中左右，访问顺序和处理顺序一致，所以代码写起来很顺
- 中序是左中右，两个顺序不一致，就麻烦些

```c++
vector<int> inorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> res;
    TreeNode* cur = root;
    
    while (cur != NULL || !st.empty()) {
        if (cur != NULL) {
            st.push(cur);
            cur = cur -> left; // 不断访问左孩子节点
        } else {
            cur = st.top();
            st.pop();
            res.push_back(cur->val); //操作左、中间节点
            cur = cur->right; // 访问右边节点，如果为 NULL，下一次会访问到栈里头的上一个节点（中间节点）
        }
    }
    return res;
}
```
##### 后序遍历（很巧妙，基于前序遍历做的改动）
- 左右中这样的顺序，要模拟实现我是做不来
- 前序: 中左右 --> 中右左 --> 数组反过来就是左右中了
- 所以，执行一遍调换左右的前序遍历，最后将数组反过来即可
```c++
vector<int> postorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> res;
    TreeNode* cur = root;
    if (cur) st.push(cur);
    while (!st.empty()) {
        cur = st.top();
        st.pop();
        res.push_back(cur->val);
        if (cur->left) st.push(cur->left);
        if (cur->right) st.push(cur->right);
    }
    reverse(res.begin(), res.end());
    return res;
    }
```
#### 226. 翻转二叉树
```c++
// 实现一个swap 函数，交换 cur->left, cur->right
// 递归函数
void recur(TreeNode* cur);

// 结束条件
if (cur == NULL) return;

// 递归逻辑
swap(cur);
recur(cur->left);
recur(cur->right);
```
#### 102 层序遍历
- 需要用到一个辅助队列，用到其先进先出的特性
- 同一层的元素归类到vector 的同一维如何实现？读取队列的大小，该大小代表该层的节点数
- 元素出队 --> val加入vector --> 孩子结点入队
#### 106. 从中序与后序遍历序列构造二叉树
- 依然需要递归
- 思路
```
// 中序 左中右 [9, 3, 15, 20, 7]
// 后序 左右中 [9, 15, 7, 20, 3]
// 递归, 参数为中序 后序数组
// 1. 只有一个节点，返回该结点即可
// 2. 找到中间节点 --> 后序数组 最后一个，中序数组按值查找
// 3. 划分中序的左子树，右子树，后序的左子树 右子树 (左闭右开原则)
// 4. 递归构建左子树，右子树
```
- 代码
```c++
TreeNode* recur(vector<int> inorder, vector<int> postorder) {
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);
    if (postorder.size() == 1) return root;
    int rootIndex;
    // 找到中序遍历中的根结点位置
    for (rootIndex = 0; rootIndex < inorder.size(); rootIndex++) {
        if (inorder[rootIndex] == rootValue) break;
    }
    // vector 的构造 可以通过 iterator 完成
    vector<int> inorderLeft(inorder.begin(), inorder.begin() + rootIndex);
    vector<int> inorderRight(inorder.begin() + rootIndex + 1, inorder.begin() + inorder.size());

    // 一个比较巧的地方，后序遍历的左子树部分，长度和中序遍历左子树一致
    vector<int> postorderLeft(postorder.begin(), postorder.begin() + inorderLeft.size());
    vector<int> postorderRight(postorder.begin() + inorderLeft.size(), postorder.begin()+ postorder.size()-1);

    // 这里做一个预处理，数组为空，说明子树为 NULLv
    root -> left = inorderLeft.size() > 0 ? recur(inorderLeft, postorderLeft): NULL;
    root -> right = inorderRight.size() > 0 ? recur(inorderRight, postorderRight): NULL;
    return root;
}
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if (inorder.size() < 1) return NULL;
    return recur(inorder, postorder);
}
```

#### 236. 二叉树的最近公共祖先
思路
```
节点的祖先，先访问左右孩子，再访问根节点，与后序遍历顺序一致
基于后序遍历:
左右孩子 --> 返回
空节点 --> 返回
遍历左右子树，如果都非空，说明根节点为公共祖先，返回根节点
都为 NULL, 说明子树无相关元素，返回 NULL
其中一个子树非空，返回该非空节点（要么是p,q之一，要么是祖先节点)
```

```c++
TreeNode* recur(TreeNode* node, TreeNode* p, TreeNode* q) {
    if (node == p || node == q || node == NULL) {
        return node;
    }

    TreeNode* left = recur(node->left, p, q);
    TreeNode* right = recur(node->right, p, q);
    
    if (left != NULL && right != NULL) return node;
    if (left != NULL) return left;
    if (right != NULL) return right;
    return NULL;
}
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    return recur(root, p, q);
}
```
#### 129. 根节点到叶节点数字之和
- 终止条件: NULL -> 0, 叶子结点: curSum
- 每次递归，返回左子树，右子树递归结果之和 （左子树，右子树各自指向一个 叶子结点或 NULL节点）
```c++
int recur(TreeNode* node, int curSum) {
    if (node == NULL) return 0;
    curSum = curSum*10 + node->val;
    // 叶子结点
    if (node->left == NULL && node->right == NULL) return curSum;
    return recur(node->left, curSum) + recur(node->right, curSum);
}
int sumNumbers(TreeNode* root) {
    return recur(root, 0);
}
```
#### 116. 填充每个节点的下一个右侧节点指针
- 想法：利用队列结构，进行层序遍历
- 每次把一层的所有节点出队，按顺序设置 next
```c++
Node* connect(Node* root) {
    if (root == NULL) return NULL;
    queue<Node*> qu;
    qu.push(root);
    while (!qu.empty()) {
        vector<Node*> nodes;
        while(!qu.empty()) {
            nodes.push_back(qu.front());
            qu.pop();
        }
        for (int i=0; i<nodes.size()-1; i++) {
            nodes[i] -> next = nodes[i+1]; 
            if (nodes[i]->left != NULL) qu.push(nodes[i]->left);
            if (nodes[i]->right != NULL) qu.push(nodes[i]->right);
        }
        if (nodes[nodes.size()-1]->left != NULL) qu.push(nodes[nodes.size()-1]->left);
        if (nodes[nodes.size()-1]->right != NULL) qu.push(nodes[nodes.size()-1]->right);
    }
    return root;
}
```
##### 递归方法
- 关键：前序遍历，利用上一层搭出来的线，搭建本层
### 二叉搜索树
- 看到二叉搜索树，一定要想到他是有序的
- 我们可以通过一个中序遍历，把它转化成一个有序数组
- 所以求最值、差值等问题，都可以等同于在数组上的相关问题

#### 235. 二叉搜索树的公共祖先
236 是基于后序遍历，但235我们可以利用二叉搜索树的性质
公共祖先，其值一定在 [p,q] 这个范围内 --> 闭区间，公共祖先可能是自己
按照这个规则递归即可
```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == NULL) return NULL;
    if ((root->val >= p->val && root->val <= q->val) || (root->val >= q->val && root->val <= p->val)) {
        return root;
    }
    TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
    TreeNode* rightNode = lowestCommonAncestor(root->right, p, q);
    if (leftNode) return leftNode;
    return rightNode;
}
```
#### 234 回文链表
##### 空间复杂度 O(n) 做法
- 遍历链表，生成一个数组，然后在数组里判断是否回文
##### 空间复杂度 O(1) 做法
- 找到链表中点：快慢指针，一个走一步，一个走两步
- 翻转后半部分链表
- 两部分链表一起遍历，元素不相等则不是回文
- 前面的链表 可能比后面链表少一个元素，只比前面链表的所有元素即可
```c++
ListNode* reverseList(ListNode* head) {
    if (head == NULL || head->next == NULL) return head;
    ListNode* prev = head;
    ListNode* cur = head->next;
    ListNode* nextNode;
    do {
        nextNode = cur->next;
        cur->next = prev;
        prev = cur;
        cur = nextNode;       
    } while (nextNode!= NULL);
    return prev;
}
bool isPalindrome(ListNode* head) {
    if (head == NULL) return false;
    if (head->next == NULL) return true;
    ListNode* slow = head->next;
    ListNode* fast = head->next->next;
    ListNode* prev = head;
    while (fast != NULL) {
        fast = fast->next;
        if (fast != NULL) {
            slow = slow->next;
            prev = prev->next;
            fast = fast->next;
        } 
    }
    prev -> next = NULL;
    ListNode* cur1 = head;
    ListNode* cur2 = reverseList(slow);
    while (cur1 != NULL) {
        if (cur1->val != cur2->val) return false;
        cur1 = cur1->next;
        cur2 = cur2->next;
    }
    return true;
}
```
#### 530. 二叉搜索树的绝对差
中序遍历之后，就可以在有序数组上遍历求绝对差
```c++
void midOrder(TreeNode* node, vector<int>& seq) {
    if (node == NULL) return;
    midOrder(node->left, seq);
    seq.push_back(node->val);
    midOrder(node->right, seq);
}

int getMinimumDifference(TreeNode* root) {
    vector<int> seq;
    midOrder(root, seq);
    int minimum = 1e5;
    for (int i=0; i<seq.size()-1; i++) {
        if (seq[i+1] - seq[i] < minimum) minimum = seq[i+1] - seq[i];
    }
    return minimum;
}
```
#### 501. 二叉搜索树中的众数
##### 方法1
针对普通的树，我们可以遍历该树，通过一个map 存放每个元素出现的频率。
最后遍历 map（或者排序, 返回众数
```c++
unordered_map<int, int> map;
void midOrder(TreeNode* cur) {
    if (cur == NULL) return;
    midOrder(cur->left);
    
    map[cur->val] += 1;

    midOrder(cur->right);
}
vector<int> findMode(TreeNode* root) {
    midOrder(root);
    vector<int> res;
    int maxCount = 0;
    // auto 牛逼
    for (auto it = map.begin(); it!=map.end(); it++) {
        if (it->second > maxCount) {
            res.clear();
            res.push_back(it->first);
            maxCount = it->second;
        } else if (it->second == maxCount) {
            res.push_back(it->first);
        }
    }
    return res;
}
```
map 无法排序，但是 vector可以。从 map 到 vector的转换方法
vector<pair<int, int>> vec(map.begin(), map.end());

##### 方法2
利用二叉搜索树，其中序遍历是有序的这一性质，省去map(不使用额外的空间)
- 记录前一个元素 pre, 比较是否和前一个元素相等
- 记录相等的数量 count, 和最大相等频率 maxCount
```c++
TreeNode* pre = NULL;
int count = 0;
int maxCount = 0;
vector<int> res;
void searchBST(TreeNode* cur) {
    if (cur == NULL) return;
    searchBST(cur->left);// 左
    // 中
    if (pre != NULL && cur->val == pre->val) {
        count++;
    } else {
        count = 1;
    }
    pre = cur;
    

    if (count > maxCount) {
        res.clear();
        maxCount = count;
        res.push_back(cur->val);
    } else if (count == maxCount) {
        res.push_back(cur->val);
    }

    searchBST(cur->right);//右

}
vector<int> findMode(TreeNode* root) {
    searchBST(root);
    return res;
}
```
#### 700.二叉搜索树中的搜索
```c++
TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL) return NULL;
    if (root->val == val) return root;
    if (val < root->val) return searchBST(root->left, val);
    return searchBST(root->right, val);
}
```
#### 701. 二叉搜索树中的插入操作
```
并不需要按题目说的，去修改树的结构
按照二叉搜索树的结构去遍历（左小右大），遇到符合条件的空节点就插入即可
具体：
左孩子为空 && val < root->val, 插入左孩子
右孩子为空 && val > root->val, 插入右孩子
其他情况 val < root->val， recur(root->left)
val > root->val, recur(root->right)
```

```c++
void recur(TreeNode* node, int val) {
    if (!node->left && val < node->val) {
        node -> left = new TreeNode(val);
        return;
    } else if (!node->right && val > node->val) {
        node->right = new TreeNode(val);
        return;
    }
    if (val < node->val) recur(node->left, val);
    else recur(node->right, val);
    }
    TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == NULL) return new TreeNode(val);
    recur(root, val);
    return root;
}
```
#### 450. 删除二叉搜索树中的节点
```
一个递归函数完成所有操作
1. 没找到节点 return root
2. 左右孩子都为空: 删除该节点
3. 左孩子为空: 右孩子作为根
4. 右孩子为空：左孩子作为根
5. 左右都不空：左孩子作为根，left -> left 作为左孩子
left -> right 在右孩子的最左孩子处，作为左孩子 （自己画图理解）
```

```c++
TreeNode* deleteNode(TreeNode* root, int key) {
    if (root == NULL) return root;
    if (root -> val == key) {
        if (root -> left == NULL && root -> right == NULL) return NULL;
        if (root -> left == NULL) return root->right;
        if (root -> right == NULL) return root->left;
        TreeNode* start = root -> right;
        while (start -> left != NULL) start = start -> left;
        root -> val = root -> left -> val;
        start -> left = root -> left -> right;
        root -> left = root -> left -> left;
        return root;
    } 
    if (root -> val < key) root -> right = deleteNode(root->right, key);
    else root -> left = deleteNode(root->left, key);
    return root;
    
}
```
#### 669. 修剪二叉搜索树
递归三部曲
```
// 可以通过返回值，直接完成移除节点的操作
TreeNode* trimBST(TreeNode* root, int low, int high)
if (root == NULL) return NULL
// 单层递归逻辑: <low, >high, [low, high]这三种情况分别考虑
```
```c++
TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (root == NULL) return NULL;
    if (root -> val < low) {
        TreeNode* right = trimBST(root->right, low, high);
        return right;
    }
    if (root -> val > high) {
        TreeNode* left = trimBST(root->left, low, high);
        return left;
    }

    root -> left = trimBST(root->left, low, high);
    root->right = trimBST(root->right, low, high);
    return root;
}
```
#### 108. 有序数组转换成二叉搜索树
数组 --> 二叉树，可以回想根据前序 + 中序 得到二叉树
关键在于找到分割点，哪部分是左子树，哪部分是右子树
二叉搜索树非常好分割 （mid 作为根， [start, mid) 左子树， [mid+1, end) 右子树）
至于平衡，由于我们每次都从中点分割，所以自然是平衡的（左右都有元素）
```c++
TreeNode* traversal(vector<int>& nums, int start, int end) {
    if (start == end-1) {
        return new TreeNode(nums[start]);
    }
    if (start >= end - 1) return NULL;
    int mid = (start + end) / 2;
    TreeNode* node = new TreeNode(nums[mid]);
    node -> left = traversal(nums, start, mid);
    node->right = traversal(nums, mid+1, end);
    return node;
}

TreeNode* sortedArrayToBST(vector<int>& nums) {
    return traversal(nums, 0, nums.size());
}
```
#### 538. 二叉搜索树转换成累加树
使每个节点 node 的新值 == 原树中大于或等于 node.val 的值之和
可以想到 二叉搜索树通过中序遍历得到递增序列
如果通过 "右根左“ 的顺序遍历，则得到递减序列
我们记录当前元素总和，则该总合就是 >= 当前元素 的值的总和
```c++
int total = 0;
void recur(TreeNode* root) {
    if (root == NULL) return;
    recur(root->right);
    total += root -> val;
    root -> val = total;
    recur(root -> left);
}
TreeNode* convertBST(TreeNode* root) {
    recur(root);
    return root;
}
```
#### 1382. 将二叉搜索树变平衡
- 直接在树上进行修改很困难，尤其是递归的条件，想不出来
- 思路: 二叉搜索树 --> 有序数组 --> 二叉平衡搜索树
    - 二叉搜索树 --> 有序数组： 中序遍历
    - 有序数组 --> 二叉平衡搜索树：每一次以数组中点作为根，两侧为左右子树， 那么左右子树元素数量相等，自然是平衡的
```c++
vector<int> arr;
void traverse(TreeNode* node) {
    if (node == NULL) return;
    traverse(node->left);
    arr.push_back(node->val);
    traverse(node->right);
    return;
}
TreeNode* construct(int start, int end) {
    if (start > end) return NULL;
    if (start == end) return new TreeNode(arr[start]);
    int mid = (start + end)/2;
    TreeNode* node = new TreeNode(arr[mid]);
    node->left = construct(start, mid-1);
    node->right = construct(mid+1, end);
    return node;
}
TreeNode* balanceBST(TreeNode* root) {
    traverse(root);
    return construct(0, arr.size()-1);
}
```
### 回溯算法
#### 常见问题
- 组合问题
- 切割问题：字符串按照某规则，有几种切割方式
- 子集问题
- 排列问题
- 棋盘问题: N皇后
#### 模板
```c++
void backtracing(参数) {
    if (结束条件) {
        存放结果;
        return;
    }
    for (选择: 本层的所有节点) {
        处理结点；
        backtracing(参数)；
        撤销处理效果
    }
}
```
#### 77.组合
```c++
vector<vector<int>> res;
    vector<int> cur;
    void backtracing(int start, int n, int k) {
        if (cur.size() == k) {
            res.push_back(cur);
            return;
        }
        // 这里剪枝了 (剩余选项 >= k - cur.size())
        for (int i=start; i<=n-k+1+cur.size(); i++) {
            cur.push_back(i);
            backtracing(i+1, n, k);
            cur.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracing(1, n, k);
        return res;
    }
```
#### 131. 分割回文串
- 类比组合问题，只不过组合的是字符串的切割位置
- 思路
```
// void backtracing(string s, int startIndex)
// 结束条件 startIndex >= s.length()
// for 循环, 循环的是截取位置
// for (i=startIndex; i<=s.length();i++)
```
- 代码
```c++
vector<vector<string>> res;
vector<string> cur;
bool isReversable(string s, int start, int end) {
    while (start <= end) {
        if (s[start] != s[end]) return false;
        start++;
        end--;
    }
    return true;
}

void backtracing(string s, int startIndex) {
    if (startIndex == s.length()) {
        res.push_back(cur);
        return;
    }

    for (int i=startIndex; i<s.length(); i++) {
        if (isReversable(s, startIndex, i)) {
            cur.push_back(string(s.begin()+ startIndex, s.begin() + i + 1));
            backtracing(s, i+1);
            cur.pop_back();
        }
    } 
}
vector<vector<string>> partition(string s) {
    backtracing(s, 0);
    
    return res;
}
```

#### 46. 全排列
```c++
vector<vector<int>> res;
vector<int> cur;
void backtracing(vector<int>& nums, vector<bool>& visited) {
    if (cur.size() == nums.size()) {
        res.push_back(cur);
    }
    // 和 组合的不同，并不是只能往后遍历
    // 所有元素都需要遍历，通过 visited 数组辨别是否已经访问过了
    for (int i=0; i<nums.size();i++) {
        if (!visited[i]) {
            visited[i] = true;
            cur.push_back(nums[i]);
            backtracing(nums, visited);
            // 执行结束，撤销结果
            visited[i] = false;
            cur.pop_back();
        }
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    vector<bool> visited(nums.size());
    backtracing(nums, visited);
    return res;
}
```
#### 332. 重新安排行程 
```c++
class Solution {
public:
    // 利用 unordered_map 里头的元素按照字母序排列这一性质，实现题目要求的，字母序较小行程优先
    unordered_map<string, map<string, int>> targets;
    
    bool backtracing(int ticketNum, vector<string>& res) {
        if (res.size() == ticketNum + 1) {
            // 只需要返回一个行程，因此返回 bool 即可
            return true;
        }

        // 注意这个 pair, int 记录到这个地方的航班数
        for (pair<const string, int>& target: targets[res[res.size()-1]]) {
            if (target.second > 0) {
                target.second--;
                res.push_back(target.first);
                if (backtracing(ticketNum, res)) return true;
                target.second++;
                res.pop_back();
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        vector<string> res;

        for (const vector<string>& vec: tickets) {
            targets[vec[0]][vec[1]]++;
        }
        res.push_back("JFK");
        backtracing(tickets.size(), res);
        return res;
    }
};
```

#### 51. N皇后
一些重点

```
convert() 是从 [[0,1], [1,2]] --> [".Q.", "..Q"]
改进
- 不需要存两位， 下标本身就代表行数
- 可以直接弄一个 vector<vector<string>>, 里面每个点要么'Q', 要么'.'  省去转换这一步
- string s(n, '.'): 初始化长度为n, "...." 这样的字符串

valid():
- 检查同一列上有没有皇后
- 检查对角线 (45, 135)
- 行不需要检查，回溯中每次 Index+1
```
```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<int>> cur;

    vector<string> convert(vector<vector<int>> cur, int n) {
        vector<string> res;

        for (int i=0; i<cur.size(); i++) {
            string s(n, '.');
            s[cur[i][1]] = 'Q';
            res.push_back(s);
        }
        return res;
    }

    int abs(int a, int b) {
        if (a > b) return a-b;
        return b-a;
    }

    bool valid(int row, int col) {
        // 检查列
        for (int i=0; i<cur.size(); i++) {
            if (col == cur[i][1]) return false;
        }
        // 检查 45 度 对角线
        for (int i=0; i<cur.size(); i++) {
            if (row-i == col-cur[i][1]) return false;
        }
        // 检查 135 度 对角线
        for (int i=0; i<cur.size(); i++) {
            if (row-i == cur[i][1] - col) return false;
        }

        return true;
    }

    void backtracing(int index, int n) {
        if (index == n) {
            res.push_back(convert(cur, n));
            return;
        }

        for (int i=0; i<n; i++) {
            if (valid(index, i)) {
                cur.push_back({ index, i});
                backtracing(index+1, n);
                cur.pop_back();
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        backtracing(0, n);
        return res;
    }
};
```
#### 52. N皇后2
- 跟51基本类似。多一个全局变量，记录解决方案数量
#### 491.递增子序列
回溯法
```markdown
void backtracing(vector<int> nums, int startIndex)
结束条件 if (startIndex >= nums.size()) return;
同时，如果cur 里头有至少两个元素，就加入 res, **但此时没有结束递归！**

单层操作：需要去重，相同元素不能出现在同一层
每一层定义一个 uset, 存放本层已出现的元素；下一层这个 uset 就重新初始化，不会传下去了。
```
```c++
vector<vector<int>> res;
vector<int> cur;
void backtracing(vector<int> nums, int startIndex) {
    if (cur.size() >= 2) res.push_back(cur);
    if (startIndex >= nums.size()) return;
    // 同一层不能访问相同元素
    unordered_set<int> uset;
    for (int i= startIndex; i<nums.size(); i++) {
        if (uset.find(nums[i]) != uset.end()) continue;
        uset.insert(nums[i]);
        if (startIndex == 0 || nums[i] >= nums[startIndex - 1]) {
            cur.push_back(nums[i]);
            backtracing(nums, i+1);
            cur.pop_back();
        }
    }
}
vector<vector<int>> findSubsequences(vector<int>& nums) {
    backtracing(nums, 0);
    return res;
}
```
#### 93.复原 IP 地址
```c++
vector<string> cur;
vector<string> res;
// 不一定要传子字符串进来。传原字符串 + 起始终止位置即可
bool isValid(string s) {
    if (s.length() == 0) return false;
    if (s[0] == '0') {
        return s.length() == 1? true: false;
    }
    if (s.length() > 3) return false;
    int num = 0;
    for (int i=0;i<s.length();i++) {
        num = num*10 + s[i] - '0';
    }
    return num > 0 && num <= 255; 
}

void backtracing(int startIndex, string s, int part) {
    if (part == 4) {
        if (startIndex == s.length()) {
            // vector<string> 没有 join 方法，只能自己手动拼接
            string a = "";
            for (int i=0;i<cur.size();i++) {
                a += cur[i];
                if (i!=cur.size()-1) a+=".";
            }
            res.push_back(a);
        }
        return;
    }
    for (int i=1; startIndex+i <= s.length() && i<=3; i++) {
        string sub = s.substr(startIndex, i);
        if (!isValid(sub)) continue;
        cur.push_back(sub);
        backtracing(startIndex+i, s, part+1);
        cur.pop_back();
    }
}
vector<string> restoreIpAddresses(string s) {
    backtracing(0, s, 0);
    return res;
}
```
### 贪心算法
#### 局部最优推出全局最优
#### 455. 分发饼干
- 局部最优: s[j] - g[i] 最小（也就是最刚好，浪费的饼干最少)
- s, g 排序
- 如果 g[i] <= s[j], i++. j++, num++
- g[i] > s[j]: s++;
```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i=0, j=0, num=0;
    while (i < g.size() && j < s.size()) {
        if (g[i] <= s[j]) {
            i++;
            j++;
            num++;
        } else {
            j++;
        }
    }
    return num;
}
```

#### 122. 买卖股票的最佳时机2
##### 做法1
- 把利润分解为每两天之间的差价，而不是多天的总利润
- 局部最优? 收集每个正利润 prices[i+1] - prices[i]
- 全局最优: 最大利润

##### 做法2
- prices[fast] > prices[slow] && prices[fast] < prices[fast+1] 则卖出
```c++
int maxProfit(vector<int>& prices) {
    int slow = 0, fast = 1, total=0;
    while (fast < prices.size()) {
        if (prices[slow] > prices[fast]) {
            slow++;
            fast++;
        } else {
            if (fast + 1 < prices.size() && prices[fast] < prices[fast+1]) fast++;
            else {
                total += prices[fast] - prices[slow];
                slow = fast+1;
                fast = fast+2;
            }
        }
    }

    return total;
}
```

#### 55.跳跃游戏
- 局部最优：当前位置的最大覆盖范围
- 全局最优 nums.size()-2 处的最大覆盖范围，是否>= nums.size()-1
```c++
bool canJump(vector<int>& nums) {
    int maxCover = 0, i=0;
    while(i < nums.size() -1 && maxCover>=i) {
        maxCover = max(maxCover, i+nums[i]);
        i++;
    }
    return maxCover >= nums.size()-1;
}
```
#### 45. 跳跃游戏2
动态规划做法
```c++
int jump(vector<int>& nums) {
    vector<int> dp(nums.size());
    for (int i=1; i<dp.size(); i++) {
        for (int j=0; j<i; j++) {
            if (j + nums[j] >= i) {
                dp[i] = dp[i] == 0 ? dp[j] + 1 : min(dp[i], dp[j]+1);
            } 
        }
    }
    return dp[dp.size()-1];
}
```

贪心做法
计算当前能覆盖最大位置，和下一步能覆盖的最大位置
如果 curDistance < nums.size()-1, 那么就需要走一步 count++, curDistance = nextDistance
```c++
int jump(vector<int>& nums) {
    if (nums.size() == 1) return 0;
    int curDistance = 0;
    int nextDistance = 0;
    int count = 0;
    for (int i=0; i<nums.size(); i++) {
        nextDistance = max(nextDistance, i+nums[i]);
        if (i == curDistance) {
            if (curDistance >= nums.size()-1) break;
            count++;
            curDistance = nextDistance;
            if (nextDistance >= nums.size()-1) break;
        }
    }
    return count;
}
```
#### 1005. K 次取反后最大化的数组和
贪心策略
```
// 先把负数变成正数
// 剩下偶数次：一个数变来变去，总和不变
// 剩下奇数次: 选最小的数，变成负的
```

代码
```c++
 int largestSumAfterKNegations(vector<int>& nums, int k) {
    int i=0;
    sort(nums.begin(), nums.end());
    // 负数变为正的
    while (i < nums.size() && nums[i] < 0 && k>0) {
        nums[i] = -nums[i];
        k--;
        i++;
    }
    int total = accu(nums);
    if (k%2 == 0) return total;
    // 找出最小的那个数，变成负数
    int min = 1e5;
    for (int i=0; i<nums.size(); i++) {
        if (nums[i] < min) min = nums[i];
    }
    return total - 2*min;
}
```
#### 134. 加油站

暴力解法: 从每个位置开始模拟，看看能否回到该点。
gas 总和小于 cost, 剪枝
如果起始位置 diff < 0, 可以剪枝

贪心解法:
```
首先确认 diff[] 总和 > 0, 否则一定不能回到终点
记录 curSum
如果 curSum < 0, 说明会遇到油不足的情况，且 sum[i+1, diff.size()] > 0, 则起始位置应该从 i+1 开始， curSum = 0

局部最优: 如果前diff[j]的 curSum < 0, 起始位置至少是j+1
全局最优: 找到一个起始位置
```

代码
```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    vector<int> diff; // <index, value>
    for (int i=0; i<gas.size();i++) {
        diff.push_back(gas[i] - cost[i]);
    }
    int curSum = 0;
    int total = 0;
    int start = 0;

    for (int i=0; i<diff.size(); i++) {
        curSum += diff[i];
        total += diff[i];
        if (curSum < 0) {
            start = i+1;
            curSum = 0;
        }
    }
    if (total < 0) return -1;
    return start;
}
```
#### 135.分发糖果
```
一定要确定左边之后, 再确定右边
两边一起考虑，会顾此失彼

考虑右孩子大于左孩子的情况，从前往后遍历
局部最优: ratings[i] > ratings[i-1] 则 candies[i] = candies[i-1] + 1
全局最优：评分高的右孩子，糖果比左孩子多1

接下来考虑左孩子大于右孩子情况，从后往前遍历

```

```c++
int candy(vector<int>& ratings) {
    vector<int> candies(ratings.size(), 1);
    for (int i=1; i<ratings.size(); i++) {
        if (ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;
    }
    for (int i=ratings.size()-1; i>0; i--) {
        if (ratings[i] < ratings[i-1]) {
            candies[i-1] = max(candies[i] +1, candies[i-1]); 
        }
    }
    return accumulate(candies.begin(), candies.end(), 0);
}
```

#### 860. 柠檬水找零
- 给5元，不用找钱
- 给10元，找5元
- 给20， 10+5 || 5+5+5
- 5元是最有用的。所以优先找10元，其次才是5元
- 模拟整个过程即可，用map 存储目前已有的面额数量

```c++
unordered_map<int, int> map;
for (int i=0; i<bills.size(); i++) {
    if (bills[i] == 5) {
        map[5] += 1;
    } else if (bills[i] == 10) {
        if (map[5] <= 0) return false;
        map[5]--;
        map[10]++;
    } else {
        if (map[10] > 0 && map[5] > 0) {
            map[10]--;
            map[5]--;
        } else if (map[5] >= 3) {
            map[5] = map[5] - 3;
        } else {
            return false;
        }
    } 
}
return true;
```

#### 406. 根据身高重建队列
与135.分发糖果有共同点：存在两个维度时，一定先确定一个维度，再确定另一个维度
本例中，我们首先确定高度，越高的站前面，（高度相等时，ki 小的站前面）
其次确定 k. 我们按照排序后数组的顺序，分别将元素插入新数组的Ki处即可。
听起来很神奇，为啥呢？
前提：一定能生成符合要求的序列，且我们从高到低进行插入
局部最优：针对一个 (h_i, k_i), 插入 下标k_i处时，比他高的元素已经插入好了，所以前面一定有k_i个高于或等于它的；对于原来 k_i处，现在k_i+1处那个元素，前面插入了一个高度更小的，不影响自己
全局最优：每个位置都按这个规则插入

```c++
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    // 首先按照高度排序
    sort(people.begin(), people.end(), cmp);
    // 按照高度顺序，一个个插入k对应的下标
    vector<vector<int>> sorted;
    for (int i=0; i<people.size(); i++) {
        sorted.insert(sorted.begin()+people[i][1], people[i]);
    }
    return sorted;
}
```
#### 56. 合并区间（印象深刻啊）
先把数组排序了
局部最优：每个能合并的地方我们都合并
全局最优：得到不重叠的数组

```c++
vector<vector<int>> merge(vector<vector<int>>& intervals) {
    sort(intervals.begin(), intervals.end(), cmp);
    vector<vector<int>> res;
    for (int i=0; i<intervals.size()-1; i++) {
        if (intervals[i][1] >= intervals[i+1][0]) {
            // 很巧妙的地方，把合并后的区间放到数组下一个位置，那么下一次遍历时，可以对合并后的区间进行进一步合并
            intervals[i+1][0] = intervals[i][0];
            // 合并后区间的最大值，是两个最大值的最大值
            // [1,3][2,4] 和 [1,4][2,3]
            intervals[i+1][1] = max(intervals[i][1], intervals[i+1][1]);
        } else {
            // 如果没有继续合并了，就加入 res
            res.push_back(intervals[i]);
        } 
    }
    // 最后一个元素，无论是否被合并，都需要加入res
    res.push_back(intervals[intervals.size()-1]);
    return res;
}
```
#### 452. 最少数量的箭引爆气球
如果多个区间存在交集，则可以用一根箭射多个气球
--> 发现和合并区间很像，而且不需要记录合并后的区间，记录数量即可
```c++
// 注意一下，写 cmp 函数时，要传引用进去，不然会超时
// static: 与对象无关，无需创建实例即可访问
// 为什么 const &: 引用传递，并且禁止更改变量，效率高；如果值传递，需要创建临时变量，效率低。
static bool cmp(const vector<int>& a, const vector<int>& b) {
    return a[0] < b[0];
}
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(), points.end(), cmp);
        int total = 0;
        for (int i=0; i<points.size()-1; i++) {
            if (points[i][1] >= points[i+1][0]) {
                points[i+1][1] = min(points[i][1], points[i+1][1]);
            } else {
                total++;
            }
        }
        total++;
        return total;
    }
};
```
#### 435. 无重叠区间
首先对数组进行排序
从左向右遍历，遇到重叠区间，则 num++, 舍弃该区间
如何排序？应该根据右边界来排，右边界越小，留下的空间就越大
```c++
int eraseOverlapIntervals(vector<vector<int>>& intervals) {
    int remove_num = 0;
    sort(intervals.begin(), intervals.end(), cmp);
    for (int i=0; i<intervals.size()-1; i++) {
        if (intervals[i][1] > intervals[i+1][0]) {
            remove_num++;
            // 不需要真的删除一个区间（时间复杂度高）
            // 用没删除的区间 覆盖 该区间即可
            intervals[i+1] = intervals[i];
        }
    }
    return remove_num;
}
```
#### 763. 划分字母区间
其实并不是贪心
**遍历过程中，如果找到了所遍历过所有字母的最远边界，就找到了分割点**
1. 遍历，找到所有字母的最远出现位置
2. 再次遍历，记录已遍历过所有字母的最远边界；如果最远边界等于下标，则找到分割点
```c++
vector<int> partitionLabels(string s) {
    vector<int> maxDistance(26);
    for (int i=0; i<s.length(); i++) {
        maxDistance[s[i]-'a'] = max(maxDistance[s[i]-'a'], i);
    }
    int curMaxDis = 0;
    vector<int> res;
    for (int i=0; i<s.length(); i++) {
        curMaxDis = max(curMaxDis, maxDistance[s[i] - 'a']);
        if (curMaxDis == i) {
            res.push_back(i);
        }
    }
    // res 里头存的分割点下标，转换成每个区间长度
    for (int i=res.size()-1; i>0; i--) {
        res[i] = res[i] - res[i-1];
    }
    res[0]++;
    return res;
}
```
#### 738. 单调递增的数字
- 如果 arr[i-1] > arr[i]
    - arr[i-1]--, arr[i] 及之后元素全部变为 9
    - 12867 -- 12799
- 但是如果 arr[i-1]-- 之后， arr[i-2] > arr[i-1] 呢？
- 所以从后往前遍历，设置一个标志位 flag，表示哪个位置需要 --
- 该标志位最终会位于最前面的元素
- flag 之后全部置为9
```c++
vector<int> num2Array(int num) {
    vector<int> arr;
    while (num > 0) {
        arr.push_back(num % 10);
        num = num /10;
    }
    reverse(arr.begin(), arr.end());
    return arr;
}
int arr2int(vector<int> arr) {
    int i=0;
    int num = 0;
    while (arr[i] == 0) i++;
    while(i<arr.size()) {
        num = num * 10 + arr[i];
        i++;
    }
    return num;
}
int monotoneIncreasingDigits(int n) {
    vector<int> arr = num2Array(n);
    int flag = -1;
    for (int i= arr.size()-2; i>=0; i--) {
        if (arr[i] > arr[i+1]) {
            arr[i]--;
            flag = i;
        }
    }
    if (flag != -1) {
        for (int j=flag+1; j<arr.size(); j++) {
            arr[j] = 9;
        }
    }
    
    return arr2int(arr);
}
```
#### 监控二叉树
```
从下往上看，局部最优：叶子结点的父节点安摄像头，使摄像头最少 --> 全局最优
从底向上: 后序遍历
三个状态:
0 未覆盖
1 装摄像头
2 已覆盖
空节点应该是已覆盖

四种情况:
左右都覆盖: 根 = 0
左右至少一个未覆盖: 根 = 1
左右存在摄像头: 根 = 2
头结点没覆盖: +1
```
```c++
int result = 0;
int recur(TreeNode* node) {
    if (node == NULL) return 2;
    int left = recur(node->left);
    int right = recur(node->right);

    if (left == 0 || right == 0) {
        result += 1;
        return 1;
    }
    if (left == 1 || right == 1) {
        return 2;
    }
    return 0;
}
int minCameraCover(TreeNode* root) {
    // 根节点有没覆盖
    if (recur(root) == 0) result++;
    return result;
}
```
#### 1221. 分割平衡字符串
- 简单贪心：从前往后，只要遇到平衡字符串，我就分割；这样得到的总数就是最大的
- 如何判断平衡？辅助栈
```c++
int balancedStringSplit(string s) {
    stack<int> st;
    int count=0;
    if (s.length() == 0) return 0;
    for (int i=0; i<s.length(); i++) {
        if (st.empty()) st.push(s[i]);
        else {
            if (s[i] != st.top()) {
                st.pop();
            } else {
                st.push(s[i]);
            }
        }
        if (st.empty()) count++;
    }
    return count;
}
```
### 动态规划
#### 解题步骤
- 确定 dp 数组 及下标含义
- 递推公式
- dp 数组初始化
- 确定遍历顺序
- 举例推导 dp数组
- dp 数组要打印出来！
#### 斐波那契数列问题为例
- 确定 dp 数组 及下标含义 --> dp[i] --> F(i)
- 递推公式 --> dp[i] = dp[i-1] + dp[i-2]
- dp 数组初始化 --> dp[0] = 0, dp[1] = 1
- 确定遍历顺序 --> 从前到后
- 举例推导 dp数组 --> 0 1 1 2 3 5 8, 打印出来，比较一下！
#### 70. 爬楼梯
- dp[i]: 第i级阶梯到顶层阶梯的方法
- dp[i] = dp[i+1] + dp[i+2]
- dp[n-2] = 2, dp[n-1] = 1
- 从右向左
```c++
int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 两个数组元素就够了！
    int dp[2]; // vector<int> dp(2), 向量同样可以用下标访问
    dp[0] = 1;
    dp[1] = 2;
    for (int i = n-3;i>=0;i--) {
        int sum = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return dp[1];
}
```
#### 746. 使用最小花费爬楼梯
- dp[n]: 登上第 n 级台阶的总花费
- dp[n] = min(dp[n-1] + cost[n-1], dp[n-2] + cost[n-2])
- dp[0] = 0, dp[1] = 0 (起始位置不花钱，登上台阶才花钱)
#### 343. 整数划分
- 动规五部曲
```
// dp[n]: n可拆分得到的最大乘积
// dp[n] = max (j*(n-j), j*dp[n-j]), j 从1开始
// dp[2] = 1
```
- 代码
```c++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[2] = 1;
    for (int i=3; i<=n; i++) {
        dp[i] = -1e5;
        for (int j=1; j<=i-2; j++) {
            // 在遍历过程中需要不断计算最大值
            // 可以通过加入 dp[i] 项，取最大值，避免额外维护一个变量
            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
        }
    }
    return dp[n];
}
```
#### 96. 不同的二叉搜索树
思路
```
dp[n]: 1->n 组成的二叉搜索树数量
dp[4] 为例
以 4 为根， 左子树三个点 dp[3] * 右子树 0个点 dp[0]
以 3 为根 左子树2个点 dp[2] * 右子树 1个点 dp[1]
以 2 为根 左子树1个点 dp[1] * 右子树 2个点 dp[2]
以 1 为根 左子树0个点 dp[0] * 右子树 3个点 dp[3]
dp[n] = sum(dp[j] * dp[n-1-j])
dp[0] = 1
```

#### 62. 不同路径
- 二维动态规划
- 思路
```
dp[i][j]: (0, 0) 出发，到 (i, j) 的路径数
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
**初始化: dp [i][0] = 1 dp[0][j] = 1**
```
- 代码
```c++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    for (int i=0; i<m; i++) {
        dp[i][0] = 1;
    }
    for (int i=0; i<n; i++) {
        dp[0][i] = 1;
    }
    for (int i=1; i<m; i++) {
        for (int j=1; j<n; j++) {
            dp[i][j] = dp[i][j-1] + dp[i-1][j];
        }
    }
    return dp[m-1][n-1];
}
```
#### 198.打家劫舍
动态规划五部曲
```
dp[n] 到了第 n 家时的最高金额
要么偷n, 则 n-1 一定不偷；要么不偷n
dp[n] = max(dp[n-1], dp[n-2] + a[n])

dp[0] = 0
dp[1] = nums[1-1]
```

代码
```c++
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size() + 1);
        dp[0] = 0;
        dp[1] = nums[0];

        for (int i=2; i<dp.size(); i++) {
            dp[i] = max(dp[i-2]+ nums[i-1], dp[i-1]);
        }
        return dp[dp.size()-1];
    }
};
```

#### 213.打家劫舍2
```
主要的区别是 第一家 和 最后一家连在一起，不能同时抢
既然不能同时抢，我们分别考虑 1-> n-1, 2 --> n 这两种情况，取最大值即可

重新定义 dp[n]: 下标为 n 处的最大金额
```

```c++
int rob(vector<int>& nums) {
    if (nums.size() == 1) return nums[0];
    if (nums.size() == 2) return max(nums[0], nums[1]);
    // 考虑首个元素的 dp
    vector<int> dp1(nums.size());
    // 考虑尾元素的 dp
    vector<int> dp2(nums.size());

    // 接下来两部分逻辑一致，可以抽一个函数出去
    dp1[0] = nums[0];
    dp1[1] = max(nums[0], nums[1]);
    for (int i=2; i<nums.size()-1; i++) {
        dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i]);
    }

    dp2[1] = nums[1];
    dp2[2] = max(nums[1], nums[2]);
    for (int i=3; i<nums.size(); i++) {
        dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);
    }

    return max(dp1[nums.size()-2], dp2[nums.size()-1]);
}
```
#### 337.打家劫舍3
##### 方法1 暴力递归
可以通过后序遍历进行递归
对于每个节点，考虑：
1. 抢劫该节点，则不抢孩子节点
2. 不抢该节点，则抢孩子节点
取两者的最大值

```c++
int rob(TreeNode* root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return root->val;

    int val_parent = root->val;
    // 偷父节点, 跳过孩子节点
    if (root->left) val_parent += rob(root->left->left) + rob(root->left->right);
    if (root->right) val_parent += rob(root->right->left) + rob(root->right->right);

    int val_child = rob(root->left) + rob(root->right);
    return max(val_parent, val_child);
}
```
但是这种方法会超时
##### 方法2 有记忆的递归
我们在每次递归下，会计算孙子节点的值；但是在儿子节点递归时，孙子节点作为儿子的儿子，被重复计算了
因此我们可以用一个 map 存储已经计算过的值，避免重复
##### 方法3 树形贪心
- 函数参数和返回值
    - vector<int> robTree(TreeNode* node)
    - 返回长度为2的dp数组， dp[0] 代表不抢当前节点, dp[1] 代表抢当前节点
- 结束条件
    - if (cur == NULL) return vector<int>({0, 0});
- 遍历顺序
    - 后序遍历
- 单层递归逻辑
    - 偷当前节点 val1 = node->val + max(left[0], right[0])
    - 不偷当前节点 val2 = max(left[0], left[1]) + max(right[0], right[1])
    - return {val2, val1}

```c++
vector<int> robTree(TreeNode* node) {
    if (node == NULL) return vector<int>({0, 0});
    vector<int> left, right;
    left = robTree(node->left);
    right = robTree(node->right);
    // 不抢本节点
    int val1 = max(left[0], left[1]) + max(right[0], right[1]);
    // 抢本节点
    int val2 = node->val + left[0] + right[0];
    return vector<int>({val1, val2});
}
int rob(TreeNode* root) {
    vector<int> res = robTree(root);
    return max(res[0], res[1]);
}
```
#### 121. 买卖股票的最佳时机
- 只买卖股票一次
##### 方法1 贪心
最左价格最低处买入，最右价格最高处卖出
遍历数组，每新增一个元素，更新最低价格 low
记录差价 res, 每新增一个元素，同时比较该元素 - low 和 res的大小
(其实我感觉没体现出是贪心吧)

```c++
int maxProfit(vector<int>& prices) {    
    int low = 1e5;
    int res = 0;
    for (int i=0; i<prices.size(); i++) {
        low = min(low, prices[i]);
        res = max(res, prices[i]-low);
    }
    return res;
}
```
##### 方法2 动态规划
- 递推过程中，同样记得维护最小值 low
- dp[n]: 下标为 n处最大利润
- dp[0] = 0
- dp[n] = max(dp[n-1], nums[n] - min), 同时维护 min
```c++
int maxProfit(vector<int>& prices) {    
    int low = prices[0];
    vector<int> dp(prices.size());
    dp[0] = 0;
    for (int i=1; i<dp.size(); i++) {
        low = min(low, prices[i]);
        dp[i] = max(dp[i-1], prices[i]-low);
    }
    return dp[dp.size()-1];
}
```
#### 123. 买卖股票的最佳时机3
- 主要限制在于只能交易两次
- 所以不再是一维数组能够表示的 （买或不买，抢或不抢）
```
五种状态: 0        1        2         3         4
      没交易过   第一次买入 第一次卖出  第二次买入  第二次卖出
dp[i][0] = dp[i-1][0]
// 第一次买入股票 / 已经第一次买入了， 跟随之前的状态
dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])
// 第一次卖出股票 / 已经第一次卖出了，跟随状态
dp[i][2] = max(dp[i-1][1] + prices[i], dp[i-1][2])
```

```c++
int maxProfit(vector<int>& prices) {
    vector<vector<int>> dp(
        prices.size(), 
        vector<int>(5)
    );
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    dp[0][3] = -prices[0];
    dp[0][4] = 0;

    for (int i=1; i<dp.size(); i++) {
        dp[i][0] = dp[i-1][0];
        dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]);
        dp[i][2] = max(dp[i-1][1] + prices[i], dp[i-1][2]);
        dp[i][3] = max(dp[i-1][2] - prices[i], dp[i-1][3]);
        dp[i][4] = max(dp[i-1][3] + prices[i], dp[i-1][4]);
    }

    int maxV = -1e5;
    for (int i=0; i<5; i++) {
        maxV = max(maxV, dp[dp.size()-1][i]);
    }
    return maxV;
}
```
#### 188. 买卖股票的最佳时机4
- 和123基本类似，只不过状态的数量是动态的 (2K+1)
- 但状态依然可以根据奇偶，划分为买入(-prices[i]), 卖出(+prices[i])
```c++
int maxProfit(int k, vector<int>& prices) {
    if (prices.size() == 0) return 0;
    vector<vector<int>> dp(prices.size(), vector<int>(2*k+1));
    dp[0][0] = 0;
    for (int j=1; j<2*k+1; j++) {
        if (j%2 == 1) dp[0][j] = -prices[0];
    }
    for (int i=1; i<prices.size(); i++) {
        dp[i][0] = 0;
        for (int j=1; j<2*k+1; j++) {
            if (j%2 == 1) {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i]);
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i]);
            }
        }
    }
    int maxV = -1e5;
    for (int j=0; j<2*k+1; j++) {
        maxV = max(maxV, dp[dp.size()-1][j]);
    }
    return maxV;
}
```
#### 309. 最佳股票买卖时机含冷冻期
```
三种状态:
0              1          2
无操作         买入       卖出，进入冷冻期
0           -prices[0]    0

递推公式：
// 可能是结束冷冻期，进入无操作状态
dp[i][0] = max(dp[i-1][0], dp[i-1][2]); 
// 本轮买入，或已经买入
dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]);
// 本轮卖出
dp[i][2] = dp[i-1][1] + prices[i];
```

```c++
int maxProfit(vector<int>& prices) {
    if (prices.size() == 0) return 0;
    vector<vector<int>> dp(prices.size(), vector<int>(3));
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    for (int i=1; i<prices.size();i++) {
        dp[i][0] = max(dp[i-1][0], dp[i-1][2]);
        dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1]);
        dp[i][2] = dp[i-1][1] + prices[i];
    }
    return max({ dp[dp.size()-1][0], dp[dp.size()-1][1], dp[dp.size()-1][2]});
}
```
#### 714. 买卖股票含手续费
```
三个状态
0       1    2
无操作   买入  卖出

初始状态:
dp[0][0] = 0, dp[0][1] = -prices[0]-fee, dp[0][2] = -INF
由于不可能出现 dp[0][2]这个状态，所以给他赋一个负无穷，保证不参与下面的递推
```
```c++
int INF = 1e4;
int maxProfit(vector<int>& prices, int fee) {
    vector<vector<int>> dp(prices.size(), vector<int>(3));
    dp[0][0] = 0;
    dp[0][1] = -prices[0] - fee;
    dp[0][2] = -INF;
    for (int i=1; i<prices.size(); i++) {
        dp[i][0] = max(dp[i-1][0], dp[i-1][2]);
        dp[i][1] = max({dp[i-1][0]-prices[i]-fee, dp[i-1][1], dp[i-1][2]-prices[i]-fee});
        dp[i][2] = dp[i-1][1] + prices[i];
    }
    return max({ dp[prices.size()-1][0], dp[prices.size()-1][1], dp[prices.size()-1][2]});
}
```
### 动态规划--01背包问题
问题定义
```
总重为 W 的背包
N件物品， weight[i], value[i], 每件物品只能用一次
背包里头的物品最大价值？
```

动规五部曲(二维数组版)

```
dp[i][j]: 在[0-i]物品中进行选择，装入后背包的容量为j, 此时背包的最大价值

dp[i][j] = max(
            dp[i-1][j]  不放入物品 i
            dp[i-1][j-weights[i]] + values[i] 放入物品i, 注意检查 j-weights[i] 的越界情况
            )

初始化：
    dp[i][0] = 0
    dp[0][j] = j >= weights[0] ? value[0] : 0

遍历顺序：每个值 依赖其左上角的值
所以先遍历物品，然后背包容量           
```

如果我们把 i-1 那一层 拷贝到 i 层，表达式可以简化为
dp[i][j] = max(dp[i][j], dp[i][j-weight[i]] + value[i])

进一步简化为一维数组
dp[j] = max(dp[j-weight[i]] + value[i])

动规五部曲(滚动一维数组版)

```
dp[j]: 容量为 j 的背包的最大价值
dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
由于推导过程中取较大的数，价值非负情况下，所有 dp[i] 初始为0即可

遍历顺序:
for (int i=0; i<weight.size(); i++) {// 遍历一个个物品
    for (int j=bagWeight; j>=weight[i]; j--) { // 遍历背包容量

    }
}

为什么倒序遍历背包容量？因为 dp 和前者有关，正序遍历可能导致物品被重复加入
```

#### 416. 分割等和子集
如何理解为01背包问题？

```
目标: 找出一个和为 sum/2 的子集
背包容量为 sum/2
每个物品 weights[i] = values[i] = nums[i]
背包可以正好装满，则找到了子集
```

代码
```c++
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums);
    if (sum % 2 == 1) return false; // 总和是奇数，肯定找不到子集
    int total = sum / 2; // 背包容量
    vector<vector<int>> dp(nums.size(), vector<int>(total+1));

    for (int i=0; i< nums.size(); i++) {
        dp[i][0] = 0;
    }
    for (int i=0; i<= total; i++) {
        dp[0][i] = nums[0] > i ? 0: nums[0]; // 要检查背包容量 够不够装第一个数
    }

    for (int i=1; i<nums.size(); i++) {
        for (int j=1; j<=total;j++) {
            dp[i][j] = dp[i-1][j];
            // 只有背包容量 能够装下 nums[i] 时，才在两项中取最大值
            if (j - nums[i] >= 0) {
                dp[i][j] = max(
                    dp[i][j],
                    dp[i-1][j-nums[i]] + nums[i]
                );
            }
        }
    }

    return dp[nums.size()-1][total] == total; 
}
```

#### 1049. 最后一块石头
- 和等和子集类似，研究能否划分石头，使其总量和为 sum/2
- 仍然是背包问题
    - 总量 sum/2
    - weight = value
    - 放入或者不放入
- 动规五部曲
    - dp[j]: 容量为j 背包最大价值
    - ...
- 最后返回 dp[sum/2] 和剩余部分的差值
```c++
int accu(vector<int> stones) {
    int total = 0;
    for (int i=0; i<stones.size(); i++) {
        total += stones[i];
    }
    return total;
}
int lastStoneWeightII(vector<int>& stones) {
    int acc = accu(stones);
    vector<int> dp(acc/2+1);

    for (int i=0; i<=acc/2; i++) {
        dp[i] = 0;
    }

    for (int i=0; i<stones.size(); i++) {
        for (int j=acc/2; j>=0; j--) {
            if (j-stones[i] >= 0)  dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]);
        }
    }

    if (dp[acc/2] > acc - dp[acc/2]) {
        return 2 * dp[acc/2] - acc;
    } else {
        return acc - 2 * dp[acc/2];
    }
}
```

#### 494. 目标和
动规五部曲

```
背包的目标容量: (sum + target / 2);
两个集合 a,b a+b = sum, a-b = target
dp[i]: 使背包容量为 i 的方法
dp[i] += dp[i-nums[i]]: i - nums[i] +nums[i] = i; 所以可以累加上后者的方法数
dp[0] = 1, 其他为0 
```

代码
```c++
int accu(vector<int> nums) {
    int acc = 0;
    for (int i=0; i<nums.size(); i++) {
        acc += nums[i];
    }
    return acc;
}
int findTargetSumWays(vector<int>& nums, int target) {
    int acc = accu(nums);
    if ((acc + target) % 2 == 1) return 0; // 目标非整数，是无法实现的
    int goal = (acc + target) / 2;
    if (goal < 0) goal = -goal; // 负的目标可以取对应正值；等于我们将最后得到的集合加上 "-" 好号
    vector<int> dp(goal+1);

    dp[0] = 1;

    for (int i=0; i<nums.size(); i++) { // 先遍历物品
        for (int j=goal; j>=nums[i]; j--) { // 背包容量倒序遍历
            dp[j] += dp[j-nums[i]];
        }
    }

    return dp[goal];
}
```
#### 474. 一和零
动规五部曲
```
dp[x][y]: 最多有x 个0， y个1时，最大子集的大小
dp[x][y] = max(
    dp[x][y],
    dp[x-count[i][0]][y-count[i][1]]
)
dp[0][0] = 0
```

先计算得到每个字符串里头的 0 和 1的数量，存到一个映射表中
```c++
vector<vector<int>> countNum(vector<string> strs) {
    vector<vector<int>> count;
    for (int j=0; j<strs.size(); j++) {
        string str = strs[j];
        count.push_back(vector<int> ({0, 0}));
        // count[i][0]: strs[i] 中 0 的数量
        for (int i=0; i<str.length();i++) {
            if (str.at(i) == '0') count[j][0]++;
            else count[j][1]++;
        }
    }

    return count;
}
```

执行动态规划
```c++
int findMaxForm(vector<string>& strs, int m, int n) {
    vector<vector<int>> count;
    count = countNum(strs);

    vector<vector<int>> dp(m+1, vector<int>(n+1));
    dp[0][0] = 0;

    // 三层循环，内部的 dp 是二维数组v
    for (int i=0; i<strs.size(); i++) {
        for (int j=m; j>=count[i][0]; j--) {
            for (int k=n; k>=count[i][1]; k--) {
                dp[j][k] = max(dp[j][k], dp[j-count[i][0]][k-count[i][1]] + 1);
            }
        }
    }

    return dp[m][n];
}
```
### 动态规划--完全背包问题
N 件物品 最多承重为 W 的背包；
每件物品 weight[i] value[i];
**每件物品可以放入背包无数次**
求背包内物品的最大价值
#### 和01背包的区别 (自己找一个简单的例子，就很容易看出)
01 背包
遍历背包容量时，从大到小; 这样保证所有物品只装入一次
```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

完全背包
遍历背包容量时，从小到大; 每个物品可以装入多次
```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

#### 518. 零钱兑换 II
这一题求的是组合数，如果求排列数则有不同

动规五部曲
```
dp[n]: 容量为n的组合数
dp[n] += dp[n-coins[i]]
dp[0] = 0
```

```c++
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount+1);
    dp[0] = 1;
    sort(coins.begin(), coins.end());
    // 遍历顺序有讲究；先遍历硬币，则代表组合 
    // 假设 coins = [1, 2], 则dp[3] 只包含 {1,2}, 不包含 {2, 1}
    // 如果我们先遍历背包，则求的是排列数
    for (int i=0; i<coins.size(); i++) {
        for (int j=coins[i]; j<=amount; j++) {
            dp[j] += dp[j-coins[i]];
        }
    }
    return dp[amount];
}
```
#### 377. 组合总和4
- 说是组合 实际上是排列
- 遍历顺序：
    - 求组合：外层物品，内层背包
    - 求排列：外层背包，内层物品 （则每个物品放入的顺序可以不同）
```c++
int combinationSum4(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    if (nums.size() == 0 || nums[0] > target) return 0;

    vector<int> dp(target+1);
    dp[0] = 1;
    for (int j=1; j<=target; j++) {
        for (int i=0; i<nums.size() && nums[i] <= j; i++) {
            if (dp[j] < INT_MAX - dp[j - nums[i]]) dp[j] += dp[j-nums[i]];
        }
    }
    return dp[target];
}
```
#### 139. 单词划分
- 完全背包问题
- 背包: s
- 物品：单词，可以取多次

动态规划
```
dp[n]: true 前n个字符构成的子串可以被拆分，false 不可被拆分
dp[i] = dp[j] == true && 子串(i, j) == wordDict[k]
dp[0] = true
遍历顺序无所谓
```

代码
```c++
bool wordBreak(string s, vector<string>& wordDict) {
    vector<bool> dp(s.length() + 1);
    sort(wordDict.begin(), wordDict.end()); // 从短字符串到长字符串排序
    dp[0] = true;
    for (int i=1; i<dp.size(); i++) {
        for (int j=0; j<wordDict.size(); j++) {
            if (wordDict[j].length() > i || !dp[i - wordDict[j].length()]) continue;
            string sub = s.substr(i-wordDict[j].length(), wordDict[j].length());
            if (sub ==  wordDict[j]) {
                dp[i] = true;
            }
        }
    }

    return dp[dp.size()-1];
}
```
### 子序列问题
#### 300. 最长递增子序列
```
dp[n]: 下标 n的最长子序列长度
dp[n] = 遍历所有 dp[j], j<n; 如果 nums[n] > nums[j], 选一个 dp[j]+1的最大值
```
```c++
int lengthOfLIS(vector<int>& nums) {
    vector<int> dp(nums.size());
    dp[0] = 1;
    int maxV = dp[0];
    for (int i=1; i<dp.size(); i++) {
        // 初始状态为1， 只含自己的话
        dp[i] = 1;
        for (int j=0; j<i;j++) {
            if (nums[i] > nums[j]) {
                // 这个 max 操作，实际上是比较了所有 dp[j]+1 取最大值
                dp[i] = max(dp[i], dp[j]+1);
            }
        }
        maxV = max(dp[i], maxV);
    }
    return maxV;
}
```
#### 674. 最长连续递增子序列
- 不要思维定式了！这个问题直接遍历一遍即可解决
- 遍历中维护几个量
    - 当前序列长度 curLen
    - 最长序列 maxLen
    - 当前序列最大值 就是 nums[i-1]
```c++
int findLengthOfLCIS(vector<int>& nums) {
    int curLen = 1;
    int maxLen = 1;
    for (int i=1; i<nums.size(); i++) {
        if (nums[i] > nums[i-1]) {
            curLen++;
            maxLen = max(curLen, maxLen);
        } else {
            curLen = 1;
            maxLen = max(curLen, maxLen);
        }
    }
    return maxLen;
}
```
#### 5. 最长回文子串
#### 718. 最长重复子数组
- 还是一个连续子序列问题
- 因为存在两个数组，所以dp 应该是个二维数组
```
dp[i][j]: 以 A 数组下标 i-1, B 数组下标 j-1 处, 结尾的子数组的最大长度
为什么下标 i-1? 便于定义初始状态
if (A[i-1] == B[j-1]) dp[i][j] = dp[i-1][j-1] + 1 else 0
dp[*][0] dp[0][*] = 0
```
```c++
int findLength(vector<int>& nums1, vector<int>& nums2) {
    int n = nums1.size();
    int m = nums2.size();
    vector<vector<int>> dp(n+1, vector<int>(m+1));
    int result = 0;
    for (int i=1; i<n+1; i++) {
        for (int j=1; j<m+1; j++) {
            if (nums1[i-1] == nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                result = max(dp[i][j], result);
            } 
        }
    }
    return result;
}
```
#### 1143. 最长公共子序列
- 和 718 的区别：这个子序列不要求是连续的了
- 动规上的区别
    - 718 中，如果 A[i-1] != B[j-1], 则 dp[i][j] = 0
        - 即使 A[i] = B[j], 但也构不成“连续”子数组，所以 dp[i+1][j+1] = 1 = 0+1
    - 1143中， 如果 A[i-1] != B[j-1]， dp[i][j] 应该在 {dp[i][j-1], dp[i-1][j]} 中取最大值
        - 因为不要求连续，所以一旦 A[i-1] == B[j-1]， dp[i][j] 就在之前的最大序列基础上 + 1
```c++
int longestCommonSubsequence(string text1, string text2) {
    int n = text1.length();
    int m = text2.length();
    vector<vector<int>> dp(n+1, vector<int>(m+1));
    int result = 0;
    for (int i=1; i<n+1; i++) {
        for (int j=1; j<m+1; j++) {
            if (text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                result = max(dp[i][j], result);
            } else {
                dp[i][j] = max({dp[i-1][j-1], dp[i-1][j], dp[i][j-1]});
            }
        }
    }
    return result;
}
``` 
#### 1035. 不相交的线
- dp[i][j]: 下标 i-1, j-1 处线的数量
- dp[i][j]: num1[i-1] == num2[j-1] ? dp[i-1][j-1] +1
    - i,j 都位于最右边，不会和其他边交叉
- num1[i-1] != num2[j-1]: dp[i-1][j-1], dp[i][j-1], dp[i-1][j]的最大值
```c++
int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
    int m = nums1.size();
    int n = nums2.size();
    vector<vector<int>> dp(m+1, vector<int> (n+1));
    for (int i=1; i<=m; i++) {
        for (int j=1; j<=n; j++) {
            if (nums1[i-1] == nums2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max({dp[i-1][j], dp[i][j-1]});
            }
        }
    }
    return dp[m][n];
}
```
- 其实这也是个最长公共子序列问题，和1143一模一样
#### 53.最大子序和
- dp[i]: 下标 i-1 处的最大子序和
- dp[i] = max(dp[i-1] + nums[i-1], nums[i-1])
    - dp[i-1] < 0, 新的子序列就从 i 开始
- 要有一个 maxV, 最大值不一定出现在最后 [-1, 4, -2, 1]
```c++
int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size()+1);
    int maxV = nums[0];
    for (int i=1; i<=nums.size(); i++) {
        dp[i] = max(dp[i-1] + nums[i-1], nums[i-1]);
        maxV = max(maxV, dp[i]);
    }
    return maxV;
}
```
#### 392. 判断子序列
```
dp[i][j], s[i-1], t[j-1] 处，s 是否为 t 的子序列
s[i-1] == t[j-1]:
    dp[i][j] = dp[i-1][j-1]
s[i-1] != t[j-1]:
    dp[i][j] = dp[i][j-1], t更短的时候，是否为子序列，继承这一结果

初始化 dp[0][*] = true

```
```c++
bool isSubsequence(string s, string t) {
    int m = s.length();
    int n = t.length();
    vector<vector<bool>> dp(m+1, vector<bool>(n+1));
    for (int i=0; i<=n; i++) {
        dp[0][i] = true;
    }
    for (int i=1; i<=m; i++){
        for (int j=1; j<=n; j++) {
            if (s[i-1] == t[j-1] && dp[i-1][j-1]) dp[i][j] = true;
            if (dp[i][j-1]) dp[i][j] = true;
        }
    }
    return dp[m][n];
}
```
### 115. 不同的子序列
```
dp[i][j]: 到下标 i-1 处的S, 等于下标j-1结尾 t 的子序列个数
递推：
    s[i-1] == t[j-1] ? 可以用 s[i-1] 来匹配 --> dp[i-1][j-1],
    也可以不用 s[i-1] 匹配（比如之前已有相同字母出现）dp[i-1][j]

    s[i-1] != t[j-1] --> dp[i-1][j]
初值:
    dp[0][1-m] = 0, s 为空串，匹配不了t
    dp[i][0] = 1, t为空串，s中总存在空串与之匹配
```
```c++
int numDistinct(string s, string t) {
    int n = s.length();
    int m = t.length();
    vector<vector<unsigned long long>> dp(n+1, vector<unsigned long long>(m+1));
    for (int i=0;i<=n; i++) {
        dp[i][0] = 1;
    }
    for (int i=1; i<=n;i++) {
        for (int j=1; j<=m; j++) {
            if (s[i-1] == t[j-1]) {
                dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
            } else {
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][m];
}
```
## 图论
### 并查集
两个操作:
- 查询 a,b 是否在同一组
- 将元素 a,b 合并为一组

数据结构: 每一组表示为树结构
- 是否在同一组 --> 检查根结点是否一致
- 合并为一组: 修改根结点到一致

代码
```c++
vector<int> parent;

void init(int n) {
  for (int i=0; i<n; i++) {
    parent.push_back(i); // 初始每个节点的父元素指向自己
  }
}

int find(int x) {
  if (x == parent[x]) return x;
  return find(parent[x]); // 沿着树往上找
}

void union(int x, int y) {
  x = find(x);
  y = find(y); // 分别找到根结点
  if (x == y) return;
  parent[y] = x;
}

bool same(int x, int y) {
  return find(x) == find(y);
}
```
#### 200. 岛屿数量

DFS 做法 --将该题理解为找 联通组件的数量

代码
```c++
 int count = 0;
int m, n;
void dfs(vector<vector<char>>& grid, int count, int row, int col) {
    if (row >= m || col >= n || row < 0 || col < 0 || grid[row][col] != '1') return;
    grid[row][col] = '2'; // 设置一个已访问过的标志
    // 上下左右 四个方向进行 DFS 搜索
    dfs(grid, count, row+1, col);
    dfs(grid, count, row, col+1);
    dfs(grid, count, row-1, col);
    dfs(grid, count, row, col-1);
}
int numIslands(vector<vector<char>>& grid) {
    m = grid.size();
    n = grid[0].size();
    
    for (int i=0; i<m; i++) {
        for (int j=0; j<n; j++) {
            // 未访问过的 "1"
            if (grid[i][j] == '1') {
                dfs(grid, count, i, j);
                count++;
            } 
        }
    }
    return count;
}
```

并查集做法
整体思想：遇到相邻的 "1" 结点，就合并集合
最后集合的数量（连通组件的数量）就是岛屿数量
集合数最初为节点总数，每次合并集合，则 count--

```c++
class UnionFind {
private:
    int count = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(vector<vector<char>> grid) {
        int m = grid.size();
        int n = grid[0].size();

        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (grid[i][j] == '0') parent.push_back(-1);
                else {
                  parent.push_back(i* n + j); // 用一个一维数组来存储，实质上是一样的
                  count++;
                }
                rank.push_back(0);
            }
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return; // 已经联合的节点，不需要 count--

        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        
        count--; // 联合之后，连通分量减少
    }

    int getCount() {
        return count;
    }
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        UnionFind UF = UnionFind(grid);
       
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                // 未访问过的 "1"
                if (grid[i][j] == '1') {
                    if (j+1 < n && grid[i][j+1] == '1') UF.unite(i*n+j, i*n+j+1);
                    if (j-1 >= 0 && grid[i][j-1] == '1') UF.unite(i*n+j, i*n+j-1);
                    if (i+1 < m && grid[i+1][j] == '1') UF.unite(i*n+j, (i+1)*n+j);
                    if (i-1 >= 0 && grid[i-1][j] == '1') UF.unite(i*n+j, (i-1)*n+j);
                    grid[i][j] == '0'; // 避免重复访问
                } 
            }
        }
        return UF.getCount();
    }
};
```

##### new UnionFind 和 UnionFind 的区别
- new: Allocates memory for an object or array of objects
    - 返回一个指针
    - char* pCharArray = new char[CName::sizeOfBuffer];
- UnionFind: 调用构造函数，返回相应的对象
    - UnionFind UF(grid); // 括号里是构造函数的参数v

#### 684 冗余连接
希望找到一棵树中多余的那条边
**如果有多个答案，返回最后出现的边**
树中多余的边 -- 这两个点已经在同一个树上了
UnionFind: 不断构造树，合并树，直到发现 same(x,y)
```c++
class UnionFind {
private:
    // 不能直接 vector<int> parent(1001);
    vector<int> parent = vector<int> (1001);
    vector<int> rank = vector<int> (1001);
    
public:
    UnionFind() {
        for (int i=0; i<parent.size(); i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    void myUnion(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (rank[x] < rank[y]) {
            // 较矮的树，作为较高的树的子树
            parent[x] = y;
        } else if (rank[y] < rank[x]) {
            parent[y] = x;
        } else {
            // 例如，原本x,y高度为3， 以x作为y的根，则x高度变为4
            parent[y] = x;
            rank[x]++;
        }
    }
};
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        // 直接调用构造函数，返回一个对象
        UnionFind UF = UnionFind();
        for (int i=0; i<edges.size(); i++) {
            int first = edges[i][0];
            int second = edges[i][1];
            if (UF.same(first, second)) {
                return vector<int> ({first, second});
            } else {
                UF.myUnion(first, second);
            }
        }
        return edges[edges.size()-1];
    }
};
```

### 最小生成树
- 无向图中的一个子图
- tree (连通、无环) spanning (include all vertices)
- 找到这样的树中，权值最小的那个
- 应用: 修一条经过所有村庄的路，保证修路的花费最少

#### Kruscal 算法
https://blog.csdn.net/luomingjun12315/article/details/47700237
思路
```
1. 先将所有边排序（权值小的优先）
2. 按权值分别选择边，并查集中合并两个顶点所在集合；如果顶点已经在同一集合，则不选择该边
3. 直到所有节点都被访问过了 (MST.size() == V())
```

##### 1135
```c++
class UnionFind {
private:
    int count = 0;
    int fee = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(int n) {
        count = n;
        for (int i=0; i<=n; i++) {
            parent.push_back(i);
            rank.push_back(0);
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    int getCount() {
        return count;
    }

    int getFee() {
        return fee;
    }

    void unite(int x, int y, int cost) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        count--;
        // 费用也放在并查集里计算
        // 如果两个点已经在同一个集合中，则不应该加上该费用（不选择该边）
        fee += cost; 
    }
    
};
bool compare(vector<int> a, vector<int> b) {
        return a[2] < b[2];
}
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        UnionFind UF(n);

        sort(connections.begin(), connections.end(), compare);

        for (int i=0; i<connections.size(); i++) {
            UF.unite(connections[i][0], connections[i][1], connections[i][2]);
            if (UF.getCount() == 1) return UF.getFee();
        }

        return -1; // 没有找到最小生成树

    }
};
```

#### Prim 算法

选择一个点，放入点集 V 中
选择 V -> 非V 的一个权值最小的边，将新的点加入点集 V
直到 V.size() == 点总数

数据结构:
- visited
- minDist[i]: 从集合 V 到结点i的最小距离

先给出图的定义
```c++
struct Vex {
    int v, weight; // 所连接的节点 和权重
}

vector<Vex> graph[V]; // 每个节点，通过一个 vector 存储邻接结点
```

一次 Prim
```c++
// 将 s 加入 V 中
int prim(int s, int n) {
    int newNode, tmpMin, total=0;
    visited[s] = true;

    // 初始化各点到集合 V 的距离
    for (int j=0; j<graph[s].size(); j++) {
        minDist[graph[s][j].v] = graph[s][j].w;
    }

    // 进行 n-1次相关操作
    for (int i=0; i<n-1; i++) {
        // 找到距离最小的那个点
        tmpMin = INF;
        for (int j=0; j<n; j++) {
            if (minDist[j] < tmpMin) {
                tmpMin = minDist[j];
                newNode = j;
            }
        }
        // visited, minDist 更新
        visited[newNode] = true;
        total += tmpMin;

        for (int j=0; j<graph[newNode].size(); j++) {
            if (!visited[graph[newNode][j].v]) {
                minDist[graph[newNode][j].v] = min(graph[s][j].w, minDist[graph[newNode][j].v]);
            }
            
        }
    }
    return total;
}
```

```c++
bool visited[V];
int minDist[v];
// 先把0号结点加入集合
visited[0] = true;
minDist[0] = -1;
for (int i=1; i<V; i++) {
    visited[i] = false;
    if (graph[0][i])
}
```
### 深度优先算法(DFS)
基本模板
```c++
void dfs (int i, adj, visited) {
    if (结束条件) ... return;
    visited[i] = true
    for (int w: adj[i]) {
        dfs(w, adj, visited);
    }
    visited[i] = false
}
```
相关概念
- 得到一个新节点时，立即对新节点进行遍历
- DFS 遍历时，能到达的节点都是从初始节点可达的。所以常用于求解 **可达性问题**
#### 207. 课程表
时间复杂度还是不够好，没有通过复杂用例
- 基本思路: 通过 DFS 查找是否存在回路，有回路则不能完成所有课程学习
- mark[i] == 1: 由自己启动的 DFS，说明存在回路
- mark[i] == -1：其他节点发起的DFS, 只说明到达i 有多中路径，不代表回路v
```c++
bool dfs(int i, vector<vector<int>> adj, vector<int>& mark) {
    // 1 代表由 i 发起的dfs, 说明存在环
    if (mark[i] == 1) return false;
    // -1 代表其他点发起的 dfs 已经访问过了
    if (mark[i] == -1) return true;
    
    mark[i] = 1;
    for (int w: adj[i]) {
        if(!dfs(w, adj, mark)) return false;
    }

    mark[i] = -1;
    return true;
}
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> adj(numCourses, vector<int>());
    vector<int> mark(numCourses);
    for (vector<int> w: prerequisites) {
        adj[w[1]].push_back(w[0]);
    }

    for (int i=0; i<numCourses; i++) {
        if(!dfs(i, adj, mark)) return false;
        // mark.clear();
    }
    return true;
}
```
#### 695. 岛屿的最大面积
- 每次递归，对四个方向查找 值为1 && 未访问过
- 注意：visited 置为 true 后，不需要再置为 false; 
    - 同一个岛屿内部，点不能重复计算
    - 不同岛屿则不会相通， visited 的值无所谓
```c++
int dfs(int row, int col, vector<vector<bool>>& visited, vector<vector<int>> grid, int len, int width) {
    int total = 0;
    // 检查一下上下左右四个方向
    if (row-1>=0 && !visited[row-1][col] && grid[row-1][col] == 1) {
        visited[row-1][col] = true;
        total += dfs(row-1, col, visited, grid, len, width);
    }
    if (row+1<len && !visited[row+1][col] && grid[row+1][col] == 1) {
        visited[row+1][col] = true;
        total += dfs(row+1, col, visited, grid, len, width);
    }
    if (col-1>=0 && !visited[row][col-1] && grid[row][col-1] == 1) {
        visited[row][col-1] = true;
        total += dfs(row, col-1, visited, grid, len, width);
    }
    if (col+1<width && !visited[row][col+1] && grid[row][col+1] == 1) {
        visited[row][col+1] = true;
        total += dfs(row, col+1, visited, grid, len, width);
    }
    return 1+total;
}
int maxAreaOfIsland(vector<vector<int>>& grid) {
    if (grid.size() == 0) return 0;
    int len = grid.size();
    int width = grid[0].size();
    vector<vector<bool>> visited(len, vector<bool>(width));
    int maxV = 0;
    for (int i=0; i<grid.size(); i++) {
        for (int j=0; j<grid[0].size(); j++) {
            if (!visited[i][j] && grid[i][j] == 1) {
                visited[i][j] = true;
                maxV = max(maxV, dfs(i, j, visited, grid, len, width));
            }
        }
    }
    return maxV;
}
```
#### 841. 钥匙与房间
- 标准 dfs, 访问过的节点 visited[i] = true
- 统计 visitedNum >= N, 则 return true
- 如果遍历完后 visitedNum < N, return false
```c++
int visitedNum = 0;
bool dfs(int index, vector<vector<int>> rooms, vector<bool>& visited, int N) {
    visitedNum++;
    cout << index << " " << visitedNum << endl;
    if (visitedNum >= N) return true;
    visited[index] = true;
    for (int j: rooms[index]) {
        if (j!= index && !visited[j]) {
            if (dfs(j, rooms, visited, N)) return true;
        }
    }
    return false;
}
bool canVisitAllRooms(vector<vector<int>>& rooms) {
    int N = rooms.size();
    vector<bool> visited(N);
    return dfs(0, rooms, visited, N);
}
```
#### 547. 省份数量
- 实际上就是求 覆盖所有节点需要多少个连通分量
### 拓扑排序
#### 构造图
- 如果存在关系 [u,v], 且 u 在 v 之前，则 u 的邻接节点中加上 v
#### 基于 DFS 的算法 （辅助栈)
```伪代码
// 对每个节点执行 dfs
function dfs(int n) {
    if (!visited[n]) {
        visited[n] = true;
        for (w: n 的所有邻接节点)
            dfs(w)
        visited[n] = false;
        把 n 加入栈中
    }
}
// 出栈序列即为拓扑排序结果
```
- 为什么在 dfs 之后才 把 n 加入栈中？
    - 保证 n 在其所有后序节点之前出栈
- 还需要考虑是否存在回路。若存在回路，则没有拓扑序列 （localMarked, globalMarked)
#### 210. 课程表2
- 复杂用例没法通过，超时
```c++
bool dfs(int index, vector<vector<int>> adj, vector<int>& mark, stack<int>& st) {
    // 从自己出发的 dfs, 说明存在环
    if (mark[index] == -1) return false;
    // 其他点出发的 dfs
    if (mark[index] == 1) return true;
    mark[index] = -1;
    for (int w: adj[index]) {
        if (!dfs(w, adj, mark, st)) return false;
    }
    st.push(index);
    mark[index] = 1;
    return true;
}
vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
    vector<int> mark(numCourses);
    vector<vector<int>> adj(numCourses);
    stack<int> st;
    vector<int> seq;

    for (vector<int> req: prerequisites) {
        if (req[0] == req[1]) return {};
        adj[req[1]].push_back(req[0]);
    }

    for (int i=0; i<numCourses; i++) {
        if (mark[i] != 1) {
            if (!dfs(i, adj, mark, st)) return {};
        }
    }
    
    while (!st.empty()) {
        seq.push_back(st.top());
        st.pop();
    }
    return seq;
}
```

### 宽度优先算法 (BFS)
基本模板
```c++
void bfs(int start, adj) {
    queue qu;
    qu.push(start);

    while (!qu.empty()) {
        cur = qu.top();
        qu.pop();
        // 对 cur 进行操作
        visited[cur] = true
        for (w: adj[cur]) {
            if (!visited[w])
                qu.push(w);
        }
    }
}
```
- 每一层遍历的节点，与根节点的距离相同
- 得到一个结论，如果先遍历i 后遍历 j, 有 d_i <= d_j
- 如果是一个无权图，第一次遍历到目的节点，所经过路径为最短路径
#### 1091. 二进制矩阵中的最短路径
- 一个无权图，遍历到目标节点，所经过路径为最短路径的例子
```c++
int shortestPathBinaryMatrix(vector<vector<int>>& grid) {
    int n = grid.size();
    queue<vector<int>> qu;
    int pathLen = 1;

    if (grid[0][0] != 0) return -1;
    
    qu.push(vector<int> ({0, 0, pathLen}));
    vector<bool> visited(n * n);
    visited[0] = true;
    // 弄一个方向矩阵，便于遍历所有相邻节点
    vector<vector<int>> directions({{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1,-1}, {1, 0}, {1, 1}});
    while (!qu.empty()) {
        vector<int> cur = qu.front();
        qu.pop();
        // 终止条件
        if (cur[0] == n-1 && cur[1] == n-1) return cur[2];
        for (vector<int> dir: directions) {
            int newRow = cur[0] + dir[0];
            int newCol = cur[1] + dir[1];
            // 越界
            if (newRow <0 || newRow >= n || newCol<0 || newCol>=n) continue;
            // 已访问过或已在队列中 或 == 1
            if (visited[newRow*n + newCol] || grid[newRow][newCol] != 0) continue;
            qu.push({newRow, newCol, cur[2]+1});
            // 加入队列后，就置 visited = true;
            visited[newRow*n + newCol] = true;
        }
    }
    return -1;
}
```
#### 127. 单词接龙
- 怎么想到是用 BFS
    - 最短转换序列，BFS的话一定先遍历第一层，然后第二层... 保证第一次出现的转换序列就是最短的
```c++
// 判断是否只差一个字母
bool oneLetterDiff(string s, string t) {
    if (s.length() != t.length()) return false;
    int total = 0;
    for (int i=0; i<s.length(); i++) {
        if (s[i] != t[i]) total++;
        if (total > 1) return false;
    }
    return total == 1;
}
int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
    queue<pair<string, int>>  qu;
    qu.push({beginWord, 1});
    vector<bool> visited(wordList.size());
    while (!qu.empty()) {
        pair<string, int> cur = qu.front();
        qu.pop();
        // 结束条件：找到 endWord
        if (cur.first == endWord) return cur.second;
        for (int i=0; i<wordList.size(); i++) {
            // 遍历：not visited && 只差一个字母
            if (!visited[i] && oneLetterDiff(cur.first, wordList[i])) {
                qu.push({wordList[i], cur.second+1});
                visited[i] = true;
            }
        }
    }
    return 0;
}
```

### 单源最短路径
找到从节点 s 到其他节点的最短路径
#### 数据结构
- distTo[v]: s 到 v 的最短路径长度
- path[v]: s 到 v 的最短路径上的上一个节点
#### Dijkstra 算法
伪代码
```c++
int distTo[];
int path[];
bool visited[];
int findMin(int s) {
    int minV = -1;
    int tmpMin = INF;
    for (int i=0; i<n; i++) {
        if (!visited[i] && distTo[i] < tmpMin) {
            minV = i;
            tmpMin = distTo[i];
        }
    }
    return minV;
}
void dijkstra(int s) {
    // 首先初始化
    for (int i=0; i<n; i++) {
        distTo[i] = INF;
        path[i] = -1;
    }
    // s 的邻接边
    for (int e: weight[s]) {
        distTo[e.to()] = e.weight;
        path[e.to()] = s; 
    }
    // 循环 n-1 次，把所有点遍历过去
    for (int i=n-1; i>0; i--) {
        int des = findMin(s);
        collected[des] = true;
        // 新增一个节点后，相应修改其他点的距离
        for (int e: weights[des]) {
            if (distTo[e.to()] > distTo[des] + e.weight) {
                distTo[e.to()] = distTo[des] + e.weight;
                pathTo[e.to()] = des;
            }
        }
    }
}
```

#### 787. K 站中转内最便宜的航班
在最短路径问题基础上，还增加了最多 k 次中转这个限制
也就是 dist[dst] <= k+1


#### 279.完全平方数
- 怎么用 BFS? 遍历小于当前值的完全平方数，分别减去该数，然后等待下一次搜索
- 为什么用 BFS? 最少数量问题，BFS保证遍历到的第一个方法，一定是最少数量的
```c++
int numSquares(int n) {
    queue<pair<int, int>> qu;
    qu.push({n, 0});
    while (!qu.empty()) {
        pair<int, int> cur = qu.front();
        qu.pop();
        for (int i=1; i*i <= cur.first; i++) {
            int value = cur.first - i*i;
            int times = cur.second+1;
            if (value == 0) return times;
            else qu.push({ value, times });
        }
    }
    return -1;
}
```

### 二分图
- 能够用两种颜色对图中节点进行着色，且相邻节点颜色不同，则为二分图
#### 785. 判断二分图
- 通过 dfs 遍历图
    - 当前节点颜色与上一节点相反
    - 如果当前节点已经有颜色，而且与上一节点一致，则不能划分为二分图
- 每一个没遍历过的节点，都应作为起点，进行dfs
    - 如果只对第一个节点进行遍历，很可能第一个节点没有邻接节点，根本没有遍历这张图...
```c++
bool dfs(int index, vector<vector<int>> graph, vector<int>& color, int prevColor) {
    color[index] = -prevColor;
    for (int adj: graph[index]) {
        if (color[adj] == color[index]) return false;
        if (color[adj] == 0 && !dfs(adj, graph, color, color[index])) return false; 
    }
    return true;
}
bool isBipartite(vector<vector<int>>& graph) {
    int N = graph.size();
    vector<int> color(N); // -1 代表颜色1， 0代表无颜色，1代表颜色2
    for (int i=0; i<N; i++) {
        if (color[i] == 0 && !dfs(i, graph, color, 1)) return false;
    }
    return true;
}
```
## 单调栈
- 维护一个单调递增/递减的栈
以 739. 每日温度为例
### 739. 每日温度
- 希望维护一个单调递增的栈
- 如果新元素 <= 栈顶元素，直接入栈即可
- 新元素 > 栈顶元素，则出栈，并执行操作
    - 该出栈元素的天数 = 新元素Index - 出站元素Index
    - 循环该操作，直到 新元素 <= 栈顶元素
```c++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> days(temperatures.size());
    // 单调递增栈，存放的是数组下标，实际比较的是值
    stack<int> st;

    for (int i=0; i<temperatures.size(); i++) {
        while (!st.empty()) {
            int prevIndex = st.top();
            if (temperatures[i] > temperatures[prevIndex]) {
                days[prevIndex] = i - prevIndex;
                st.pop();
            } else {
                break;
            }
        }
        st.push(i);
    }

    return days;
}
```

## 综合题
### 42.接雨水
#### 双指针法
我们针对每一列计算能够接的雨水
针对列i, 宽度肯定是1，则雨水面积 min(lHeight, rHeight) - height[i], 只取正值 （不存在负值)
lHeight, rHeight 可以分别往左往右遍历得到
```c++
int trap(vector<int>& height) {
    int lHeight, rHeight;
    int rains=0;
    for (int i=1; i<height.size(); i++) {
        // 第一个柱子 和 最后一个柱子不接雨水
        lHeight = 0, rHeight = 0;
        if (i == height.size() - 1) continue;
        for (int slow = 0; slow < i; slow++) {
            lHeight = max(lHeight, height[slow]);
        }
        for (int fast=i+1; fast < height.size(); fast++) {
            rHeight = max(rHeight, height[fast]);
        }
        int cur = min(lHeight, rHeight) - height[i];
        if (cur <= 0) continue;
        // cout << lHeight << rHeight << height[i] << cur << endl;
        rains = rains + cur;
    }
    return rains;
}
```

#### 动态规划法？存疑
其实我觉得只是双指针法的一个改良
每个位置的lHeight, rHeight 其实可以通过一次遍历来获得，不需要在每次循环内去取。这样可以把复杂度降到 O(n)
```c++
int trap(vector<int>& height) {
    int rains=0;
    vector<int> lMax(height.size());
    vector<int> rMax(height.size());
    lMax[0] = height[0];
    rMax[height.size()-1] = height[height.size()-1];
    for (int i=1; i<height.size(); i++) {
        lMax[i] = max(height[i], lMax[i-1]);
    }
    for (int i=height.size()-2; i>0; i--) {
        rMax[i] = max(height[i], rMax[i+1]);
    }
    for (int i=1; i<height.size(); i++) {
        int cur = min(lMax[i], rMax[i]) - height[i];
        if (cur <= 0) continue;
        rains = rains + cur;
    }
    return rains;
}
```

#### 单调栈法
```
从小到大的单调栈
栈里头存放下标
当前 < 栈顶，则入栈
当前 == 栈顶，栈顶出栈，当前元素入栈（更新下标为最右边的）
当前 > 栈顶，计算水量 (while 循环)
水量 = 长 * 宽
长 = min(height[right], height[left]) - height[mid]
宽 = right - left - 1
```

代码
```c++
int trap(vector<int>& height) {
    int total = 0;
    stack<int> st;
    for (int i=0; i<height.size(); i++) {
        if (st.empty()) {
            st.push(i);
            continue;
        }
        int topIndex = st.top();
        if (height[topIndex] > height[i]) st.push(i);
        else if (height[topIndex] == height[i]) {
            // 遇到相等元素，右边的那个入栈（最新的）
            st.pop();
            st.push(i);
        } else {
            while (!st.empty() && height[i] > height[st.top()]) {
                int midIndex = st.top();
                st.pop();
                if (!st.empty()) {
                    int leftIndex = st.top();
                    total += (i - leftIndex - 1) * (min(height[i], height[leftIndex]) - height[midIndex]);
                }
            }
            
            st.push(i);
            
        }
    }
    return total;
}
```