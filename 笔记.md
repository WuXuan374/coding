[toc]
### 数组
#### 一维数组的存储空间是连续的，那么二维数组？
- 取决于语言实现。C++是连续分布；Java由虚拟机完成寻址操作，不是连续分布。
#### 704 二分查找
- 直接用循环二分查找即可，不一定要递归
```c++
int search(vector<int>& nums, int target) {
    int low = 0;
    int len = nums.size();
    int high = len - 1;
    int mid;
    while (low <= high) {
        mid = (low + high) / 2;
        if (mid >= len) return -1;
        if (nums[mid] == target) return mid;
        if (nums[mid] > target) {v
            high = mid -1;
        } else {
            low = mid + 1;
        }
    }
    return -1;v
}
```
#### 209 长度最小的子数组
- 为什么认为需要双指针法？
    - 很可能需要回溯起始位置，来保证每个子数组都检查到。回溯这一操作需要双指针来完成
```C++
 int minSubArrayLen(int target, vector<int>& nums) {
    int slowIndex=0, fastIndex=0, total=0, minLength=1e5;
    int len = nums.size();
    while (slowIndex < len) {
        // 特殊情况处理，剪枝
        if (fastIndex >= len && total < target) break;
        if (total < target && fastIndex < len) {
            total += nums[fastIndex];
            fastIndex++;
        } else {
            minLength = min(fastIndex - slowIndex, minLength);
            total -= nums[slowIndex];
            slowIndex++;
        }
    }
    if (minLength == 1e5) return 0;
    return minLength;
}
```
#### 59 螺旋矩阵2
```c++
// n*n 二维向量的初始化
vector<vector<int>> res(
    n,
    vector<int>(n)
)
// 二维数组的初始化
int direction[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
```
#### 三数之和
- 仍然是双指针法的应用
- for 循环 遍历起始位置 i
- left 从 i+1 开始， right 从 len-1 开始
- 三数之和小于0 left++
- 三数之和大于0 right--
- ==0 加入向量， left++, right--
```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    int len = nums.size();
    if (len < 2) return res;
    sort(nums.begin(), nums.end());
    for (int i=0; i<len-2;i++) {
        int left = i+1;
        int right = len-1;
        if (i>=1 && nums[i] == nums[i-1]) continue; // 去重
        if (nums[i] > 0) break;
        while (left < right) {
            if (nums[i] + nums[left] + nums[right] < 0) {
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
            }
            else if (nums[i] + nums[left] + nums[right] > 0) {
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
            else if (nums[i] + nums[left] + nums[right] == 0) {
                // 以下五行可化简为: res.push_back(vector<int>({nums[i], nums[left], nums[right]}));
                vector<int> cur;
                cur.push_back(nums[i]);
                cur.push_back(nums[left]);
                cur.push_back(nums[right]);
                res.push_back(cur);
                do {
                    left++;
                } while(left < len && nums[left] == nums[left-1]);
                do {
                    right--;
                } while(right > i && nums[right] == nums[right+1]);
            }
        }
    }
    return res;
```
- **另外的注意点--去重**
- left++, 实际上需要跳过所有相等的值, right--同理
- 
```c++
do {
    left++;
} while(left < len && nums[left] == nums[left-1]);
```
- 遍历i 时，跳过和前一个值相等的
```c++
if (i>=1 && nums[i] == nums[i-1]) continue;
```
### 链表
#### 基础知识
- 链表节点不是连续分布，而是散乱分布
- c++ 链表定义方式
```c++
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) {}; // 构造函数

}
```
- **添加虚拟头结点，可以同化对所有节点的操作，降低复杂度**
#### 203.移除链表元素
- 体现虚拟头结点的作用
```c++
ListNode* removeElements(ListNode* head, int val) {
    ListNode* vHead = new ListNode(0, head);
    ListNode* prev = vHead;
    ListNode* cur = vHead -> next;
    while (cur != NULL) {
        if (cur -> val == val) {
            prev -> next = cur -> next;
            cur = cur -> next;
        } else {
            prev = cur;
            cur = cur -> next;
        }
    }
    return vHead -> next;
}
```
- 仍然存在问题，别忘了释放空间！（虚拟头节点 + 被删除的节点）
```c++
ListNode* tmp;
delete(tmp);
```

#### 面试题 02.07. 链表相交
这一题要看图
简单的思路: 两个指针分别从 headA, headB出发，每次走一步
如果链表A 走完了，就走链表 B; 链表B 走完了，走A
当两个指针所指的节点相等，则遇到交点了

代码实现过程中有不少注意点
```c++
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* nodeA = headA;
    ListNode* nodeB = headB;
    // 因为环不一定存在，为了避免无限循环，控制每个链表只遍历一次
    bool finishA = false, finishB = false;
    // 链表为 NULL 也需要考虑
    if (nodeA == NULL || nodeB == NULL) return NULL;
    while (true) {
        if (nodeA == NULL && !finishA) {
            nodeA = headB;
            finishA = true;
        } else if (nodeA == NULL && finishA) {
            // 只能遍历一次，不允许重复遍历
            break;
        }

        if (nodeB == NULL && !finishB) {
            nodeB = headA;
            finishB = true;
        } else if (nodeB == NULL && finishB) {
            break;
        } 
        // 很可能第一个节点就相等，所以相等判断 先于 往后走一步
        if (nodeA == nodeB) return nodeA;

        nodeA = nodeA -> next;
        nodeB = nodeB -> next;
    }
    return NULL;
}
```
### 哈希表
#### 例子
- 学生名字 通过 hashFunction, 得到索引
- 通过索引直接访问对应数据
- 作用：快速判断一个元素是否出现在集合中
#### 数据结构选用
##### Set
- 优先选用std:unordered_set, 查询和增删效率最优
- 需要集合有序：std:set
- 有序加重复数据: std:multi_set
#### 1002. 查找常用字符
- 数组中的每个字符串，对应一个26位数组，存储每个字母出现的频率
- 两个 26 维数组取最小值，符合“所有字符串都显示”这一定义
- 小技巧
    - 数组初始化 int hash[26] = {0};
    - char to string: string s(1, i + 'a');
```c++
vector<string> commonChars(vector<string>& words) {
    vector<string> result;
    int len = words.size();
    if (!len) {
        return result;
    }
    int hash[26] = {0};
    string word = words[0];
    for (int i=0; i< word.length(); i++) {
        hash[word[i] - 'a'] += 1;
    }
    for (int i=1; i< words.size(); i++) {
        int hashOther[26] = {0};
        string word = words[i];
        for (int i=0; i< word.length(); i++) {
            hashOther[word[i] - 'a'] += 1;
        }
        for (int i=0; i<26; i++) {
            hash[i] = min(hash[i], hashOther[i]);
        }
    }
    for (int i=0; i<26; i++) {
        while (hash[i] > 0) {
            string s(1, i + 'a');
            result.push_back(s);
            hash[i]--;
        }
    }
    return result;
}
```
#### 18. 四数之和
- 固定遍历的是前两个数
- 最后两个数采用双指针法，一个往前 一个往后， 直到相遇

去重
```
数组长度小于 4
所有元素都是正数时， nums[0] > target
nums[i] == nums[i-1]
nums[k] == nums[k-1] (不包括 k-1 == i 的情况)
slow++, fast-- 都要跳过相等的元素
```
```c++
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    vector<vector<int>> res;
    if (nums.size() < 4) return res;
    sort(nums.begin(), nums.end());
    if (nums[0] >= 0 && nums[0] > target) return res;

    for (int i=0;i<nums.size()-3; i++) {
        if (i>0 && nums[i] == nums[i-1]) continue;
        for (int k=i+1; k<nums.size()-2;k++) {
            // 去重
            if (k > i+1 && nums[k] == nums[k-1]) continue;
            int slow = k+1;
            int fast = nums.size() - 1;
            while (slow < fast) {
                int total = nums[i] + nums[k] + nums[slow] + nums[fast];
                if (total < target) {
                    do {
                        slow++;
                    } while(slow < fast && nums[slow] == nums[slow-1]);
                }
                else if (total == target) {
                    res.push_back({nums[i], nums[k], nums[slow], nums[fast]});
                    do {
                        slow++;
                    } while(slow < fast && nums[slow] == nums[slow-1]);
                    do {
                        fast--;
                    } while(slow < fast && nums[fast] == nums[fast+1]);
                } else {
                    do {
                        fast--;
                    } while(slow < fast && nums[fast] == nums[fast+1]);
                }
            }
        }
    }

    return res;
}
```
### 字符串
#### 344.反转字符串
- 简单的双指针法
#### 541. 反转字符串2
- 反转部分可以通过循环完成: 起始:low, 终止: high
- 每 2k 字符进行反转：循环完成
- 检查 len - i < k?
```c++
void reverse(string &s, int low, int high) {
  for (int i=0; i<= (high - low) /2; i++) {
    char tmp = s[low + i];
    s[low + i] = s[high - i];
    s[high - i] = tmp;
  }
}
string reverseStr(string s, int k) {
  int len = s.length();
  for (int i=0; i< len; i += 2*k) {
    if (len - i < k) {
        reverse(s, i, len-1);
    } else {
        reverse(s, i, min(len-1, i+k-1));
    }
  }
  return s;
}
```
#### 剑指 Offer 58 - II. 左旋转字符串
- 在不添加额外空间的前提下进行旋转
- 提示: 整体反转 + 局部反转
### 栈和队列
#### 20.有效的括号
- 匹配问题可应用栈
- 遇到左括号 入栈
- 遇到右括号 出栈 看是否匹配
- 未遍历完成，栈空 || 遍历完成，栈非空，则无效
#### 150. 逆波兰表达式求值
- 还是栈的应用
- string to int: stoi()
#### 347. 前k个高频元素

基本思路
```
// 首先是 unordered_map 统计每个数出现频率
// Topk 计算：当然可以对整个 map 进行排序，但由于是大数问题，可能超时
// 更好的方法:
// TopK 问题用堆来解决
// 利用 priority_queue 实现堆，（小顶堆），超出 k 时，最小的那个元素出队，则最后剩下的是 k个频率最高的元素
```

涉及很多数据结构的使用，归纳如下
```c++
priority_queue: 优先级队列，实际上就是一个堆
堆: 堆是一颗完全二叉树，树中每个结点的值都>=(大顶堆) 或 <=(小顶堆) 其左右孩子的值
priority_queue 的缺省实现是大顶堆

priority_queue 的构造函数
template<
    class T,
    class Container = std::vector<T>,
    class Compare = std::less<typename Container::value_type>
> 

对应
priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

std:less 需要实现 bool operator()(const T& lhs, const T& rhs );
```

代码
```c++
class mycomparison {
public:
    // 为什么 左大于右是小顶堆？ 和 priority_queue的实现有关
    bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
        return lhs.second > rhs.second;
    }
};
vector<int> topKFrequent(vector<int>& nums, int k) {
    // 要统计元素出现频率
    unordered_map<int, int> map; // map<nums[i],对应出现的次数>
    for (int i = 0; i < nums.size(); i++) {
        map[nums[i]]++;
    }

    // 对频率排序
    // 定义一个小顶堆，大小为k
    priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

    // 用固定大小为k的小顶堆，扫面所有频率的数值
    for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
        pri_que.push(*it);
        if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
            pri_que.pop();
        }
    }

    // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒叙来输出到数组
    vector<int> result(k);
    for (int i = k - 1; i >= 0; i--) {
        result[i] = pri_que.top().first;
        pri_que.pop();
    }
    return result;

    }
```
### 二叉树
#### 相关定义
- 满二叉树：只有度数为0和度数为2的节点，且度数为0节点在同一层
- 完全二叉树：只有最下层节点可以没填满，且最下层节点集中在最左边
- 二叉搜索树：左子树小于根结点，右子树大于根结点
- 平衡二叉搜索树：二叉搜索树基础上，左右子树高度差不超过1
#### 顺序存储
- 左孩子：2i+1, 右孩子: 2i+2
#### 遍历
##### 深度优先
- 往深处走，遇到叶子结点再往回
- 前序： 中左右
- 中序： 左中右 
- 后序： 左右中
##### 广度优先
- 一层一层遍历
- 层序遍历
#### 数据结构定义
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x): val(x), left(NULL), right(NULL) {}
};
```
#### 递归遍历三部曲 （前序遍历为例）
- 递归函数的参数和返回值
```c++
// 当前节点 和 存储遍历值的 vector
void traverse(TreeNode* cur, vector<int>& vec)
```
- 结束条件
```c++
if (cur == NULL) return;
```
- 单层递归逻辑
```c++
vec.push_back(cur->val); //中
traverse(cur->left, vec); //左
traverse(cur->right, vec); //右
```

#### 三种遍历的迭代方法！
##### 前序遍历(辅助栈)
- 空节点不入栈
```c++
stack<TreeNode* > st;
vector<int> res;
vector<int> preorderTraversal(TreeNode* root) {
    if (root == NULL) return res;
    st.push(root);
    while (!st.empty()) {
        TreeNode* cur = st.top();
        st.pop();
        res.push_back(cur->val);
        if (cur->right != NULL) st.push(cur->right);
        if (cur->left != NULL) st.push(cur->left);
    }
    return res;
}
```
##### 中序遍历
- 中序遍历不能用前序遍历的方法，为啥？
一共存在两种操作
- 处理：将元素放入数组
- 访问：遍历节点
- 前序遍历是中左右，访问顺序和处理顺序一致，所以代码写起来很顺
- 中序是左中右，两个顺序不一致，就麻烦些

```c++
vector<int> inorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> res;
    TreeNode* cur = root;
    
    while (cur != NULL || !st.empty()) {
        if (cur != NULL) {
            st.push(cur);
            cur = cur -> left; // 不断访问左孩子节点
        } else {
            cur = st.top();
            st.pop();
            res.push_back(cur->val); //操作左、中间节点
            cur = cur->right; // 访问右边节点，如果为 NULL，下一次会访问到栈里头的上一个节点（中间节点）
        }
    }
    return res;
}
```
##### 后序遍历（很巧妙，基于前序遍历做的改动）
- 左右中这样的顺序，要模拟实现我是做不来
- 前序: 中左右 --> 中右左 --> 数组反过来就是左右中了
- 所以，执行一遍调换左右的前序遍历，最后将数组反过来即可
```c++
vector<int> postorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    vector<int> res;
    TreeNode* cur = root;
    if (cur) st.push(cur);
    while (!st.empty()) {
        cur = st.top();
        st.pop();
        res.push_back(cur->val);
        if (cur->left) st.push(cur->left);
        if (cur->right) st.push(cur->right);
    }
    reverse(res.begin(), res.end());
    return res;
    }
```
#### 226. 翻转二叉树
```c++
// 实现一个swap 函数，交换 cur->left, cur->right
// 递归函数
void recur(TreeNode* cur);

// 结束条件
if (cur == NULL) return;

// 递归逻辑
swap(cur);
recur(cur->left);
recur(cur->right);
```
#### 102 层序遍历
- 需要用到一个辅助队列，用到其先进先出的特性
- 同一层的元素归类到vector 的同一维如何实现？读取队列的大小，该大小代表该层的节点数
- 元素出队 --> val加入vector --> 孩子结点入队
#### 106. 从中序与后序遍历序列构造二叉树
- 依然需要递归
- 思路
```
// 中序 左中右 [9, 3, 15, 20, 7]
// 后序 左右中 [9, 15, 7, 20, 3]
// 递归, 参数为中序 后序数组
// 1. 只有一个节点，返回该结点即可
// 2. 找到中间节点 --> 后序数组 最后一个，中序数组按值查找
// 3. 划分中序的左子树，右子树，后序的左子树 右子树 (左闭右开原则)
// 4. 递归构建左子树，右子树
```
- 代码
```c++
TreeNode* recur(vector<int> inorder, vector<int> postorder) {
    int rootValue = postorder[postorder.size() - 1];
    TreeNode* root = new TreeNode(rootValue);
    if (postorder.size() == 1) return root;
    int rootIndex;
    // 找到中序遍历中的根结点位置
    for (rootIndex = 0; rootIndex < inorder.size(); rootIndex++) {
        if (inorder[rootIndex] == rootValue) break;
    }
    // vector 的构造 可以通过 iterator 完成
    vector<int> inorderLeft(inorder.begin(), inorder.begin() + rootIndex);
    vector<int> inorderRight(inorder.begin() + rootIndex + 1, inorder.begin() + inorder.size());

    // 一个比较巧的地方，后序遍历的左子树部分，长度和中序遍历左子树一致
    vector<int> postorderLeft(postorder.begin(), postorder.begin() + inorderLeft.size());
    vector<int> postorderRight(postorder.begin() + inorderLeft.size(), postorder.begin()+ postorder.size()-1);

    // 这里做一个预处理，数组为空，说明子树为 NULLv
    root -> left = inorderLeft.size() > 0 ? recur(inorderLeft, postorderLeft): NULL;
    root -> right = inorderRight.size() > 0 ? recur(inorderRight, postorderRight): NULL;
    return root;
}
TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
    if (inorder.size() < 1) return NULL;
    return recur(inorder, postorder);
}
```

#### 236. 二叉树的最近公共祖先
思路
```
节点的祖先，先访问左右孩子，再访问根节点，与后序遍历顺序一致
基于后序遍历:
左右孩子 --> 返回
空节点 --> 返回
遍历左右子树，如果都非空，说明根节点为公共祖先，返回根节点
都为 NULL, 说明子树无相关元素，返回 NULL
其中一个子树非空，返回该非空节点（要么是p,q之一，要么是祖先节点)
```

```c++
TreeNode* recur(TreeNode* node, TreeNode* p, TreeNode* q) {
    if (node == p || node == q || node == NULL) {
        return node;
    }

    TreeNode* left = recur(node->left, p, q);
    TreeNode* right = recur(node->right, p, q);
    
    if (left != NULL && right != NULL) return node;
    if (left != NULL) return left;
    if (right != NULL) return right;
    return NULL;
}
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    return recur(root, p, q);
}
```
### 二叉搜索树
- 看到二叉搜索树，一定要想到他是有序的
- 我们可以通过一个中序遍历，把它转化成一个有序数组
- 所以求最值、差值等问题，都可以等同于在数组上的相关问题

#### 235. 二叉搜索树的公共祖先
236 是基于后序遍历，但235我们可以利用二叉搜索树的性质
公共祖先，其值一定在 [p,q] 这个范围内 --> 闭区间，公共祖先可能是自己
按照这个规则递归即可
```c++
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (root == NULL) return NULL;
    if ((root->val >= p->val && root->val <= q->val) || (root->val >= q->val && root->val <= p->val)) {
        return root;
    }
    TreeNode* leftNode = lowestCommonAncestor(root->left, p, q);
    TreeNode* rightNode = lowestCommonAncestor(root->right, p, q);
    if (leftNode) return leftNode;
    return rightNode;
}
```
#### 530. 二叉搜索树的绝对差
中序遍历之后，就可以在有序数组上遍历求绝对差
```c++
void midOrder(TreeNode* node, vector<int>& seq) {
    if (node == NULL) return;
    midOrder(node->left, seq);
    seq.push_back(node->val);
    midOrder(node->right, seq);
}

int getMinimumDifference(TreeNode* root) {
    vector<int> seq;
    midOrder(root, seq);
    int minimum = 1e5;
    for (int i=0; i<seq.size()-1; i++) {
        if (seq[i+1] - seq[i] < minimum) minimum = seq[i+1] - seq[i];
    }
    return minimum;
}
```
#### 501. 二叉搜索树中的众数
##### 方法1
针对普通的树，我们可以遍历该树，通过一个map 存放每个元素出现的频率。
最后遍历 map（或者排序, 返回众数
```c++
unordered_map<int, int> map;
void midOrder(TreeNode* cur) {
    if (cur == NULL) return;
    midOrder(cur->left);
    
    map[cur->val] += 1;

    midOrder(cur->right);
}
vector<int> findMode(TreeNode* root) {
    midOrder(root);
    vector<int> res;
    int maxCount = 0;
    // auto 牛逼
    for (auto it = map.begin(); it!=map.end(); it++) {
        if (it->second > maxCount) {
            res.clear();
            res.push_back(it->first);
            maxCount = it->second;
        } else if (it->second == maxCount) {
            res.push_back(it->first);
        }
    }
    return res;
}
```
map 无法排序，但是 vector可以。从 map 到 vector的转换方法
vector<pair<int, int>> vec(map.begin(), map.end());

##### 方法2
利用二叉搜索树，其中序遍历是有序的这一性质，省去map(不使用额外的空间)
- 记录前一个元素 pre, 比较是否和前一个元素相等
- 记录相等的数量 count, 和最大相等频率 maxCount
```c++
TreeNode* pre = NULL;
int count = 0;
int maxCount = 0;
vector<int> res;
void searchBST(TreeNode* cur) {
    if (cur == NULL) return;
    searchBST(cur->left);// 左
    // 中
    if (pre != NULL && cur->val == pre->val) {
        count++;
    } else {
        count = 1;
    }
    pre = cur;
    

    if (count > maxCount) {
        res.clear();
        maxCount = count;
        res.push_back(cur->val);
    } else if (count == maxCount) {
        res.push_back(cur->val);
    }

    searchBST(cur->right);//右

}
vector<int> findMode(TreeNode* root) {
    searchBST(root);
    return res;
}
```
#### 700.二叉搜索树中的搜索
```c++
TreeNode* searchBST(TreeNode* root, int val) {
    if (root == NULL) return NULL;
    if (root->val == val) return root;
    if (val < root->val) return searchBST(root->left, val);
    return searchBST(root->right, val);
}
```
#### 701. 二叉搜索树中的插入操作
```
并不需要按题目说的，去修改树的结构
按照二叉搜索树的结构去遍历（左小右大），遇到符合条件的空节点就插入即可
具体：
左孩子为空 && val < root->val, 插入左孩子
右孩子为空 && val > root->val, 插入右孩子
其他情况 val < root->val， recur(root->left)
val > root->val, recur(root->right)
```

```c++
void recur(TreeNode* node, int val) {
    if (!node->left && val < node->val) {
        node -> left = new TreeNode(val);
        return;
    } else if (!node->right && val > node->val) {
        node->right = new TreeNode(val);
        return;
    }
    if (val < node->val) recur(node->left, val);
    else recur(node->right, val);
    }
    TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (root == NULL) return new TreeNode(val);
    recur(root, val);
    return root;
}
```
### 回溯算法
#### 常见问题
- 组合问题
- 切割问题：字符串按照某规则，有几种切割方式
- 子集问题
- 排列问题
- 棋盘问题: N皇后
#### 模板
```c++
void backtracing(参数) {
    if (结束条件) {
        存放结果;
        return;
    }
    for (选择: 本层的所有节点) {
        处理结点；
        backtracing(参数)；
        撤销处理效果
    }
}
```
#### 77.组合
```c++
vector<vector<int>> res;
    vector<int> cur;
    void backtracing(int start, int n, int k) {
        if (cur.size() == k) {
            res.push_back(cur);
            return;
        }
        // 这里剪枝了 (剩余选项 >= k - cur.size())
        for (int i=start; i<=n-k+1+cur.size(); i++) {
            cur.push_back(i);
            backtracing(i+1, n, k);
            cur.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracing(1, n, k);
        return res;
    }
```
#### 131. 分割回文串
- 类比组合问题，只不过组合的是字符串的切割位置
- 思路
```
// void backtracing(string s, int startIndex)
// 结束条件 startIndex >= s.length()
// for 循环, 循环的是截取位置
// for (i=startIndex; i<=s.length();i++)
```
- 代码
```c++
vector<vector<string>> res;
vector<string> cur;
bool isReversable(string s, int start, int end) {
    while (start <= end) {
        if (s[start] != s[end]) return false;
        start++;
        end--;
    }
    return true;
}

void backtracing(string s, int startIndex) {
    if (startIndex == s.length()) {
        res.push_back(cur);
        return;
    }

    for (int i=startIndex; i<s.length(); i++) {
        if (isReversable(s, startIndex, i)) {
            cur.push_back(string(s.begin()+ startIndex, s.begin() + i + 1));
            backtracing(s, i+1);
            cur.pop_back();
        }
    } 
}
vector<vector<string>> partition(string s) {
    backtracing(s, 0);
    
    return res;
}
```

#### 46. 全排列
```c++
vector<vector<int>> res;
vector<int> cur;
void backtracing(vector<int>& nums, vector<bool>& visited) {
    if (cur.size() == nums.size()) {
        res.push_back(cur);
    }
    // 和 组合的不同，并不是只能往后遍历
    // 所有元素都需要遍历，通过 visited 数组辨别是否已经访问过了
    for (int i=0; i<nums.size();i++) {
        if (!visited[i]) {
            visited[i] = true;
            cur.push_back(nums[i]);
            backtracing(nums, visited);
            // 执行结束，撤销结果
            visited[i] = false;
            cur.pop_back();
        }
    }
}

vector<vector<int>> permute(vector<int>& nums) {
    vector<bool> visited(nums.size());
    backtracing(nums, visited);
    return res;
}
```
#### 332. 重新安排行程 
```c++
class Solution {
public:
    // 利用 unordered_map 里头的元素按照字母序排列这一性质，实现题目要求的，字母序较小行程优先
    unordered_map<string, map<string, int>> targets;
    
    bool backtracing(int ticketNum, vector<string>& res) {
        if (res.size() == ticketNum + 1) {
            // 只需要返回一个行程，因此返回 bool 即可
            return true;
        }

        // 注意这个 pair, int 记录到这个地方的航班数
        for (pair<const string, int>& target: targets[res[res.size()-1]]) {
            if (target.second > 0) {
                target.second--;
                res.push_back(target.first);
                if (backtracing(ticketNum, res)) return true;
                target.second++;
                res.pop_back();
            }
        }
        return false;
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        vector<string> res;

        for (const vector<string>& vec: tickets) {
            targets[vec[0]][vec[1]]++;
        }
        res.push_back("JFK");
        backtracing(tickets.size(), res);
        return res;
    }
};
```

#### 51. N皇后
一些重点

```
convert() 是从 [[0,1], [1,2]] --> [".Q.", "..Q"]
改进
- 不需要存两位， 下标本身就代表行数
- 可以直接弄一个 vector<vector<string>>, 里面每个点要么'Q', 要么'.'  省去转换这一步
- string s(n, '.'): 初始化长度为n, "...." 这样的字符串

valid():
- 检查同一列上有没有皇后
- 检查对角线 (45, 135)
- 行不需要检查，回溯中每次 Index+1
```
```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<int>> cur;

    vector<string> convert(vector<vector<int>> cur, int n) {
        vector<string> res;

        for (int i=0; i<cur.size(); i++) {
            string s(n, '.');
            s[cur[i][1]] = 'Q';
            res.push_back(s);
        }
        return res;
    }

    int abs(int a, int b) {
        if (a > b) return a-b;
        return b-a;
    }

    bool valid(int row, int col) {
        // 检查列
        for (int i=0; i<cur.size(); i++) {
            if (col == cur[i][1]) return false;
        }
        // 检查 45 度 对角线
        for (int i=0; i<cur.size(); i++) {
            if (row-i == col-cur[i][1]) return false;
        }
        // 检查 135 度 对角线
        for (int i=0; i<cur.size(); i++) {
            if (row-i == cur[i][1] - col) return false;
        }

        return true;
    }

    void backtracing(int index, int n) {
        if (index == n) {
            res.push_back(convert(cur, n));
            return;
        }

        for (int i=0; i<n; i++) {
            if (valid(index, i)) {
                cur.push_back({ index, i});
                backtracing(index+1, n);
                cur.pop_back();
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        backtracing(0, n);
        return res;
    }
};
```

#### 491.递增子序列
回溯法
```markdown
void backtracing(vector<int> nums, int startIndex)
结束条件 if (startIndex >= nums.size()) return;
同时，如果cur 里头有至少两个元素，就加入 res, **但此时没有结束递归！**

单层操作：需要去重，相同元素不能出现在同一层
每一层定义一个 uset, 存放本层已出现的元素；下一层这个 uset 就重新初始化，不会传下去了。
```
```c++
vector<vector<int>> res;
vector<int> cur;
void backtracing(vector<int> nums, int startIndex) {
    if (cur.size() >= 2) res.push_back(cur);
    if (startIndex >= nums.size()) return;
    // 同一层不能访问相同元素
    unordered_set<int> uset;
    for (int i= startIndex; i<nums.size(); i++) {
        if (uset.find(nums[i]) != uset.end()) continue;
        uset.insert(nums[i]);
        if (startIndex == 0 || nums[i] >= nums[startIndex - 1]) {
            cur.push_back(nums[i]);
            backtracing(nums, i+1);
            cur.pop_back();
        }
    }
}
vector<vector<int>> findSubsequences(vector<int>& nums) {
    backtracing(nums, 0);
    return res;
}
```
### 贪心算法
#### 局部最优推出全局最优
#### 455. 分发饼干
- 局部最优: s[j] - g[i] 最小（也就是最刚好，浪费的饼干最少)
- s, g 排序
- 如果 g[i] <= s[j], i++. j++, num++
- g[i] > s[j]: s++;
```c++
int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end());
    sort(s.begin(), s.end());
    int i=0, j=0, num=0;
    while (i < g.size() && j < s.size()) {
        if (g[i] <= s[j]) {
            i++;
            j++;
            num++;
        } else {
            j++;
        }
    }
    return num;
}
```

#### 122. 买卖股票的最佳时机2
##### 做法1
- 把利润分解为每两天之间的差价，而不是多天的总利润
- 局部最优? 收集每个正利润 prices[i+1] - prices[i]
- 全局最优: 最大利润

##### 做法2
- prices[fast] > prices[slow] && prices[fast] < prices[fast+1] 则卖出
```c++
int maxProfit(vector<int>& prices) {
    int slow = 0, fast = 1, total=0;
    while (fast < prices.size()) {
        if (prices[slow] > prices[fast]) {
            slow++;
            fast++;
        } else {
            if (fast + 1 < prices.size() && prices[fast] < prices[fast+1]) fast++;
            else {
                total += prices[fast] - prices[slow];
                slow = fast+1;
                fast = fast+2;
            }
        }
    }

    return total;
}
```

#### 55.跳跃游戏
- 局部最优：当前位置的最大覆盖范围
- 全局最优 nums.size()-2 处的最大覆盖范围，是否>= nums.size()-1
```c++
bool canJump(vector<int>& nums) {
    int maxCover = 0, i=0;
    while(i < nums.size() -1 && maxCover>=i) {
        maxCover = max(maxCover, i+nums[i]);
        i++;
    }
    return maxCover >= nums.size()-1;
}
```
#### 45. 跳跃游戏2
动态规划做法
```c++
int jump(vector<int>& nums) {
    vector<int> dp(nums.size());
    for (int i=1; i<dp.size(); i++) {
        for (int j=0; j<i; j++) {
            if (j + nums[j] >= i) {
                dp[i] = dp[i] == 0 ? dp[j] + 1 : min(dp[i], dp[j]+1);
            } 
        }
    }
    return dp[dp.size()-1];
}
```

贪心做法
计算当前能覆盖最大位置，和下一步能覆盖的最大位置
如果 curDistance < nums.size()-1, 那么就需要走一步 count++, curDistance = nextDistance
```c++
int jump(vector<int>& nums) {
    if (nums.size() == 1) return 0;
    int curDistance = 0;
    int nextDistance = 0;
    int count = 0;
    for (int i=0; i<nums.size(); i++) {
        nextDistance = max(nextDistance, i+nums[i]);
        if (i == curDistance) {
            if (curDistance >= nums.size()-1) break;
            count++;
            curDistance = nextDistance;
            if (nextDistance >= nums.size()-1) break;
        }
    }
    return count;
}
```
#### 1005. K 次取反后最大化的数组和
贪心策略
```
// 先把负数变成正数
// 剩下偶数次：一个数变来变去，总和不变
// 剩下奇数次: 选最小的数，变成负的
```

代码
```c++
 int largestSumAfterKNegations(vector<int>& nums, int k) {
    int i=0;
    sort(nums.begin(), nums.end());
    // 负数变为正的
    while (i < nums.size() && nums[i] < 0 && k>0) {
        nums[i] = -nums[i];
        k--;
        i++;
    }
    int total = accu(nums);
    if (k%2 == 0) return total;
    // 找出最小的那个数，变成负数
    int min = 1e5;
    for (int i=0; i<nums.size(); i++) {
        if (nums[i] < min) min = nums[i];
    }
    return total - 2*min;
}
```
#### 134. 加油站

暴力解法: 从每个位置开始模拟，看看能否回到该点。
gas 总和小于 cost, 剪枝
如果起始位置 diff < 0, 可以剪枝

贪心解法:
```
首先确认 diff[] 总和 > 0, 否则一定不能回到终点
记录 curSum
如果 curSum < 0, 说明会遇到油不足的情况，且 sum[i+1, diff.size()] > 0, 则起始位置应该从 i+1 开始， curSum = 0

局部最优: 如果前diff[j]的 curSum < 0, 起始位置至少是j+1
全局最优: 找到一个起始位置
```

代码
```c++
int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
    vector<int> diff; // <index, value>
    for (int i=0; i<gas.size();i++) {
        diff.push_back(gas[i] - cost[i]);
    }
    int curSum = 0;
    int total = 0;
    int start = 0;

    for (int i=0; i<diff.size(); i++) {
        curSum += diff[i];
        total += diff[i];
        if (curSum < 0) {
            start = i+1;
            curSum = 0;
        }
    }
    if (total < 0) return -1;
    return start;
}
```
#### 135.分发糖果
```
一定要确定左边之后, 再确定右边
两边一起考虑，会顾此失彼

考虑右孩子大于左孩子的情况，从前往后遍历
局部最优: ratings[i] > ratings[i-1] 则 candies[i] = candies[i-1] + 1
全局最优：评分高的右孩子，糖果比左孩子多1

接下来考虑左孩子大于右孩子情况，从后往前遍历

```

```c++
int candy(vector<int>& ratings) {
    vector<int> candies(ratings.size(), 1);
    for (int i=1; i<ratings.size(); i++) {
        if (ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;
    }
    for (int i=ratings.size()-1; i>0; i--) {
        if (ratings[i] < ratings[i-1]) {
            candies[i-1] = max(candies[i] +1, candies[i-1]); 
        }
    }
    return accumulate(candies.begin(), candies.end(), 0);
}
```

#### 860. 柠檬水找零
- 给5元，不用找钱
- 给10元，找5元
- 给20， 10+5 || 5+5+5
- 5元是最有用的。所以优先找10元，其次才是5元
- 模拟整个过程即可，用map 存储目前已有的面额数量

```c++
unordered_map<int, int> map;
for (int i=0; i<bills.size(); i++) {
    if (bills[i] == 5) {
        map[5] += 1;
    } else if (bills[i] == 10) {
        if (map[5] <= 0) return false;
        map[5]--;
        map[10]++;
    } else {
        if (map[10] > 0 && map[5] > 0) {
            map[10]--;
            map[5]--;
        } else if (map[5] >= 3) {
            map[5] = map[5] - 3;
        } else {
            return false;
        }
    } 
}
return true;
```

#### 406. 根据身高重建队列
与135.分发糖果有共同点：存在两个维度时，一定先确定一个维度，再确定另一个维度
本例中，我们首先确定高度，越高的站前面，（高度相等时，ki 小的站前面）
其次确定 k. 我们按照排序后数组的顺序，分别将元素插入新数组的Ki处即可。
听起来很神奇，为啥呢？
前提：一定能生成符合要求的序列，且我们从高到低进行插入
局部最优：针对一个 (h_i, k_i), 插入 下标k_i处时，比他高的元素已经插入好了，所以前面一定有k_i个高于或等于它的；对于原来 k_i处，现在k_i+1处那个元素，前面插入了一个高度更小的，不影响自己
全局最优：每个位置都按这个规则插入

```c++
vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
    // 首先按照高度排序
    sort(people.begin(), people.end(), cmp);
    // 按照高度顺序，一个个插入k对应的下标
    vector<vector<int>> sorted;
    for (int i=0; i<people.size(); i++) {
        sorted.insert(sorted.begin()+people[i][1], people[i]);
    }
    return sorted;
}
```
### 动态规划
#### 解题步骤
- 确定 dp 数组 及下标含义
- 递推公式
- dp 数组初始化
- 确定遍历顺序
- 举例推导 dp数组
- dp 数组要打印出来！
#### 斐波那契数列问题为例
- 确定 dp 数组 及下标含义 --> dp[i] --> F(i)
- 递推公式 --> dp[i] = dp[i-1] + dp[i-2]
- dp 数组初始化 --> dp[0] = 0, dp[1] = 1
- 确定遍历顺序 --> 从前到后
- 举例推导 dp数组 --> 0 1 1 2 3 5 8, 打印出来，比较一下！
#### 70. 爬楼梯
- dp[i]: 第i级阶梯到顶层阶梯的方法
- dp[i] = dp[i+1] + dp[i+2]
- dp[n-2] = 2, dp[n-1] = 1
- 从右向左
```c++
int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    // 两个数组元素就够了！
    int dp[2]; // vector<int> dp(2), 向量同样可以用下标访问
    dp[0] = 1;
    dp[1] = 2;
    for (int i = n-3;i>=0;i--) {
        int sum = dp[0] + dp[1];
        dp[0] = dp[1];
        dp[1] = sum;
    }
    return dp[1];
}
```
#### 746. 使用最小花费爬楼梯
- dp[n]: 登上第 n 级台阶的总花费
- dp[n] = min(dp[n-1] + cost[n-1], dp[n-2] + cost[n-2])
- dp[0] = 0, dp[1] = 0 (起始位置不花钱，登上台阶才花钱)
#### 343. 整数划分
- 动规五部曲
```
// dp[n]: n可拆分得到的最大乘积
// dp[n] = max (j*(n-j), j*dp[n-j]), j 从1开始
// dp[2] = 1
```
- 代码
```c++
int integerBreak(int n) {
    vector<int> dp(n+1);
    dp[2] = 1;
    for (int i=3; i<=n; i++) {
        dp[i] = -1e5;
        for (int j=1; j<=i-2; j++) {
            // 在遍历过程中需要不断计算最大值
            // 可以通过加入 dp[i] 项，取最大值，避免额外维护一个变量
            dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j]));
        }
    }
    return dp[n];
}
```
#### 96. 不同的二叉搜索树
思路
```
dp[n]: 1->n 组成的二叉搜索树数量
dp[4] 为例
以 4 为根， 左子树三个点 dp[3] * 右子树 0个点 dp[0]
以 3 为根 左子树2个点 dp[2] * 右子树 1个点 dp[1]
以 2 为根 左子树1个点 dp[1] * 右子树 2个点 dp[2]
以 1 为根 左子树0个点 dp[0] * 右子树 3个点 dp[3]
dp[n] = sum(dp[j] * dp[n-1-j])
dp[0] = 1
```

#### 62. 不同路径
- 二维动态规划
- 思路
```
dp[i][j]: (0, 0) 出发，到 (i, j) 的路径数
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
**初始化: dp [i][0] = 1 dp[0][j] = 1**
```
- 代码
```c++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m,vector<int>(n));
    for (int i=0; i<m; i++) {
        dp[i][0] = 1;
    }
    for (int i=0; i<n; i++) {
        dp[0][i] = 1;
    }
    for (int i=1; i<m; i++) {
        for (int j=1; j<n; j++) {
            dp[i][j] = dp[i][j-1] + dp[i-1][j];
        }
    }
    return dp[m-1][n-1];
}
```
#### 198.打家劫舍
动态规划五部曲
```
dp[n] 到了第 n 家时的最高金额
要么偷n, 则 n-1 一定不偷；要么不偷n
dp[n] = max(dp[n-1], dp[n-2] + a[n])

dp[0] = 0
dp[1] = nums[1-1]
```

代码
```c++
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size() + 1);
        dp[0] = 0;
        dp[1] = nums[0];

        for (int i=2; i<dp.size(); i++) {
            dp[i] = max(dp[i-2]+ nums[i-1], dp[i-1]);
        }
        return dp[dp.size()-1];
    }
};
```

#### 213.打家劫舍2
```
主要的区别是 第一家 和 最后一家连在一起，不能同时抢
既然不能同时抢，我们分别考虑 1-> n-1, 2 --> n 这两种情况，取最大值即可

重新定义 dp[n]: 下标为 n 处的最大金额
```

```c++
int rob(vector<int>& nums) {
    if (nums.size() == 1) return nums[0];
    if (nums.size() == 2) return max(nums[0], nums[1]);
    // 考虑首个元素的 dp
    vector<int> dp1(nums.size());
    // 考虑尾元素的 dp
    vector<int> dp2(nums.size());

    // 接下来两部分逻辑一致，可以抽一个函数出去
    dp1[0] = nums[0];
    dp1[1] = max(nums[0], nums[1]);
    for (int i=2; i<nums.size()-1; i++) {
        dp1[i] = max(dp1[i-1], dp1[i-2] + nums[i]);
    }

    dp2[1] = nums[1];
    dp2[2] = max(nums[1], nums[2]);
    for (int i=3; i<nums.size(); i++) {
        dp2[i] = max(dp2[i-1], dp2[i-2] + nums[i]);
    }

    return max(dp1[nums.size()-2], dp2[nums.size()-1]);
}
```
#### 337.打家劫舍3
##### 方法1 暴力递归
可以通过后序遍历进行递归
对于每个节点，考虑：
1. 抢劫该节点，则不抢孩子节点
2. 不抢该节点，则抢孩子节点
取两者的最大值

```c++
int rob(TreeNode* root) {
    if (root == NULL) return 0;
    if (root->left == NULL && root->right == NULL) return root->val;

    int val_parent = root->val;
    // 偷父节点, 跳过孩子节点
    if (root->left) val_parent += rob(root->left->left) + rob(root->left->right);
    if (root->right) val_parent += rob(root->right->left) + rob(root->right->right);

    int val_child = rob(root->left) + rob(root->right);
    return max(val_parent, val_child);
}
```
但是这种方法会超时
##### 方法2 有记忆的递归
我们在每次递归下，会计算孙子节点的值；但是在儿子节点递归时，孙子节点作为儿子的儿子，被重复计算了
因此我们可以用一个 map 存储已经计算过的值，避免重复
##### 方法3 树形贪心
- 函数参数和返回值
    - vector<int> robTree(TreeNode* node)
    - 返回长度为2的dp数组， dp[0] 代表不抢当前节点, dp[1] 代表抢当前节点
- 结束条件
    - if (cur == NULL) return vector<int>({0, 0});
- 遍历顺序
    - 后序遍历
- 单层递归逻辑
    - 偷当前节点 val1 = node->val + max(left[0], right[0])
    - 不偷当前节点 val2 = max(left[0], left[1]) + max(right[0], right[1])
    - return {val2, val1}

```c++
vector<int> robTree(TreeNode* node) {
    if (node == NULL) return vector<int>({0, 0});
    vector<int> left, right;
    left = robTree(node->left);
    right = robTree(node->right);
    // 不抢本节点
    int val1 = max(left[0], left[1]) + max(right[0], right[1]);
    // 抢本节点
    int val2 = node->val + left[0] + right[0];
    return vector<int>({val1, val2});
}
int rob(TreeNode* root) {
    vector<int> res = robTree(root);
    return max(res[0], res[1]);
}
```
#### 121. 买卖股票的最佳时机
- 只买卖股票一次
##### 方法1 贪心
最左价格最低处买入，最右价格最高处卖出
遍历数组，每新增一个元素，更新最低价格 low
记录差价 res, 每新增一个元素，同时比较该元素 - low 和 res的大小
(其实我感觉没体现出是贪心吧)

```c++
int maxProfit(vector<int>& prices) {    
    int low = 1e5;
    int res = 0;
    for (int i=0; i<prices.size(); i++) {
        low = min(low, prices[i]);
        res = max(res, prices[i]-low);
    }
    return res;
}
```
### 方法2 动态规划
- 递推过程中，同样记得维护最小值 low
- dp[n]: 下标为 n处最大利润
- dp[0] = 0
- dp[n] = max(dp[n-1], nums[n] - min), 同时维护 min
```c++
int maxProfit(vector<int>& prices) {    
    int low = prices[0];
    vector<int> dp(prices.size());
    dp[0] = 0;
    for (int i=1; i<dp.size(); i++) {
        low = min(low, prices[i]);
        dp[i] = max(dp[i-1], prices[i]-low);
    }
    return dp[dp.size()-1];
}
```
### 动态规划--01背包问题
问题定义
```
总重为 W 的背包
N件物品， weight[i], value[i], 每件物品只能用一次
背包里头的物品最大价值？
```

动规五部曲(二维数组版)

```
dp[i][j]: 在[0-i]物品中进行选择，装入后背包的容量为j, 此时背包的最大价值

dp[i][j] = max(
            dp[i-1][j]  不放入物品 i
            dp[i-1][j-weights[i]] + values[i] 放入物品i, 注意检查 j-weights[i] 的越界情况
            )

初始化：
    dp[i][0] = 0
    dp[0][j] = j >= weights[0] ? value[0] : 0

遍历顺序：每个值 依赖其左上角的值
所以先遍历物品，然后背包容量           
```

如果我们把 i-1 那一层 拷贝到 i 层，表达式可以简化为
dp[i][j] = max(dp[i][j], dp[i][j-weight[i]] + value[i])

进一步简化为一维数组
dp[j] = max(dp[j-weight[i]] + value[i])

动规五部曲(滚动一维数组版)

```
dp[j]: 容量为 j 的背包的最大价值
dp[j] = max(dp[j], dp[j-weight[i]]+value[i])
由于推导过程中取较大的数，价值非负情况下，所有 dp[i] 初始为0即可

遍历顺序:
for (int i=0; i<weight.size(); i++) {// 遍历一个个物品
    for (int j=bagWeight; j>=weight[i]; j--) { // 遍历背包容量

    }
}

为什么倒序遍历背包容量？因为 dp 和前者有关，正序遍历可能导致物品被重复加入
```

#### 416. 分割等和子集
如何理解为01背包问题？

```
目标: 找出一个和为 sum/2 的子集
背包容量为 sum/2
每个物品 weights[i] = values[i] = nums[i]
背包可以正好装满，则找到了子集
```

代码
```c++
bool canPartition(vector<int>& nums) {
    int sum = accumulate(nums);
    if (sum % 2 == 1) return false; // 总和是奇数，肯定找不到子集
    int total = sum / 2; // 背包容量
    vector<vector<int>> dp(nums.size(), vector<int>(total+1));

    for (int i=0; i< nums.size(); i++) {
        dp[i][0] = 0;
    }
    for (int i=0; i<= total; i++) {
        dp[0][i] = nums[0] > i ? 0: nums[0]; // 要检查背包容量 够不够装第一个数
    }

    for (int i=1; i<nums.size(); i++) {
        for (int j=1; j<=total;j++) {
            dp[i][j] = dp[i-1][j];
            // 只有背包容量 能够装下 nums[i] 时，才在两项中取最大值
            if (j - nums[i] >= 0) {
                dp[i][j] = max(
                    dp[i][j],
                    dp[i-1][j-nums[i]] + nums[i]
                );
            }
        }
    }

    return dp[nums.size()-1][total] == total; 
}
```

#### 1049. 最后一块石头
- 和等和子集类似，研究能否划分石头，使其总量和为 sum/2
- 仍然是背包问题
    - 总量 sum/2
    - weight = value
    - 放入或者不放入
- 动规五部曲
    - dp[j]: 容量为j 背包最大价值
    - ...
- 最后返回 dp[sum/2] 和剩余部分的差值
```c++
int accu(vector<int> stones) {
    int total = 0;
    for (int i=0; i<stones.size(); i++) {
        total += stones[i];
    }
    return total;
}
int lastStoneWeightII(vector<int>& stones) {
    int acc = accu(stones);
    vector<int> dp(acc/2+1);

    for (int i=0; i<=acc/2; i++) {
        dp[i] = 0;
    }

    for (int i=0; i<stones.size(); i++) {
        for (int j=acc/2; j>=0; j--) {
            if (j-stones[i] >= 0)  dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]);
        }
    }

    if (dp[acc/2] > acc - dp[acc/2]) {
        return 2 * dp[acc/2] - acc;
    } else {
        return acc - 2 * dp[acc/2];
    }
}
```

#### 494. 目标和
动规五部曲

```
背包的目标容量: (sum + target / 2);
两个集合 a,b a+b = sum, a-b = target
dp[i]: 使背包容量为 i 的方法
dp[i] += dp[i-nums[i]]: i - nums[i] +nums[i] = i; 所以可以累加上后者的方法数
dp[0] = 1, 其他为0 
```

代码
```c++
int accu(vector<int> nums) {
    int acc = 0;
    for (int i=0; i<nums.size(); i++) {
        acc += nums[i];
    }
    return acc;
}
int findTargetSumWays(vector<int>& nums, int target) {
    int acc = accu(nums);
    if ((acc + target) % 2 == 1) return 0; // 目标非整数，是无法实现的
    int goal = (acc + target) / 2;
    if (goal < 0) goal = -goal; // 负的目标可以取对应正值；等于我们将最后得到的集合加上 "-" 好号
    vector<int> dp(goal+1);

    dp[0] = 1;

    for (int i=0; i<nums.size(); i++) { // 先遍历物品
        for (int j=goal; j>=nums[i]; j--) { // 背包容量倒序遍历
            dp[j] += dp[j-nums[i]];
        }
    }

    return dp[goal];
}
```
#### 474. 一和零
动规五部曲
```
dp[x][y]: 最多有x 个0， y个1时，最大子集的大小
dp[x][y] = max(
    dp[x][y],
    dp[x-count[i][0]][y-count[i][1]]
)
dp[0][0] = 0
```

先计算得到每个字符串里头的 0 和 1的数量，存到一个映射表中
```c++
vector<vector<int>> countNum(vector<string> strs) {
    vector<vector<int>> count;
    for (int j=0; j<strs.size(); j++) {
        string str = strs[j];
        count.push_back(vector<int> ({0, 0}));
        // count[i][0]: strs[i] 中 0 的数量
        for (int i=0; i<str.length();i++) {
            if (str.at(i) == '0') count[j][0]++;
            else count[j][1]++;
        }
    }

    return count;
}
```

执行动态规划
```c++
int findMaxForm(vector<string>& strs, int m, int n) {
    vector<vector<int>> count;
    count = countNum(strs);

    vector<vector<int>> dp(m+1, vector<int>(n+1));
    dp[0][0] = 0;

    // 三层循环，内部的 dp 是二维数组v
    for (int i=0; i<strs.size(); i++) {
        for (int j=m; j>=count[i][0]; j--) {
            for (int k=n; k>=count[i][1]; k--) {
                dp[j][k] = max(dp[j][k], dp[j-count[i][0]][k-count[i][1]] + 1);
            }
        }
    }

    return dp[m][n];
}
```
### 动态规划--完全背包问题
N 件物品 最多承重为 W 的背包；
每件物品 weight[i] value[i];
**每件物品可以放入背包无数次**
求背包内物品的最大价值
#### 和01背包的区别 (自己找一个简单的例子，就很容易看出)
01 背包
遍历背包容量时，从大到小; 这样保证所有物品只装入一次
```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

完全背包
遍历背包容量时，从小到大; 每个物品可以装入多次
```c++
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j < bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
```

#### 518. 零钱兑换 II
这一题求的是组合数，如果求排列数则有不同

动规五部曲
```
dp[n]: 容量为n的组合数
dp[n] += dp[n-coins[i]]
dp[0] = 0
```

```c++
int change(int amount, vector<int>& coins) {
    vector<int> dp(amount+1);
    dp[0] = 1;
    sort(coins.begin(), coins.end());
    // 遍历顺序有讲究；先遍历硬币，则代表组合 
    // 假设 coins = [1, 2], 则dp[3] 只包含 {1,2}, 不包含 {2, 1}
    // 如果我们先遍历背包，则求的是排列数
    for (int i=0; i<coins.size(); i++) {
        for (int j=coins[i]; j<=amount; j++) {
            dp[j] += dp[j-coins[i]];
        }
    }
    return dp[amount];
}
```
#### 377. 组合总和4
- 说是组合 实际上是排列
- 遍历顺序：
    - 求组合：外层物品，内层背包
    - 求排列：外层背包，内层物品 （则每个物品放入的顺序可以不同）
```c++
int combinationSum4(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    if (nums.size() == 0 || nums[0] > target) return 0;

    vector<int> dp(target+1);
    dp[0] = 1;
    for (int j=1; j<=target; j++) {
        for (int i=0; i<nums.size() && nums[i] <= j; i++) {
            if (dp[j] < INT_MAX - dp[j - nums[i]]) dp[j] += dp[j-nums[i]];
        }
    }
    return dp[target];
}
```
#### 139. 单词划分
- 完全背包问题
- 背包: s
- 物品：单词，可以取多次

动态规划
```
dp[n]: true 前n个字符构成的子串可以被拆分，false 不可被拆分
dp[i] = dp[j] == true && 子串(i, j) == wordDict[k]
dp[0] = true
遍历顺序无所谓
```

代码
```c++
bool wordBreak(string s, vector<string>& wordDict) {
    vector<bool> dp(s.length() + 1);
    sort(wordDict.begin(), wordDict.end()); // 从短字符串到长字符串排序
    dp[0] = true;
    for (int i=1; i<dp.size(); i++) {
        for (int j=0; j<wordDict.size(); j++) {
            if (wordDict[j].length() > i || !dp[i - wordDict[j].length()]) continue;
            string sub = s.substr(i-wordDict[j].length(), wordDict[j].length());
            if (sub ==  wordDict[j]) {
                dp[i] = true;
            }
        }
    }

    return dp[dp.size()-1];
}
```
## 图论
### 并查集
两个操作:
- 查询 a,b 是否在同一组
- 将元素 a,b 合并为一组

数据结构: 每一组表示为树结构
- 是否在同一组 --> 检查根结点是否一致
- 合并为一组: 修改根结点到一致

代码
```c++
vector<int> parent;

void init(int n) {
  for (int i=0; i<n; i++) {
    parent.push_back(i); // 初始每个节点的父元素指向自己
  }
}

int find(int x) {
  if (x == parent[x]) return x;
  return find(parent[x]); // 沿着树往上找
}

void union(int x, int y) {
  x = find(x);
  y = find(y); // 分别找到根结点
  if (x == y) return;
  parent[y] = x;
}

bool same(int x, int y) {
  return find(x) == find(y);
}
```
#### 200. 岛屿数量

DFS 做法 --将该题理解为找 联通组件的数量

代码
```c++
 int count = 0;
int m, n;
void dfs(vector<vector<char>>& grid, int count, int row, int col) {
    if (row >= m || col >= n || row < 0 || col < 0 || grid[row][col] != '1') return;
    grid[row][col] = '2'; // 设置一个已访问过的标志
    // 上下左右 四个方向进行 DFS 搜索
    dfs(grid, count, row+1, col);
    dfs(grid, count, row, col+1);
    dfs(grid, count, row-1, col);
    dfs(grid, count, row, col-1);
}
int numIslands(vector<vector<char>>& grid) {
    m = grid.size();
    n = grid[0].size();
    
    for (int i=0; i<m; i++) {
        for (int j=0; j<n; j++) {
            // 未访问过的 "1"
            if (grid[i][j] == '1') {
                dfs(grid, count, i, j);
                count++;
            } 
        }
    }
    return count;
}
```

并查集做法
整体思想：遇到相邻的 "1" 结点，就合并集合
最后集合的数量（连通组件的数量）就是岛屿数量
集合数最初为节点总数，每次合并集合，则 count--

```c++
class UnionFind {
private:
    int count = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(vector<vector<char>> grid) {
        int m = grid.size();
        int n = grid[0].size();

        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (grid[i][j] == '0') parent.push_back(-1);
                else {
                  parent.push_back(i* n + j); // 用一个一维数组来存储，实质上是一样的
                  count++;
                }
                rank.push_back(0);
            }
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return; // 已经联合的节点，不需要 count--

        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        
        count--; // 联合之后，连通分量减少
    }

    int getCount() {
        return count;
    }
};

class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        UnionFind UF = UnionFind(grid);
       
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                // 未访问过的 "1"
                if (grid[i][j] == '1') {
                    if (j+1 < n && grid[i][j+1] == '1') UF.unite(i*n+j, i*n+j+1);
                    if (j-1 >= 0 && grid[i][j-1] == '1') UF.unite(i*n+j, i*n+j-1);
                    if (i+1 < m && grid[i+1][j] == '1') UF.unite(i*n+j, (i+1)*n+j);
                    if (i-1 >= 0 && grid[i-1][j] == '1') UF.unite(i*n+j, (i-1)*n+j);
                    grid[i][j] == '0'; // 避免重复访问
                } 
            }
        }
        return UF.getCount();
    }
};
```

##### new UnionFind 和 UnionFind 的区别
- new: Allocates memory for an object or array of objects
    - char* pCharArray = new char[CName::sizeOfBuffer];
- UnionFind: 调用构造函数，返回相应的对象
    - UnionFind UF(grid); // 括号里是构造函数的参数v


### 最小生成树
- 无向图中的一个子图
- tree (连通、无环) spanning (include all vertices)
- 找到这样的树中，权值最小的那个
- 应用: 修一条经过所有村庄的路，保证修路的花费最少

#### Kruscal 算法
https://blog.csdn.net/luomingjun12315/article/details/47700237
思路
```
1. 先将所有边排序（权值小的优先）
2. 按权值分别选择边，并查集中合并两个顶点所在集合；如果顶点已经在同一集合，则不选择该边
3. 直到所有节点都被访问过了 (MST.size() == V())
```

##### 1135
```c++
class UnionFind {
private:
    int count = 0;
    int fee = 0;
    vector<int> parent;
    vector<int> rank;

public:
    UnionFind(int n) {
        count = n;
        for (int i=0; i<=n; i++) {
            parent.push_back(i);
            rank.push_back(0);
        }
    }

    int find(int x) {
        if (x == parent[x]) return x;
        return find(parent[x]);
    }

    int getCount() {
        return count;
    }

    int getFee() {
        return fee;
    }

    void unite(int x, int y, int cost) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (rank[x] < rank[y]) {
            parent[x] = y;
        } else if (rank[x] > rank[y]) {
            parent[y] = x;
        } else {
            parent[y] = x;
            rank[x]++;
        }
        count--;
        // 费用也放在并查集里计算
        // 如果两个点已经在同一个集合中，则不应该加上该费用（不选择该边）
        fee += cost; 
    }
    
};
bool compare(vector<int> a, vector<int> b) {
        return a[2] < b[2];
}
class Solution {
public:
    int minimumCost(int n, vector<vector<int>>& connections) {
        UnionFind UF(n);

        sort(connections.begin(), connections.end(), compare);

        for (int i=0; i<connections.size(); i++) {
            UF.unite(connections[i][0], connections[i][1], connections[i][2]);
            if (UF.getCount() == 1) return UF.getFee();
        }

        return -1; // 没有找到最小生成树

    }
};
```

#### Prim 算法

选择一个点，放入点集 V 中
选择 V -> 非V 的一个权值最小的边，将新的点加入点集 V
直到 V.size() == 点总数

数据结构:
- visited
- minDist[i]: 从集合 V 到结点i的最小距离

先给出图的定义
```c++
struct Vex {
    int v, weight; // 所连接的节点 和权重
}

vector<Vex> graph[V]; // 每个节点，通过一个 vector 存储邻接结点
```

一次 Prim
```c++
// 将 s 加入 V 中
int prim(int s, int n) {
    int newNode, tmpMin, total=0;
    visited[s] = true;

    // 初始化各点到集合 V 的距离
    for (int j=0; j<graph[s].size(); j++) {
        minDist[graph[s][j].v] = graph[s][j].w;
    }

    // 进行 n-1次相关操作
    for (int i=0; i<n-1; i++) {
        // 找到距离最小的那个点
        tmpMin = INF;
        for (int j=0; j<n; j++) {
            if (minDist[j] < tmpMin) {
                tmpMin = minDist[j];
                newNode = j;
            }
        }
        // visited, minDist 更新
        visited[newNode] = true;
        total += tmpMin;

        for (int j=0; j<graph[newNode].size(); j++) {
            if (!visited[graph[newNode][j].v]) {
                minDist[graph[newNode][j].v] = min(graph[s][j].w, minDist[graph[newNode][j].v]);
            }
            
        }
    }
    return total;
}
```

```c++
bool visited[V];
int minDist[v];
// 先把0号结点加入集合
visited[0] = true;
minDist[0] = -1;
for (int i=1; i<V; i++) {
    visited[i] = false;
    if (graph[0][i])
}
```
### 深度优先算法
#### 207. 课程表
时间复杂度还是不够好，没有通过复杂用例
- 基本思路: 通过 DFS 查找是否存在回路，有回路则不能完成所有课程学习
- mark[i] == 1: 由自己启动的 DFS，说明存在回路
- mark[i] == -1：其他节点发起的DFS, 只说明到达i 有多中路径，不代表回路v
```c++
bool dfs(int i, vector<vector<int>> adj, vector<int>& mark) {
    // 1 代表由 i 发起的dfs, 说明存在环
    if (mark[i] == 1) return false;
    // -1 代表其他点发起的 dfs 已经访问过了
    if (mark[i] == -1) return true;
    
    mark[i] = 1;
    for (int w: adj[i]) {
        if(!dfs(w, adj, mark)) return false;
    }

    mark[i] = -1;
    return true;
}
bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
    vector<vector<int>> adj(numCourses, vector<int>());
    vector<int> mark(numCourses);
    for (vector<int> w: prerequisites) {
        adj[w[1]].push_back(w[0]);
    }

    for (int i=0; i<numCourses; i++) {
        if(!dfs(i, adj, mark)) return false;
        // mark.clear();
    }
    return true;
}
```

### 单源最短路径
找到从节点 s 到其他节点的最短路径
#### 数据结构
- distTo[v]: s 到 v 的最短路径长度
- path[v]: s 到 v 的最短路径上的上一个节点
#### Dijkstra 算法
伪代码
```c++
int distTo[];
int path[];
bool visited[];
int findMin(int s) {
    int minV = -1;
    int tmpMin = INF;
    for (int i=0; i<n; i++) {
        if (!visited[i] && distTo[i] < tmpMin) {
            minV = i;
            tmpMin = distTo[i];
        }
    }
    return minV;
}
void dijkstra(int s) {
    // 首先初始化
    for (int i=0; i<n; i++) {
        distTo[i] = INF;
        path[i] = -1;
    }
    // s 的邻接边
    for (int e: weight[s]) {
        distTo[e.to()] = e.weight;
        path[e.to()] = s; 
    }
    // 循环 n-1 次，把所有点遍历过去
    for (int i=n-1; i>0; i--) {
        int des = findMin(s);
        collected[des] = true;
        // 新增一个节点后，相应修改其他点的距离
        for (int e: weights[des]) {
            if (distTo[e.to()] > distTo[des] + e.weight) {
                distTo[e.to()] = distTo[des] + e.weight;
                pathTo[e.to()] = des;
            }
        }
    }
}
```

#### 787. K 站中转内最便宜的航班
在最短路径问题基础上，还增加了最多 k 次中转这个限制
也就是 dist[dst] <= k+1

## 单调栈
- 维护一个单调递增/递减的栈
以 739. 每日温度为例
### 739. 每日温度
- 希望维护一个单调递增的栈
- 如果新元素 <= 栈顶元素，直接入栈即可
- 新元素 > 栈顶元素，则出栈，并执行操作
    - 该出栈元素的天数 = 新元素Index - 出站元素Index
    - 循环该操作，直到 新元素 <= 栈顶元素
```c++
vector<int> dailyTemperatures(vector<int>& temperatures) {
    vector<int> days(temperatures.size());
    // 单调递增栈，存放的是数组下标，实际比较的是值
    stack<int> st;

    for (int i=0; i<temperatures.size(); i++) {
        while (!st.empty()) {
            int prevIndex = st.top();
            if (temperatures[i] > temperatures[prevIndex]) {
                days[prevIndex] = i - prevIndex;
                st.pop();
            } else {
                break;
            }
        }
        st.push(i);
    }

    return days;
}
```

## 综合题
### 42.接雨水
#### 双指针法
我们针对每一列计算能够接的雨水
针对列i, 宽度肯定是1，则雨水面积 min(lHeight, rHeight) - height[i], 只取正值 （不存在负值)
lHeight, rHeight 可以分别往左往右遍历得到
```c++
int trap(vector<int>& height) {
    int lHeight, rHeight;
    int rains=0;
    for (int i=1; i<height.size(); i++) {
        // 第一个柱子 和 最后一个柱子不接雨水
        lHeight = 0, rHeight = 0;
        if (i == height.size() - 1) continue;
        for (int slow = 0; slow < i; slow++) {
            lHeight = max(lHeight, height[slow]);
        }
        for (int fast=i+1; fast < height.size(); fast++) {
            rHeight = max(rHeight, height[fast]);
        }
        int cur = min(lHeight, rHeight) - height[i];
        if (cur <= 0) continue;
        // cout << lHeight << rHeight << height[i] << cur << endl;
        rains = rains + cur;
    }
    return rains;
}
```

#### 动态规划法？存疑
其实我觉得只是双指针法的一个改良
每个位置的lHeight, rHeight 其实可以通过一次遍历来获得，不需要在每次循环内去取。这样可以把复杂度降到 O(n)
```c++
int trap(vector<int>& height) {
    int rains=0;
    vector<int> lMax(height.size());
    vector<int> rMax(height.size());
    lMax[0] = height[0];
    rMax[height.size()-1] = height[height.size()-1];
    for (int i=1; i<height.size(); i++) {
        lMax[i] = max(height[i], lMax[i-1]);
    }
    for (int i=height.size()-2; i>0; i--) {
        rMax[i] = max(height[i], rMax[i+1]);
    }
    for (int i=1; i<height.size(); i++) {
        int cur = min(lMax[i], rMax[i]) - height[i];
        if (cur <= 0) continue;
        rains = rains + cur;
    }
    return rains;
}
```

#### 单调栈法
```
从小到大的单调栈
栈里头存放下标
当前 < 栈顶，则入栈
当前 == 栈顶，栈顶出栈，当前元素入栈（更新下标为最右边的）
当前 > 栈顶，计算水量 (while 循环)
水量 = 长 * 宽
长 = min(height[right], height[left]) - height[mid]
宽 = right - left - 1
```

代码
```c++
int trap(vector<int>& height) {
    int total = 0;
    stack<int> st;
    for (int i=0; i<height.size(); i++) {
        if (st.empty()) {
            st.push(i);
            continue;
        }
        int topIndex = st.top();
        if (height[topIndex] > height[i]) st.push(i);
        else if (height[topIndex] == height[i]) {
            // 遇到相等元素，右边的那个入栈（最新的）
            st.pop();
            st.push(i);
        } else {
            while (!st.empty() && height[i] > height[st.top()]) {
                int midIndex = st.top();
                st.pop();
                if (!st.empty()) {
                    int leftIndex = st.top();
                    total += (i - leftIndex - 1) * (min(height[i], height[leftIndex]) - height[midIndex]);
                }
            }
            
            st.push(i);
            
        }
    }
    return total;
}
```