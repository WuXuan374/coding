### 技术栈总结
- 后端 SQL: sqlachemy
### EdtibaleParameter 组件
#### 哪些内容可以作为props?
- 权限控制
- 非编辑状态下的样式
- onSave: (value) => Promise<void>
- Input 组件自带的属性
#### 组件需要做什么？
- 编辑/非编辑状态
- 记录输入值
- 越界报错
#### 小技巧
##### 如何保证 onSave: (value) => Promise<void> 的格式都是这样的
- 有可能需要更多参数，但我们可以通过柯里化，最终得到只需要一个参数的函数
```javascript
const onSave =
    (key: string, convertFn?: (value: any) => any) =>
      (value: any): Promise<void> => genericSave(key, convertFn ? convertFn(value) : value);  
```

### ConfirmModal 组件：重要操作时的确认弹窗
#### 基本逻辑
- 需要用户输入内容，进行确认，然后才能执行某操作。
#### 哪些内容可以作为props?
- 作为入口的按钮
- Confirm Cancel 后的回调
- 要确认的值
#### 组件需要做什么？
- 输入值与确认值一致，才允许 Confirm
#### 注意点
- 关闭 Modal 后清空所有状态

### 手机端适配
- useMedia 或者自己监听屏幕宽度
- Table 滚动：可以自己写css :overflowX: 'scroll'
- 优先保证某内容宽度: {flex-shrink: 0} 
- Form: labelCol, wrapperCol
- Description: 一行的展示数量

### 服务的 Quota 用量
- 主要就是 sqlachemy 语句，连接几张表

### 服务按照 PSM 聚类
- 首先完成之前的筛选、分页、排序操作
- 数据结构: { id, instances, ... children: [...] }, 外面属性是 psm 信息，children 下是服务信息
- instances, deploy_cnt 通过 reduce()来计算
- 如果 psm 与 服务 ID 一致，就没有 children 了
- 巧妙之处
    * Table 组件能够自动将 children 下的内容，作为展开项，比较方便
    * psm 的数据项 与 服务是一致的，可以用同一套逻辑处理（比如表格内容);同时通过有无 children 还能对两者进行判断
### 文件上传功能
- 整体逻辑：前端文件上传、检查 > 缓存到 TOS > 后端从 TOS 下载文件 > 后端压缩打包文件 > 上传 HDFS
- Bonus: 前后端基于 socket.io, 实时传递和展示上传进度，并且该内容展示是以用户为单位的（不同 Tab, 甚至不同浏览器）
#### 要点
- 文件夹数据 TreeData 的构建：递归
- 上传控制：暂停 继续 终止，基于 g-uploader
- 全局的进度 状态
- 长轮询连接的建立、终止和消息传递
- 通过 localStorage 较为持久化地储存创建状态
- 后端下载进度计算
- 下载时，保存文件夹的结构，并进行压缩
#### Socketio 相关
- namespace: C-S 之间，多个连接的逻辑划分
- rooms: 加入 room 的 Client, 都会接收到服务端返回的信息，类似聊天室的作用。我们可以通过用户名标识 room.
- Redis：在不同服务器实例之间，缓存连接信息

### Bernard Log
- iframe 可以嵌入其他 HTML 页面，但其缺点是无法交互，我们无法修改里头的内容
- 有一些内容显然不能在客户端请求，那么我们可以写一个 Node Server, 把客户端请求转发到 Node Server，再进行请求
    * koa, gulu
#### 小技巧
##### useEffect 里头的定时操作
```javascript
useEffect(() => {
  const timerId = setInterval(() => {
    // do something
  }, 3000);
  // do something
  return (): void => {
    clearInterval(timerId);
  };
}, [dependencies]);   
```
- 代码分析
    * useEffect 的内容，在每次依赖项变化，render 时执行
    * useEffect 的返回值，在每次依赖项变化，需要 render 之前执行，清除了定时器
    * return 是一个闭包函数，可以访问外部函数作用域的变量
    * 整个 useEffect 函数的调用，在组件 unmount 时才结束。所以在组件 unmount 之前，闭包都存在，里头的变量也始终存在（不会被回收），那么 timerId 就存在。
        - 更准确地说，两次 render 之间， timerId 是没被回收的； render时， clearInterval + setInterval, 又生成一个新的 timerId
##### zlib 的解压结果在回调函数里，如何获取该解压结果，并作为整个函数的返回值？
- 在外层包一个 Promise, 变成一个异步操作，通过async await 来获得结果
